# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1980, Bill Huang
# This file is distributed under the same license as the EvoX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: EvoX\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-19 13:58+0800\n"
"PO-Revision-Date: 2025-01-17 13:53+0000\n"
"Last-Translator: BillHuang <bill.huang2001@gmail.com>\n"
"Language-Team: Chinese (Simplified Han script) <https://hosted.weblate.org/projects/evox/evox/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/apidocs/evox/evox.md:1
#, python-brace-format
msgid "{py:mod}`evox`"
msgstr "{py:mod}`evox`"

#: ../../source/apidocs/evox/evox.algorithms.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.md:10
#: ../../source/apidocs/evox/evox.md:10
#: ../../source/apidocs/evox/evox.operators.md:10
#: ../../source/apidocs/evox/evox.problems.md:10
msgid "Subpackages"
msgstr "子包"

#: ../../source/apidocs/evox/evox.algorithms.md:20
#: ../../source/apidocs/evox/evox.algorithms.mo.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:31
#: ../../source/apidocs/evox/evox.algorithms.so.md:21
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:26
#: ../../source/apidocs/evox/evox.core.md:20
#: ../../source/apidocs/evox/evox.md:26
#: ../../source/apidocs/evox/evox.metrics.md:21
#: ../../source/apidocs/evox/evox.operators.crossover.md:21
#: ../../source/apidocs/evox/evox.operators.md:22
#: ../../source/apidocs/evox/evox.operators.mutation.md:19
#: ../../source/apidocs/evox/evox.operators.sampling.md:21
#: ../../source/apidocs/evox/evox.operators.selection.md:22
#: ../../source/apidocs/evox/evox.problems.md:29
#: ../../source/apidocs/evox/evox.problems.numerical.md:21
#: ../../source/apidocs/evox/evox.utils.md:22
#: ../../source/apidocs/evox/evox.workflows.md:20
msgid "Package Contents"
msgstr "软件包内容"

#: ../../source/apidocs/evox/evox.algorithms.md:22
#: ../../source/apidocs/evox/evox.algorithms.mo.md:26
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:44
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:26
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:33
#: ../../source/apidocs/evox/evox.algorithms.so.md:23
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:28
#: ../../source/apidocs/evox/evox.core.md:22
#: ../../source/apidocs/evox/evox.md:28
#: ../../source/apidocs/evox/evox.metrics.md:23
#: ../../source/apidocs/evox/evox.operators.crossover.md:23
#: ../../source/apidocs/evox/evox.operators.md:24
#: ../../source/apidocs/evox/evox.operators.mutation.md:21
#: ../../source/apidocs/evox/evox.operators.sampling.md:23
#: ../../source/apidocs/evox/evox.operators.selection.md:24
#: ../../source/apidocs/evox/evox.problems.md:31
#: ../../source/apidocs/evox/evox.utils.md:24
#: ../../source/apidocs/evox/evox.utils.op_register.md:52
#: ../../source/apidocs/evox/evox.utils.re_export.md:12
#: ../../source/apidocs/evox/evox.workflows.md:22
msgid "Data"
msgstr "数据"

#: ../../source/apidocs/evox/evox.md:34
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.__all__>`"
msgstr "{py:obj}`__all__ <evox.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.md:34
#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.md:38
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:36
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:64
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:52
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:38
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:48
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.adam_step.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:45
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:28
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.sort_utils.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:40
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:28
#: ../../source/apidocs/evox/evox.core.components.md:36
#: ../../source/apidocs/evox/evox.core.md:34
#: ../../source/apidocs/evox/evox.core.module.md:54
#: ../../source/apidocs/evox/evox.md:40
#: ../../source/apidocs/evox/evox.metrics.gd.md:24
#: ../../source/apidocs/evox/evox.metrics.hv.md:24
#: ../../source/apidocs/evox/evox.metrics.igd.md:24
#: ../../source/apidocs/evox/evox.metrics.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:36
#: ../../source/apidocs/evox/evox.operators.crossover.md:35
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:24
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:24
#: ../../source/apidocs/evox/evox.operators.md:36
#: ../../source/apidocs/evox/evox.operators.mutation.md:33
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:24
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:28
#: ../../source/apidocs/evox/evox.operators.sampling.md:35
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:24
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:24
#: ../../source/apidocs/evox/evox.operators.selection.md:36
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:64
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:28
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:28
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:36
#: ../../source/apidocs/evox/evox.problems.md:43
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:24
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:36
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:88
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:38
#: ../../source/apidocs/evox/evox.problems.numerical.md:113
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:80
#: ../../source/apidocs/evox/evox.utils.md:36
#: ../../source/apidocs/evox/evox.utils.op_register.md:64
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:24
#: ../../source/apidocs/evox/evox.utils.re_export.md:24
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:40
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:44
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:24
#: ../../source/apidocs/evox/evox.workflows.md:34
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:24
msgid "API"
msgstr "API"

#: ../../source/apidocs/evox/evox.md:46
msgid ""
"['core', 'utils', 'algorithms', 'problems', 'workflows', 'operators', "
"'vis_tools', 'metrics', 'Modul..."
msgstr ""
"['core', 'utils', 'algorithms', 'problems', 'workflows', 'operators', "
"'vis_tools', 'metrics', 'Modul..."

#: ../../source/apidocs/evox/evox.algorithms.md:1
#, python-brace-format
msgid "{py:mod}`evox.algorithms`"
msgstr "{py:mod}`evox.algorithms`"

#: ../../source/apidocs/evox/evox.algorithms.md:28
#, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.md:40
#: ../../source/apidocs/evox/evox.algorithms.so.md:41
msgid ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."
msgstr ""
"['DE', 'SHADE', 'CoDE', 'SaDE', 'ODE', 'JaDE', 'OpenES', 'XNES', "
"'SeparableNES', 'DES', 'SNES', 'ARS..."

#: ../../source/apidocs/evox/evox.algorithms.mo.md:1
#, python-brace-format
msgid "{py:mod}`evox.algorithms.mo`"
msgstr "{py:mod}`evox.algorithms.mo`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:10
#: ../../source/apidocs/evox/evox.core.md:10
#: ../../source/apidocs/evox/evox.metrics.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.md:10
#: ../../source/apidocs/evox/evox.operators.selection.md:10
#: ../../source/apidocs/evox/evox.problems.md:20
#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.md:10
#: ../../source/apidocs/evox/evox.utils.md:10
#: ../../source/apidocs/evox/evox.vis_tools.md:10
#: ../../source/apidocs/evox/evox.workflows.md:10
msgid "Submodules"
msgstr "子模块"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:32
#, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.mo.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.md:44
msgid "['HypE', 'MOEAD', 'NSGA2', 'NSGA3', 'RVEA', 'RVEAa']"
msgstr "['HypE', 'MOEAD', 'NSGA2', 'NSGA3', 'RVEA', 'RVEAa']"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.hype`"
msgstr "{py:mod}`evox.algorithms.mo.hype`"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:10
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.adam_step.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.sort_utils.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:10
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:10
#: ../../source/apidocs/evox/evox.core.components.md:10
#: ../../source/apidocs/evox/evox.core.module.md:10
#: ../../source/apidocs/evox/evox.metrics.gd.md:10
#: ../../source/apidocs/evox/evox.metrics.hv.md:10
#: ../../source/apidocs/evox/evox.metrics.igd.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:10
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:10
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:10
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:10
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:10
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:10
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:10
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:10
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:10
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:10
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:10
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:10
#: ../../source/apidocs/evox/evox.utils.op_register.md:10
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:10
#: ../../source/apidocs/evox/evox.utils.re_export.md:10
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:10
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:10
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:10
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:10
msgid "Module Contents"
msgstr "模块内容"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:12
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:12
#: ../../source/apidocs/evox/evox.core.components.md:12
#: ../../source/apidocs/evox/evox.core.module.md:12
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:12
#: ../../source/apidocs/evox/evox.problems.numerical.md:23
#: ../../source/apidocs/evox/evox.utils.op_register.md:12
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:12
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:12
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:12
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:12
msgid "Classes"
msgstr "类"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`HypE <evox.algorithms.mo.hype.HypE>`"
msgstr "{py:obj}`HypE <evox.algorithms.mo.hype.HypE>`"

#: ../../../src/evox/algorithms/mo/hype.py:20
#: ../../../src/evox/algorithms/mo/hype.py:52
msgid "The tensorized version of HypE algorithm."
msgstr "HypE算法的张量化版本。"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:24
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:24
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.adam_step.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.sort_utils.md:12
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:12
#: ../../source/apidocs/evox/evox.core.module.md:26
#: ../../source/apidocs/evox/evox.metrics.gd.md:12
#: ../../source/apidocs/evox/evox.metrics.hv.md:12
#: ../../source/apidocs/evox/evox.metrics.igd.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:12
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:12
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:12
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:12
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:12
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:12
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:12
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:12
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:52
#: ../../source/apidocs/evox/evox.problems.numerical.md:77
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:12
#: ../../source/apidocs/evox/evox.utils.op_register.md:32
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:24
#: ../../source/apidocs/evox/evox.vis_tools.plot.md:12
msgid "Functions"
msgstr "函数"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:30
#, fuzzy, python-brace-format
msgid "{py:obj}`cal_hv <evox.algorithms.mo.hype.cal_hv>`"
msgstr "{py:obj}`cal_hv <evox.algorithms.mo.hype.cal_hv>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:49
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:49
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:121
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:30
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:108
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:94
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:34
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:63
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:30
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:30
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.Algorithm`"
msgstr "基础: {py:obj}`evox.core.Algorithm`"

#: ../../../src/evox/algorithms/mo/hype.py:54
#: ../../../src/evox/algorithms/mo/moead.py:54
#: ../../../src/evox/algorithms/mo/nsga2.py:36
#: ../../../src/evox/algorithms/mo/nsga3.py:126
#: ../../../src/evox/algorithms/mo/rvea.py:36
#: ../../../src/evox/algorithms/mo/rveaa.py:38
msgid "References"
msgstr "参考文献"

#: ../../../src/evox/algorithms/mo/hype.py:55
msgid ""
"[1] J. Bader and E. Zitzler, \"HypE: An algorithm for fast hypervolume-based"
" many-objective optimization,\"     Evolutionary Computation, vol. 19, no. "
"1, pp. 45-76, 2011. Available:     https://direct.mit.edu/evco/article-"
"abstract/19/1/45/1363/HypE-An-Algorithm-for-Fast-Hypervolume-Based-Many"
msgstr ""
"[1] J. Bader and E. Zitzler, \"HypE: An algorithm for fast hypervolume-based"
" many-objective optimization,\" Evolutionary Computation, vol. 19, no. 1, "
"pp. 45-76, 2011. Available: https://direct.mit.edu/evco/article-"
"abstract/19/1/45/1363/HypE-An-Algorithm-for-Fast-Hypervolume-Based-Many"

#: ../../../src/evox/algorithms/mo/hype.py:59
#: ../../../src/evox/algorithms/mo/nsga2.py:41
msgid ""
"[2] Z. Liang, H. Li, N. Yu, K. Sun, and R. Cheng, \"Bridging Evolutionary "
"Multiobjective Optimization and     GPU Acceleration via Tensorization,\" "
"IEEE Transactions on Evolutionary Computation, 2025. Available:     "
"https://ieeexplore.ieee.org/document/10944658"
msgstr ""
"[2] Z. Liang, H. Li, N. Yu, K. Sun, 和 R. Cheng, \"Bridging Evolutionary "
"Multiobjective Optimization and GPU Acceleration via Tensorization,\" IEEE "
"Transactions on Evolutionary Computation, 2025. Available: "
"https://ieeexplore.ieee.org/document/10944658"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md:54
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:54
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:126
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:35
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:113
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:99
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:39
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:68
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:35
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:35
#: ../../source/apidocs/evox/evox.core.components.md:47
#: ../../source/apidocs/evox/evox.core.components.md:104
#: ../../source/apidocs/evox/evox.core.components.md:128
#: ../../source/apidocs/evox/evox.core.components.md:168
#: ../../source/apidocs/evox/evox.core.module.md:79
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:47
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:72
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:104
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:35
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:35
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:35
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:99
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:123
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:147
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:171
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:195
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:219
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:243
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:267
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:35
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:49
#: ../../source/apidocs/evox/evox.problems.numerical.md:124
#: ../../source/apidocs/evox/evox.problems.numerical.md:148
#: ../../source/apidocs/evox/evox.problems.numerical.md:172
#: ../../source/apidocs/evox/evox.problems.numerical.md:196
#: ../../source/apidocs/evox/evox.problems.numerical.md:220
#: ../../source/apidocs/evox/evox.problems.numerical.md:244
#: ../../source/apidocs/evox/evox.problems.numerical.md:268
#: ../../source/apidocs/evox/evox.problems.numerical.md:292
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:35
#: ../../source/apidocs/evox/evox.vis_tools.exv.md:63
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:35
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:35
msgid "Initialization"
msgstr "初始化"

#: ../../../src/evox/algorithms/mo/hype.py:58
msgid "Initializes the HypE algorithm."
msgstr "初始化 HypE 算法。"

#: ../../source/apidocs/evox/evox.algorithms.mo.hype.md
#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md
#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md
#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md
#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.problems.numerical.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.op_register.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.exv.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md
#: ../../source/apidocs/evox/evox.workflows.std_workflow.md
msgid "Parameters"
msgstr "参数"

#: ../../../src/evox/algorithms/mo/hype.py:60
#: ../../../src/evox/algorithms/mo/moead.py:60
#: ../../../src/evox/algorithms/mo/nsga2.py:41
#: ../../../src/evox/algorithms/mo/nsga3.py:132
#: ../../../src/evox/algorithms/mo/rvea.py:41
#: ../../../src/evox/algorithms/mo/rveaa.py:41
#: ../../../src/evox/algorithms/so/de_variants/code.py:119
#: ../../../src/evox/algorithms/so/de_variants/de.py:41
#: ../../../src/evox/algorithms/so/de_variants/jade.py:41
#: ../../../src/evox/algorithms/so/de_variants/ode.py:41
#: ../../../src/evox/algorithms/so/de_variants/sade.py:105
#: ../../../src/evox/algorithms/so/de_variants/shade.py:41
#: ../../../src/evox/algorithms/so/es_variants/ars.py:41
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:41
#: ../../../src/evox/algorithms/so/es_variants/des.py:41
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:41
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:41
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:41
#: ../../../src/evox/algorithms/so/es_variants/open_es.py:41
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:41
#: ../../../src/evox/algorithms/so/es_variants/snes.py:41
#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:41
msgid "The size of the population."
msgstr "种群大小。"

#: ../../../src/evox/algorithms/mo/hype.py:61
#: ../../../src/evox/algorithms/mo/moead.py:61
#: ../../../src/evox/algorithms/mo/nsga2.py:42
#: ../../../src/evox/algorithms/mo/nsga3.py:133
#: ../../../src/evox/algorithms/mo/rvea.py:42
#: ../../../src/evox/algorithms/mo/rveaa.py:42
msgid "The number of objective functions in the optimization problem."
msgstr "优化问题中的目标函数数量。"

#: ../../../src/evox/algorithms/mo/hype.py:62
#: ../../../src/evox/algorithms/mo/moead.py:62
#: ../../../src/evox/algorithms/mo/nsga2.py:43
#: ../../../src/evox/algorithms/mo/nsga3.py:134
msgid "The lower bounds for the decision variables (1D tensor)."
msgstr "决策变量的下界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/hype.py:63
#: ../../../src/evox/algorithms/mo/moead.py:63
#: ../../../src/evox/algorithms/mo/nsga2.py:44
#: ../../../src/evox/algorithms/mo/nsga3.py:135
msgid "The upper bounds for the decision variables (1D tensor)."
msgstr "决策变量的上界（1D 张量）。"

#: ../../../src/evox/algorithms/mo/hype.py:64
msgid "The number of samples for hypervolume calculation (optional)."
msgstr "用于计算超体积的样本数量（可选）。"

#: ../../../src/evox/algorithms/mo/hype.py:65
#: ../../../src/evox/algorithms/mo/moead.py:64
#: ../../../src/evox/algorithms/mo/nsga2.py:45
#: ../../../src/evox/algorithms/mo/nsga3.py:136
#: ../../../src/evox/algorithms/mo/rvea.py:48
#: ../../../src/evox/algorithms/mo/rveaa.py:48
msgid "The selection operation for evolutionary strategy (optional)."
msgstr "进化策略的选择操作（可选）。"

#: ../../../src/evox/algorithms/mo/hype.py:66
#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
#: ../../../src/evox/algorithms/mo/nsga3.py:137
msgid ""
"The mutation operation, defaults to polynomial_mutation if not provided "
"(optional)."
msgstr "基因突变操作，该选项的缺省值是 `polynomial_mutation`，如果未提供，则使用默认值 (可选)。"

#: ../../../src/evox/algorithms/mo/hype.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:47
#: ../../../src/evox/algorithms/mo/nsga3.py:138
msgid ""
"The crossover operation, defaults to simulated_binary if not provided "
"(optional)."
msgstr "交叉操作，如果未提供（可选），默认为 simulated_binary。"

#: ../../../src/evox/algorithms/mo/hype.py:68
#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
#: ../../../src/evox/algorithms/mo/nsga3.py:140
msgid ""
"The device on which computations should run (optional). Defaults to "
"PyTorch's default device."
msgstr "计算应该运行的设备（可选）。默认为 PyTorch 的默认设备。"

#: ../../../src/evox/algorithms/mo/hype.py:65
#: ../../../src/evox/algorithms/mo/moead.py:65
#: ../../../src/evox/algorithms/mo/nsga2.py:46
#: ../../../src/evox/algorithms/mo/nsga3.py:137
#: ../../../src/evox/algorithms/mo/rvea.py:46
#: ../../../src/evox/algorithms/mo/rveaa.py:46
msgid "Perform the initialization step of the workflow."
msgstr "执行工作流的初始化步骤。"

#: ../../../src/evox/algorithms/mo/hype.py:67
#: ../../../src/evox/algorithms/mo/moead.py:67
#: ../../../src/evox/algorithms/mo/nsga2.py:48
#: ../../../src/evox/algorithms/mo/nsga3.py:139
#: ../../../src/evox/algorithms/mo/rvea.py:48
#: ../../../src/evox/algorithms/mo/rveaa.py:48
#: ../../../src/evox/workflows/std_workflow.py:69
msgid ""
"Calls the `init_step` of the algorithm if overwritten; otherwise, its `step`"
" method will be invoked."
msgstr "调用算法的 `init_step` 如果被重写；否则，将调用其 `step` 方法。"

#: ../../../src/evox/algorithms/mo/hype.py:73
#: ../../../src/evox/algorithms/mo/nsga2.py:54
#: ../../../src/evox/algorithms/mo/nsga3.py:145
msgid "Perform the optimization step of the workflow."
msgstr "执行工作流的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:1
#, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.moead`"
msgstr "{py:mod}`evox.algorithms.mo.moead`"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:18
#, python-brace-format
msgid "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"
msgstr "{py:obj}`MOEAD <evox.algorithms.mo.moead.MOEAD>`"

#: ../../../src/evox/algorithms/mo/moead.py:20
#: ../../../src/evox/algorithms/mo/moead.py:52
msgid "Implementation of the Original MOEA/D algorithm."
msgstr "原始 MOEA/D 算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.mo.moead.md:30
#, python-brace-format
msgid "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"
msgstr "{py:obj}`pbi <evox.algorithms.mo.moead.pbi>`"

#: ../../../src/evox/algorithms/mo/moead.py:55
msgid ""
"[1] Q. Zhang and H. Li, \"MOEA/D: A Multiobjective Evolutionary Algorithm "
"Based on Decomposition,\"     IEEE Transactions on Evolutionary Computation,"
" vol. 11, no. 6, pp. 712-731, 2007. Available:     "
"https://ieeexplore.ieee.org/document/4358754"
msgstr ""
"[1] Q. Zhang and H. Li, \"MOEA/D: A Multiobjective Evolutionary Algorithm "
"Based on Decomposition,\" IEEE Transactions on Evolutionary Computation, "
"vol. 11, no. 6, pp. 712-731, 2007. Available: "
"https://ieeexplore.ieee.org/document/4358754"

#: ../../../src/evox/algorithms/mo/moead.py:59
msgid ""
"This implementation closely follows the original paper and reference code. "
"It is not optimized for tensorized computation and may therefore be less "
"efficient on GPU."
msgstr "此实现严格遵循原始论文和参考代码。它未针对张量化计算进行优化，因此在GPU上的效率可能较低。"

#: ../../../src/evox/algorithms/mo/moead.py:58
msgid "Initializes the MOEA/D algorithm."
msgstr "初始化 MOEA/D 算法。"

#: ../../../src/evox/algorithms/mo/moead.py:66
msgid ""
"The crossover operation, defaults to simulated_binary_half if not provided "
"(optional)."
msgstr "交叉操作，如果未提供，则默认为 simulated_binary_half（可选）。"

#: ../../../src/evox/algorithms/mo/moead.py:73
msgid "Perform a single optimization step of the workflow."
msgstr "执行工作流程的单个优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:1
#, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.nsga2`"
msgstr "{py:mod}`evox.algorithms.mo.nsga2`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga2.md:18
#, python-brace-format
msgid "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"
msgstr "{py:obj}`NSGA2 <evox.algorithms.mo.nsga2.NSGA2>`"

#: ../../../src/evox/algorithms/mo/nsga2.py:20
#: ../../../src/evox/algorithms/mo/nsga2.py:33
msgid ""
"A tensorized implementation of the Non-dominated Sorting Genetic Algorithm "
"II (NSGA-II) for multi-objective optimization problems."
msgstr "一个面向多目标优化问题的非支配排序遗传算法 II（NSGA-II）的张量化实现。"

#: ../../../src/evox/algorithms/mo/nsga2.py:37
msgid ""
"[1] K. Deb, A. Pratap, S. Agarwal, and T. Meyarivan, \"A fast and elitist "
"multiobjective genetic algorithm: NSGA-II,\"     IEEE Transactions on "
"Evolutionary Computation, vol. 6, no. 2, pp. 182-197, 2002.     Available: "
"https://ieeexplore.ieee.org/document/996017"
msgstr ""
"[1] K. Deb, A. Pratap, S. Agarwal, and T. Meyarivan, \"A fast and elitist "
"multiobjective genetic algorithm: NSGA-II,\" IEEE Transactions on "
"Evolutionary Computation, vol. 6, no. 2, pp. 182-197, 2002. Available: "
"https://ieeexplore.ieee.org/document/996017"

#: ../../../src/evox/algorithms/mo/nsga2.py:39
msgid "Initializes the NSGA-II algorithm."
msgstr "初始化 NSGA-II 算法。"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.nsga3`"
msgstr "{py:mod}`evox.algorithms.mo.nsga3`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`NSGA3 <evox.algorithms.mo.nsga3.NSGA3>`"
msgstr "{py:obj}`NSGA3 <evox.algorithms.mo.nsga3.NSGA3>`"

#: ../../../src/evox/algorithms/mo/nsga3.py:20
#: ../../../src/evox/algorithms/mo/nsga3.py:124
msgid ""
"An implementation of the tensorized NSGA-III for many-objective optimization"
" problems."
msgstr "一个用于多目标优化问题的张量化NSGA-III算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:30
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_get_table_row_inner "
"<evox.algorithms.mo.nsga3._get_table_row_inner>`"
msgstr ""
"{py:obj}`_get_table_row_inner "
"<evox.algorithms.mo.nsga3._get_table_row_inner>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:34
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_select_from_index_by_min_inner "
"<evox.algorithms.mo.nsga3._select_from_index_by_min_inner>`"
msgstr ""
"{py:obj}`_select_from_index_by_min_inner "
"<evox.algorithms.mo.nsga3._select_from_index_by_min_inner>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:38
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_get_extreme_inner <evox.algorithms.mo.nsga3._get_extreme_inner>`"
msgstr ""
"{py:obj}`_get_extreme_inner <evox.algorithms.mo.nsga3._get_extreme_inner>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:50
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`vmap_get_table_row <evox.algorithms.mo.nsga3.vmap_get_table_row>`"
msgstr ""
"{py:obj}`vmap_get_table_row <evox.algorithms.mo.nsga3.vmap_get_table_row>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:54
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`vmap_select_from_index_by_min "
"<evox.algorithms.mo.nsga3.vmap_select_from_index_by_min>`"
msgstr ""
"{py:obj}`vmap_select_from_index_by_min "
"<evox.algorithms.mo.nsga3.vmap_select_from_index_by_min>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:58
#, fuzzy, python-brace-format
msgid "{py:obj}`vmap_get_extreme <evox.algorithms.mo.nsga3.vmap_get_extreme>`"
msgstr ""
"{py:obj}`vmap_get_extreme <evox.algorithms.mo.nsga3.vmap_get_extreme>`"

#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:77
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:94
#: ../../source/apidocs/evox/evox.algorithms.mo.nsga3.md:111
msgid "'vmap(...)'"
msgstr "'vmap(...)'"

#: ../../../src/evox/algorithms/mo/nsga3.py:127
msgid ""
"[1] K. Deb and H. Jain, \"An Evolutionary Many-Objective Optimization "
"Algorithm Using Reference-Point-Based     Nondominated Sorting Approach, "
"Part I: Solving Problems With Box Constraints,\" IEEE Transactions on "
"Evolutionary     Computation, vol. 18, no. 4, pp. 577-601, 2014. Available: "
"https://ieeexplore.ieee.org/document/6600851"
msgstr ""
"[1] K. Deb 和 H. Jain，“一种基于参考点的非支配排序方法的演化多目标优化算法，第 I 部分: 使用盒约束求解问题，”《IEEE "
"Transactions on Evolutionary Computation》，第 18 卷，第 4 期，第 577-601 页，2014。链接: "
"https://ieeexplore.ieee.org/document/6600851"

#: ../../../src/evox/algorithms/mo/nsga3.py:131
msgid ""
"[2] H. Li, Z. Liang, and R. Cheng, \"GPU-accelerated Evolutionary Many-"
"objective Optimization Using Tensorized     NSGA-III,\" in 2025 IEEE "
"Congress on Evolutionary Computation, 2025."
msgstr ""
"[2] H. Li, Z. Liang, and R. Cheng, \"GPU-accelerated Evolutionary Many-"
"objective Optimization Using Tensorized NSGA-III,\" in 2025 IEEE Congress on"
" Evolutionary Computation, 2025."

#: ../../../src/evox/algorithms/mo/nsga3.py:130
msgid "Initializes the NSGA-III algorithm."
msgstr "初始化 NSGA-III 算法。"

#: ../../../src/evox/algorithms/mo/nsga3.py:139
msgid ""
"The data type for the decision variables (optional). Defaults to "
"torch.float32."
msgstr "决策变量的数据类型（可选）。默认值为torch.float32。"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:1
#, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.rvea`"
msgstr "{py:mod}`evox.algorithms.mo.rvea`"

#: ../../source/apidocs/evox/evox.algorithms.mo.rvea.md:18
#, python-brace-format
msgid "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"
msgstr "{py:obj}`RVEA <evox.algorithms.mo.rvea.RVEA>`"

#: ../../../src/evox/algorithms/mo/rvea.py:20
#: ../../../src/evox/algorithms/mo/rvea.py:33
msgid ""
"A tensorized implementation of the Reference Vector Guided Evolutionary "
"Algorithm (RVEA) for multi-objective optimization problems."
msgstr "一个针对多目标优化问题的参考向量引导演化算法（RVEA）的张量化实现。"

#: ../../../src/evox/algorithms/mo/rvea.py:37
#: ../../../src/evox/algorithms/mo/rveaa.py:39
msgid ""
"[1] R. Cheng, Y. Jin, M. Olhofer, and B. Sendhoff, \"A reference vector "
"guided evolutionary algorithm     for many-objective optimization,\" IEEE "
"Transactions on Evolutionary Computation, vol. 20, no. 5,     pp. 773-791, "
"2016. Available: https://ieeexplore.ieee.org/document/7386636"
msgstr ""
"[1] R. Cheng, Y. Jin, M. Olhofer, and B. Sendhoff, \"A reference vector "
"guided evolutionary algorithm for many-objective optimization,\" IEEE "
"Transactions on Evolutionary Computation, vol. 20, no. 5, pp. 773-791, 2016."
" Available: https://ieeexplore.ieee.org/document/7386636"

#: ../../../src/evox/algorithms/mo/rvea.py:41
msgid ""
"[2] Z. Liang, T. Jiang, K. Sun, and R. Cheng, \"GPU-accelerated Evolutionary"
" Multiobjective Optimization     Using Tensorized RVEA,\" in Proceedings of "
"the Genetic and Evolutionary Computation Conference,     ser. GECCO ’24, "
"2024, pp. 566–575. Available: https://doi.org/10.1145/3638529.3654223"
msgstr ""
"[2] Z. Liang, T. Jiang, K. Sun, and R. Cheng, \"GPU-accelerated Evolutionary"
" Multiobjective Optimization Using Tensorized RVEA,\" in Proceedings of the "
"Genetic and Evolutionary Computation Conference, ser. GECCO ’24, 2024, pp. "
"566–575. Available: https://doi.org/10.1145/3638529.3654223"

#: ../../../src/evox/algorithms/mo/rvea.py:39
msgid "Initialize the RVEA algorithm with the given parameters."
msgstr "使用给定参数初始化RVEA算法。"

#: ../../../src/evox/algorithms/mo/rvea.py:43
#: ../../../src/evox/algorithms/mo/rveaa.py:43
#: ../../../src/evox/operators/mutation/pm_mutation.py:34
msgid "The lower bounds for the decision variables."
msgstr "**决策变量的下限值**"

#: ../../../src/evox/algorithms/mo/rvea.py:44
#: ../../../src/evox/algorithms/mo/rveaa.py:44
#: ../../../src/evox/operators/mutation/pm_mutation.py:35
msgid "The upper bounds for the decision variables."
msgstr "决策变量的上限界值。"

#: ../../../src/evox/algorithms/mo/rvea.py:45
#: ../../../src/evox/algorithms/mo/rveaa.py:45
msgid ""
"A parameter for controlling the rate of change of penalty. Defaults to 2."
msgstr "一个参数，用于控制惩罚的变化速率。默认值为 2。"

#: ../../../src/evox/algorithms/mo/rvea.py:46
#: ../../../src/evox/algorithms/mo/rveaa.py:46
msgid "The frequency of reference vector adaptation. Defaults to 0.1."
msgstr "引用向量适应的频率。默认为 0.1。"

#: ../../../src/evox/algorithms/mo/rvea.py:47
#: ../../../src/evox/algorithms/mo/rveaa.py:47
msgid "The maximum number of generations. Defaults to 100."
msgstr "最大世代数。默认为 100。"

#: ../../../src/evox/algorithms/mo/rvea.py:49
#: ../../../src/evox/algorithms/mo/rveaa.py:49
msgid "The mutation operation (optional)."
msgstr "变异操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:50
#: ../../../src/evox/algorithms/mo/rveaa.py:50
msgid "The crossover operation (optional)."
msgstr "交叉操作（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:51
#: ../../../src/evox/algorithms/mo/rveaa.py:51
msgid "The device on which computations should run (optional)."
msgstr "运行计算的设备（可选）。"

#: ../../../src/evox/algorithms/mo/rvea.py:86
#: ../../../src/evox/algorithms/mo/rveaa.py:110
msgid "Perform a single optimization step."
msgstr "执行单次优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.mo.rveaa`"
msgstr "{py:mod}`evox.algorithms.mo.rveaa`"

#: ../../source/apidocs/evox/evox.algorithms.mo.rveaa.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`RVEAa <evox.algorithms.mo.rveaa.RVEAa>`"
msgstr "{py:obj}`RVEAa <evox.algorithms.mo.rveaa.RVEAa>`"

#: ../../../src/evox/algorithms/mo/rveaa.py:20
#: ../../../src/evox/algorithms/mo/rveaa.py:33
msgid ""
"An implementation of the Reference Vector Guided Evolutionary Algorithm "
"embedded with the reference vector regeneration strategy (RVEAa) for multi-"
"objective optimization problems."
msgstr "一个参考向量引导的演化算法（RVEAa）的实现，嵌入了参考向量重生成策略，用于多目标优化问题。"

#: ../../../src/evox/algorithms/mo/rveaa.py:36
msgid ""
"This class is designed to solve multi-objective optimization problems using "
"a reference vector guided evolutionary algorithm."
msgstr "这类是设计用来使用参考向量引导的进化算法来解决多目标优化问题的。"

#: ../../../src/evox/algorithms/mo/rveaa.py:39
msgid "Initialize the RVEAa algorithm with the given parameters."
msgstr "使用给定参数初始化 RVEAa 算法。"

#: ../../source/apidocs/evox/evox.algorithms.so.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so`"
msgstr "{py:mod}`evox.algorithms.so`"

#: ../../source/apidocs/evox/evox.algorithms.so.md:29
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.so.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.so.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants`"
msgstr "{py:mod}`evox.algorithms.so.de_variants`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:32
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.so.de_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.so.de_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.md:44
msgid "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"
msgstr "['DE', 'CoDE', 'JaDE', 'ODE', 'SaDE', 'SHADE']"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.code`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.code`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`CoDE <evox.algorithms.so.de_variants.code.CoDE>`"
msgstr "{py:obj}`CoDE <evox.algorithms.so.de_variants.code.CoDE>`"

#: ../../../src/evox/algorithms/so/de_variants/code.py:20
#: ../../../src/evox/algorithms/so/de_variants/code.py:111
msgid "The implementation of CoDE algorithm."
msgstr "CoDE算法实现"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:30
#, fuzzy, python-brace-format
msgid "{py:obj}`rand_1_bin <evox.algorithms.so.de_variants.code.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.so.de_variants.code.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:34
#, fuzzy, python-brace-format
msgid "{py:obj}`rand_2_bin <evox.algorithms.so.de_variants.code.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.so.de_variants.code.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:38
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`current2rand_1 "
"<evox.algorithms.so.de_variants.code.current2rand_1>`"
msgstr ""
"{py:obj}`current2rand_1 "
"<evox.algorithms.so.de_variants.code.current2rand_1>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:42
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`rand2best_2_bin "
"<evox.algorithms.so.de_variants.code.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin "
"<evox.algorithms.so.de_variants.code.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:46
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.so.de_variants.code.current2pbest_1_bin>`"
msgstr ""
"{py:obj}`current2pbest_1_bin "
"<evox.algorithms.so.de_variants.code.current2pbest_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:58
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:54
msgid "[0, 0, 1, 0]"
msgstr "[0, 0, 1, 0]"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:68
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:64
msgid "[0, 0, 2, 0]"
msgstr "[0, 0, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:78
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:84
msgid "[0, 0, 1, 2]"
msgstr "[0, 0, 1, 2]"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:88
#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:74
msgid "[0, 1, 2, 0]"
msgstr "[0, 1, 2, 0]"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.code.md:98
msgid "[3, 2, 1, 0]"
msgstr "[3, 2, 1, 0]"

#: ../../../src/evox/algorithms/so/de_variants/code.py:113
msgid ""
"Reference: Wang Y, Cai Z, Zhang Q. Differential evolution with composite "
"trial vector generation strategies and control parameters[J]. IEEE "
"transactions on evolutionary computation, 2011, 15(1): 55-66."
msgstr ""
"参考文献: Wang Y, Cai Z, Zhang Q. 使用复合试验向量生成策略和控制参数的差分进化[J]. IEEE 进化计算交易, 2011, "
"15(1): 55-66."

#: ../../../src/evox/algorithms/so/de_variants/code.py:117
msgid "Initialize the CoDE algorithm with the given parameters."
msgstr "使用给定的参数初始化 CoDE 算法。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:120
#: ../../../src/evox/algorithms/so/de_variants/de.py:42
#: ../../../src/evox/algorithms/so/de_variants/jade.py:42
#: ../../../src/evox/algorithms/so/de_variants/sade.py:106
#: ../../../src/evox/algorithms/so/de_variants/shade.py:42
msgid "The lower bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:121
#: ../../../src/evox/algorithms/so/de_variants/de.py:43
#: ../../../src/evox/algorithms/so/de_variants/jade.py:43
#: ../../../src/evox/algorithms/so/de_variants/sade.py:107
#: ../../../src/evox/algorithms/so/de_variants/shade.py:43
msgid "The upper bounds of the search space. Must be a 1D tensor."
msgstr "搜索空间的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:122
msgid "The number of differential padding vectors to use. Defaults to 5."
msgstr "使用的差分填充向量数量。默认值为 5。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:123
msgid ""
"A tensor of control parameter pairs for the algorithm. Defaults to a "
"predefined tensor."
msgstr "算法的控制参数对的张量。默认为预定义的张量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:124
msgid ""
"A boolean indicating whether to replace individuals in the population. "
"Defaults to False."
msgstr "一个布尔值，指示是否替换种群中的个体。默认为 False。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:125
#: ../../../src/evox/algorithms/so/de_variants/de.py:50
#: ../../../src/evox/algorithms/so/de_variants/ode.py:50
msgid "The device to use for tensor computations. Defaults to None."
msgstr "用于张量计算的设备。默认为 None。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:124
msgid "Perform one iteration of the CoDE algorithm."
msgstr "执行CoDE算法的一次迭代。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:126
msgid "This step is composed of the following steps:"
msgstr "此步骤由以下步骤组成："

#: ../../../src/evox/algorithms/so/de_variants/code.py:127
msgid "Generate trial vectors using the differential sum."
msgstr "使用微分和生成试验向量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:128
msgid "Apply crossover to generate a new vector."
msgstr "应用交叉生成一个新向量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:129
msgid "Apply mutation to generate a new vector."
msgstr "应用变异以生成新向量。"

#: ../../../src/evox/algorithms/so/de_variants/code.py:130
msgid "Update the population and fitness values."
msgstr "更新种群和适应度。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.de`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.de`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.de.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`DE <evox.algorithms.so.de_variants.de.DE>`"
msgstr "{py:obj}`DE <evox.algorithms.so.de_variants.de.DE>`"

#: ../../../src/evox/algorithms/so/de_variants/de.py:20
#: ../../../src/evox/algorithms/so/de_variants/de.py:33
msgid "Differential Evolution (DE) algorithm for optimization."
msgstr "差分进化（DE）算法用于优化。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:37
msgid ""
"`__init__`: Initializes the DE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`: 使用给定的参数初始化 DE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:38
#: ../../../src/evox/algorithms/so/de_variants/jade.py:38
#: ../../../src/evox/algorithms/so/de_variants/ode.py:38
msgid ""
"`init_step`: Performs the initial evaluation of the population's fitness and"
" proceeds to the first optimization step."
msgstr "`init_step`: 执行种群适应度的初始评估，并进入第一次优化步骤。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:39
msgid ""
"`step`: Executes a single optimization step of the DE algorithm, involving "
"mutation, crossover, and selection processes."
msgstr "`step`：执行DE算法的单个优化步骤，包括变异、交叉和选择过程。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:41
#: ../../../src/evox/algorithms/so/de_variants/jade.py:41
#: ../../../src/evox/algorithms/so/de_variants/ode.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class. It is expected"
" to be provided by the `Problem` class or another external component."
msgstr "请注意，`evaluate` 方法在这个类中未定义。它预计由 `Problem` 类或其他外部组件提供。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:39
msgid "Initialize the DE algorithm with the given parameters."
msgstr "使用给定的参数初始化 DE 算法。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:44
#: ../../../src/evox/algorithms/so/de_variants/ode.py:44
msgid ""
"The base vector type used in mutation. Either \"best\" or \"rand\". Defaults"
" to \"rand\"."
msgstr "用于变异的基础向量类型。可以是 \"best\" 或 \"rand\"。默认值为 \"rand\"。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:45
#: ../../../src/evox/algorithms/so/de_variants/jade.py:44
#: ../../../src/evox/algorithms/so/de_variants/ode.py:45
msgid ""
"The number of difference vectors used in mutation. Must be at least 1 and "
"less than half of the population size. Defaults to 1."
msgstr "在变异中使用的差异向量的数量。必须至少为 1 且小于种群大小的一半。默认为 1。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor. Defaults to 0.5."
msgstr "施加于差异向量的差异权重 (F)。可以是浮点数或张量。默认为 0.5。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:47
msgid "The crossover probability (CR). Defaults to 0.9."
msgstr "交叉概率（CR）。默认为 0.9。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:48
#: ../../../src/evox/algorithms/so/de_variants/jade.py:45
msgid ""
"The mean for initializing the population with a normal distribution. "
"Defaults to None."
msgstr "用于使用正态分布初始化种群的均值。默认值为 None。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:49
#: ../../../src/evox/algorithms/so/de_variants/jade.py:46
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Defaults to None."
msgstr "用于用正态分布初始化种群的标准差。默认为 None。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:46
#: ../../../src/evox/algorithms/so/de_variants/jade.py:46
#: ../../../src/evox/algorithms/so/de_variants/ode.py:46
msgid ""
"Perform the initial evaluation of the population's fitness and proceed to "
"the first optimization step."
msgstr "执行种群适应度的初步评估，并进入第一个优化步骤。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:48
#: ../../../src/evox/algorithms/so/de_variants/jade.py:48
#: ../../../src/evox/algorithms/so/de_variants/ode.py:48
msgid ""
"This method evaluates the fitness of the initial population and then calls "
"the `step` method to perform the first optimization iteration."
msgstr "此方法评估初始种群的适应度，然后调用 `step` 方法进行第一次优化迭代。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:54
msgid "Execute a single optimization step of the DE algorithm."
msgstr "执行 DE 算法的单步优化。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:56
#: ../../../src/evox/algorithms/so/de_variants/jade.py:56
#: ../../../src/evox/algorithms/so/de_variants/ode.py:56
#: ../../../src/evox/algorithms/so/de_variants/sade.py:128
#: ../../../src/evox/algorithms/so/de_variants/shade.py:48
msgid "This involves the following sub-steps:"
msgstr "这涉及以下子步骤："

#: ../../../src/evox/algorithms/so/de_variants/de.py:57
#: ../../../src/evox/algorithms/so/de_variants/ode.py:57
msgid ""
"Mutation: Generate mutant vectors based on the specified base vector "
"strategy (`best` or `rand`) and the number of difference vectors."
msgstr "Mutation: 生成基准向量策略 (`best` 或 `rand`) 和差异向量数量的基础上，根据这些信息生成变异向量"

#: ../../../src/evox/algorithms/so/de_variants/de.py:58
#: ../../../src/evox/algorithms/so/de_variants/ode.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability."
msgstr "交叉：根据交叉概率，在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:59
#: ../../../src/evox/algorithms/so/de_variants/jade.py:59
#: ../../../src/evox/algorithms/so/de_variants/ode.py:59
msgid ""
"Selection: Evaluate the fitness of the new population and select the better "
"individuals between the current and new populations."
msgstr "选择：评估新种群的适应度，并在当前种群和新种群之间选择更优的个体。"

#: ../../../src/evox/algorithms/so/de_variants/de.py:61
#: ../../../src/evox/algorithms/so/de_variants/ode.py:62
msgid ""
"The method ensures that all new population vectors are clamped within the "
"specified bounds."
msgstr "这个方法确保新种群向量都会被截断在指定范围内。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.jade`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.jade`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`JaDE <evox.algorithms.so.de_variants.jade.JaDE>`"
msgstr "{py:obj}`JaDE <evox.algorithms.so.de_variants.jade.JaDE>`"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:20
#: ../../../src/evox/algorithms/so/de_variants/jade.py:33
msgid "Adaptive Differential Evolution (JaDE) algorithm for optimization."
msgstr "自适应差分进化算法 JaDE，用于优化任务。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:37
msgid ""
"`__init__`: Initializes the JaDE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：用给定的参数初始化 JaDE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:39
msgid ""
"`step`: Executes a single optimization step of the JaDE algorithm, involving"
" mutation, crossover, selection, and adaptation of strategy parameters."
msgstr "`step`: 执行 JaDE 算法的单个优化步骤，涉及突变、交叉、选择和策略参数的适应性。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:39
msgid "Initialize the JaDE algorithm with the given parameters."
msgstr "根据给定的参数初始化 JaDE 算法。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:47
#: ../../../src/evox/algorithms/so/de_variants/sade.py:110
#: ../../../src/evox/algorithms/so/de_variants/shade.py:45
msgid ""
"The device to use for tensor computations (e.g., \"cpu\" or \"cuda\"). "
"Defaults to None."
msgstr "用于张量计算的设备（例如，“cpu”或“cuda”）。默认为 None。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:48
msgid ""
"The learning rate for updating the adaptive parameters F_u and CR_u. "
"Defaults to 0.1."
msgstr "自适应参数 F_u 和 CR_u 更新的学习率。默认值为 0.1。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:54
msgid "Execute a single optimization step of the JaDE algorithm."
msgstr "执行JaDE算法的单次优化步骤。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:57
msgid ""
"Mutation: Generate mutant vectors by combining difference vectors and "
"adapting the mutation factor F."
msgstr "变异：通过结合差异向量并调整变异因子 F 来生成突变向量。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:58
msgid ""
"Crossover: Perform crossover between the current population and the mutant "
"vectors based on the crossover probability CR."
msgstr "交叉：根据交叉概率 CR 在当前种群和变异向量之间执行交叉。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:60
msgid ""
"Adaptation: Update the adaptive parameters F_u and CR_u based on the "
"successful mutations."
msgstr "自适应参数的更新：根据成功的突变来更新参数F_u和CR_u。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:62
msgid "Select p-best vectors from the population for mutation."
msgstr "从种群中选择 p-best 向量进行变异。"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:64
msgid ""
"Fraction of the population to consider as top-p best. Must be between 0 and "
"1."
msgstr "考虑为 top-p 最佳的群体比例。必须在 0 和 1 之间。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.jade.md
#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md
#: ../../source/apidocs/evox/evox.core.components.md
#: ../../source/apidocs/evox/evox.core.module.md
#: ../../source/apidocs/evox/evox.metrics.gd.md
#: ../../source/apidocs/evox/evox.metrics.hv.md
#: ../../source/apidocs/evox/evox.metrics.igd.md
#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md
#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md
#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md
#: ../../source/apidocs/evox/evox.operators.sampling.gird.md
#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md
#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md
#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md
#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md
#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md
#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md
#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md
#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md
#: ../../source/apidocs/evox/evox.vis_tools.plot.md
msgid "Returns"
msgstr "返回值"

#: ../../../src/evox/algorithms/so/de_variants/jade.py:65
msgid "A tensor containing selected p-best vectors."
msgstr "包含选定的 p-best 向量的张量。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.ode`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.ode`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.ode.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`ODE <evox.algorithms.so.de_variants.ode.ODE>`"
msgstr "{py:obj}`ODE <evox.algorithms.so.de_variants.ode.ODE>`"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:20
#: ../../../src/evox/algorithms/so/de_variants/ode.py:33
msgid ""
"Opposition-based Differential Evolution (ODE) algorithm for optimization."
msgstr "反对基差差分进化 (ODE) 算法用于优化。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:37
msgid ""
"`__init__`: Initializes the ODE algorithm with the given parameters, "
"including population size, bounds, mutation strategy, and other "
"hyperparameters."
msgstr "`__init__`：使用给定的参数初始化 ODE 算法，包括种群大小、边界、变异策略和其他超参数。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:39
msgid ""
"`step`: Executes a single optimization step of the ODE algorithm, involving "
"mutation, crossover, selection, and opposition-based mechanisms."
msgstr "`step`: 执行ODE算法的单个优化步骤，包括变异、交叉、选择和基于对抗的机制。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:39
msgid ""
"Initialize the Opposition-based Differential Evolution (ODE) algorithm with "
"the given parameters."
msgstr "使用给定的参数初始化基于对抗的差分进化（ODE）算法。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:42
#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:42
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:42
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:41
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:42
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:45
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:42
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:42
msgid "The lower bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的下界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:43
#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:43
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:43
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:43
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:46
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:43
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:43
msgid "The upper bounds of the particle positions. Must be a 1D tensor."
msgstr "粒子位置的上界。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:46
msgid ""
"The differential weight(s) (F) applied to difference vectors. Can be a float"
" or a tensor of shape [num_difference_vectors]. Defaults to 0.5."
msgstr "应用于差异向量的差异权重 (F)。可以是一个浮点数或形状为 [num_difference_vectors] 的张量。默认值为 0.5。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:47
msgid "The crossover probability (CR). Must be in (0, 1]. Defaults to 0.9."
msgstr "交叉概率（CR）。必须在（0，1]之间。默认值为0.9。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:48
msgid ""
"The mean for initializing the population with a normal distribution. Must be"
" provided with stdev if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的均值。如果使用，则必须提供标准差（stdev）。默认为 None。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:49
msgid ""
"The standard deviation for initializing the population with a normal "
"distribution. Must be provided with mean if used. Defaults to None."
msgstr "用于通过正态分布初始化种群的标准差。若使用，则必须提供均值。默认为 None。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:54
msgid "Execute a single optimization step of the ODE algorithm."
msgstr "执行 ODE 算法的单次优化步骤。"

#: ../../../src/evox/algorithms/so/de_variants/ode.py:60
msgid ""
"Opposition-Based Mechanism: Generate opposition-based population, evaluate "
"their fitness, and perform selection to potentially replace current "
"individuals with their opposites if they are better."
msgstr "对立机制：生成对立种群，评估它们的适应度，并进行选择，以便在它们更好的情况下，潜在地用它们的对立个体替换当前个体。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.sade`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.sade`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`SaDE <evox.algorithms.so.de_variants.sade.SaDE>`"
msgstr "{py:obj}`SaDE <evox.algorithms.so.de_variants.sade.SaDE>`"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:20
#: ../../../src/evox/algorithms/so/de_variants/sade.py:97
msgid "The implementation of SaDE algorithm."
msgstr "SaDE算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:30
#, fuzzy, python-brace-format
msgid "{py:obj}`rand_1_bin <evox.algorithms.so.de_variants.sade.rand_1_bin>`"
msgstr "{py:obj}`rand_1_bin <evox.algorithms.so.de_variants.sade.rand_1_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:34
#, fuzzy, python-brace-format
msgid "{py:obj}`rand_2_bin <evox.algorithms.so.de_variants.sade.rand_2_bin>`"
msgstr "{py:obj}`rand_2_bin <evox.algorithms.so.de_variants.sade.rand_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:38
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`rand2best_2_bin "
"<evox.algorithms.so.de_variants.sade.rand2best_2_bin>`"
msgstr ""
"{py:obj}`rand2best_2_bin "
"<evox.algorithms.so.de_variants.sade.rand2best_2_bin>`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.sade.md:42
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`current2rand_1 "
"<evox.algorithms.so.de_variants.sade.current2rand_1>`"
msgstr ""
"{py:obj}`current2rand_1 "
"<evox.algorithms.so.de_variants.sade.current2rand_1>`"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:99
msgid ""
"Reference: Qin A K, Huang V L, Suganthan P N. Differential evolution "
"algorithm with strategy adaptation for global numerical optimization[J]. "
"IEEE transactions on Evolutionary Computation, 2008, 13(2): 398-417."
msgstr ""
"参考：Qin A K, Huang V L, Suganthan P N. Differential evolution algorithm with "
"strategy adaptation for global numerical optimization[J]. IEEE transactions "
"on Evolutionary Computation, 2008, 13(2): 398-417."

#: ../../../src/evox/algorithms/so/de_variants/sade.py:103
msgid "Initialize the SaDE algorithm with the given parameters."
msgstr "用给定的参数初始化SaDE算法。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:108
#: ../../../src/evox/algorithms/so/de_variants/shade.py:44
msgid "The number of differential padding vectors to use. Defaults to 9."
msgstr "差分填充向量的数量。默认值为 9。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:109
msgid "The size of memory. Defaults to 50."
msgstr "内存大小。默认为 50。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:126
msgid "Execute a single optimization step of the SaDE algorithm."
msgstr "执行 SaDE 算法的单次优化步骤。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:129
msgid "Generate new population using differential evolution."
msgstr "使用差分进化生成新种群。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:130
msgid "Evaluate the fitness of the new population."
msgstr "评估新种群的适应度。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:131
msgid "Update the best individual and best fitness."
msgstr "更新最佳个体和最佳适应度。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:132
msgid "Update the success and failure memory."
msgstr "更新成功和失败的记忆。"

#: ../../../src/evox/algorithms/so/de_variants/sade.py:133
msgid "Update the CR memory."
msgstr "更新 CR 内存。"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.de_variants.shade`"
msgstr "{py:mod}`evox.algorithms.so.de_variants.shade`"

#: ../../source/apidocs/evox/evox.algorithms.so.de_variants.shade.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`SHADE <evox.algorithms.so.de_variants.shade.SHADE>`"
msgstr "{py:obj}`SHADE <evox.algorithms.so.de_variants.shade.SHADE>`"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:20
#: ../../../src/evox/algorithms/so/de_variants/shade.py:33
msgid "The implementation of SHADE algorithm."
msgstr "SHADE 算法的实现。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:35
msgid ""
"Reference: Tanabe R, Fukunaga A. Success-history based parameter adaptation "
"for differential evolution[C]//2013 IEEE congress on evolutionary "
"computation. IEEE, 2013: 71-78."
msgstr ""
"参考文献: Tanabe R, Fukunaga A. Success-history based parameter adaptation for "
"differential evolution[C]//2013 IEEE congress on evolutionary computation. "
"IEEE, 2013: 71-78."

#: ../../../src/evox/algorithms/so/de_variants/shade.py:39
msgid "Initialize the SHADE algorithm with the given parameters."
msgstr "用给定的参数初始化SHADE算法。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:46
msgid "Perform a single step of the SHADE algorithm."
msgstr "执行 SHADE 算法的单步操作。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:49
msgid "Generate trial vectors using the SHADE algorithm."
msgstr "使用SHADE算法生成试验向量。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:50
msgid "Evaluate the fitness of the trial vectors."
msgstr "评估试验向量的适应度。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:51
msgid "Update the population."
msgstr "更新种群。"

#: ../../../src/evox/algorithms/so/de_variants/shade.py:52
msgid "Update the memory."
msgstr "更新记忆。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants`"
msgstr "{py:mod}`evox.algorithms.so.es_variants`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:39
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.so.es_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.so.es_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.md:51
msgid ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."
msgstr ""
"['OpenES', 'XNES', 'SeparableNES', 'DES', 'SNES', 'ARS', 'ASEBO', "
"'PersistentES', 'NoiseReuseES', 'G..."

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.adam_step.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.adam_step`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.adam_step`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.adam_step.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.so.es_variants.adam_step.adam_single_tensor>`"
msgstr ""
"{py:obj}`adam_single_tensor "
"<evox.algorithms.so.es_variants.adam_step.adam_single_tensor>`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.ars`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.ars`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.ars.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`ARS <evox.algorithms.so.es_variants.ars.ARS>`"
msgstr "{py:obj}`ARS <evox.algorithms.so.es_variants.ars.ARS>`"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:20
#: ../../../src/evox/algorithms/so/es_variants/ars.py:33
msgid "The implementation of the ARS algorithm."
msgstr "ARS算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:35
msgid ""
"Reference: Simple random search provides a competitive approach to "
"reinforcement learning (https://arxiv.org/pdf/1803.07055.pdf)"
msgstr ""
"参考文献：Simple random search provides a competitive approach to reinforcement "
"learning (https://arxiv.org/pdf/1803.07055.pdf)"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:38
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:39
#: ../../../src/evox/algorithms/so/es_variants/des.py:39
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:39
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:39
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:39
#: ../../../src/evox/algorithms/so/es_variants/snes.py:39
msgid ""
"This code has been inspired by or utilizes the algorithmic implementation "
"from evosax. More information about evosax can be found at the following "
"URL: GitHub Link: https://github.com/RobertTLange/evosax"
msgstr ""
"这段代码受到了 evosax 中算法实现的启发或使用了其实现。有关 evosax 的更多信息，请访问以下网址：GitHub "
"链接：https://github.com/RobertTLange/evosax"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:39
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:39
msgid "Initialize the ARS algorithm with the given parameters."
msgstr "使用给定参数初始化ARS算法。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:42
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:42
#: ../../../src/evox/algorithms/so/es_variants/des.py:42
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:42
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:42
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:42
#: ../../../src/evox/algorithms/so/es_variants/open_es.py:42
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:42
#: ../../../src/evox/algorithms/so/es_variants/snes.py:42
msgid "The initial center of the population. Must be a 1D tensor."
msgstr "种群的初始中心。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:43
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:43
msgid "The ratio of elite population. Defaults to 0.1."
msgstr "精英种群的比例。默认为 0.1。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:44
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:44
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:44
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:44
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:44
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:44
msgid "The learning rate for the optimizer. Defaults to 0.05."
msgstr "优化器的学习率。默认值为 0.05。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:45
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:47
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:45
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:45
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:45
msgid "The standard deviation of the noise. Defaults to 0.03."
msgstr "噪声的标准差。默认为 0.03。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:46
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:43
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:47
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:43
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:43
#: ../../../src/evox/algorithms/so/es_variants/open_es.py:45
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:43
#: ../../../src/evox/algorithms/so/es_variants/snes.py:43
msgid ""
"The optimizer to use. Defaults to None. Currently, only \"adam\" or None is "
"supported."
msgstr "使用的优化器（optimizer）。 默认情况下为 None。 仅 support \"adam\" 或 None。\n"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:47
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:51
#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:45
#: ../../../src/evox/algorithms/so/es_variants/des.py:45
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:48
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:49
#: ../../../src/evox/algorithms/so/es_variants/nes.py:53
#: ../../../src/evox/algorithms/so/es_variants/nes.py:80
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:50
#: ../../../src/evox/algorithms/so/es_variants/open_es.py:47
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:50
#: ../../../src/evox/algorithms/so/es_variants/snes.py:48
#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:47
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:47
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:53
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:50
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:47
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:47
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:47
msgid "The device to use for the tensors. Defaults to None."
msgstr "设备的使用者（设备用于存放张量的硬件）。默认为 None。"

#: ../../../src/evox/algorithms/so/es_variants/ars.py:46
msgid "Perform a single step of the ARS algorithm."
msgstr "执行 ARS 算法的单步操作。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.asebo`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.asebo`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.asebo.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`ASEBO <evox.algorithms.so.es_variants.asebo.ASEBO>`"
msgstr "{py:obj}`ASEBO <evox.algorithms.so.es_variants.asebo.ASEBO>`"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:20
#: ../../../src/evox/algorithms/so/es_variants/asebo.py:33
msgid "The implementation of the ASEBO algorithm."
msgstr "ASEBO 算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:35
msgid ""
"Reference: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"
msgstr ""
"参考文献: From Complexity to Simplicity: Adaptive ES-Active Subspaces for "
"Blackbox Optimization (https://arxiv.org/abs/1903.04268)"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:45
msgid "The decay factor for the learning rate. Defaults to 1.0."
msgstr "学习率的衰减因子。默认为 1.0。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:46
msgid "The minimum value for the learning rate. Defaults to 0.001."
msgstr "学习率的最小值。默认为 0.001。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:48
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:45
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:46
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:46
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:46
msgid "The decay factor for the standard deviation. Defaults to 1.0."
msgstr "标准差的衰减因子。默认为 1.0。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:49
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:46
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:47
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:47
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:47
msgid "The minimum value for the standard deviation. Defaults to 0.01."
msgstr "标准差的最小值。默认值为 0.01。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:50
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:48
msgid "The dimension of the subspace. Defaults to None."
msgstr "子空间的维度。默认为 None。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:46
msgid "The main step of the ASEBO algorithm."
msgstr "ASEBO 算法的主要步骤。"

#: ../../../src/evox/algorithms/so/es_variants/asebo.py:48
msgid ""
"This function first computes the subspace spanned by the gradient of the "
"fitness function and then projects the gradient onto the subspace. It then "
"computes the step direction using the projected gradient and updates the "
"center and standard deviation of the search distribution."
msgstr ""
"此函数首先计算由适应度函数的梯度所张成的子空间，然后将梯度投影到该子空间。接着，它使用投影后的梯度计算步长方向，并更新搜索分布的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.cma_es`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.cma_es`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.cma_es.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`CMAES <evox.algorithms.so.es_variants.cma_es.CMAES>`"
msgstr "{py:obj}`CMAES <evox.algorithms.so.es_variants.cma_es.CMAES>`"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:20
#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:33
msgid ""
"The CMA-ES algorithm as described in \"The CMA Evolution Strategy: A "
"Tutorial\" from https://arxiv.org/abs/1604.00772."
msgstr ""
"CMA-ES 算法，详见 \"The CMA Evolution Strategy: A Tutorial\" "
"(https://arxiv.org/abs/1604.00772)。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:39
msgid "Initialize the CMA-ES algorithm with the given parameters."
msgstr "使用给定的参数初始化 CMA-ES 算法。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:41
msgid "The size of the population with the notation \\lambda."
msgstr "种群的规模使用符号 \\lambda 表示。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:42
msgid "The initial mean of the population. Must be a 1D tensor."
msgstr "种群的初始均值。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:43
msgid "The overall standard deviation, i.e., the step size of the algorithm."
msgstr "整体标准差，即算法的步长。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:44
msgid ""
"The recombination weights of the population. Defaults to None and is "
"calculated automatically with recommended values."
msgstr "种群的重组权重。默认为 None，并根据推荐值自动计算。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:46
msgid "The main step of the CMA-ES algorithm."
msgstr "CMA-ES算法的主要步骤。"

#: ../../../src/evox/algorithms/so/es_variants/cma_es.py:48
msgid ""
"In this step, the algorithm generates a new population, evaluates it, and "
"updates the mean, covariance matrix, and step size correspondingly."
msgstr "在这一步，算法生成一个新种群，评估它，并相应地更新均值、协方差矩阵和步长。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.des`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.des`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.des.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`DES <evox.algorithms.so.es_variants.des.DES>`"
msgstr "{py:obj}`DES <evox.algorithms.so.es_variants.des.DES>`"

#: ../../../src/evox/algorithms/so/es_variants/des.py:20
#: ../../../src/evox/algorithms/so/es_variants/des.py:33
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:20
#: ../../../src/evox/algorithms/so/es_variants/esmc.py:33
msgid "The implementation of the DES algorithm."
msgstr "DES算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/des.py:35
msgid ""
"Reference: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"
msgstr ""
"参考文献: Discovering Evolution Strategies via Meta-Black-Box Optimization "
"(https://arxiv.org/abs/2211.11260)"

#: ../../../src/evox/algorithms/so/es_variants/des.py:39
msgid "Initialize the DES algorithm with the given parameters."
msgstr "用给定的参数初始化DES算法。"

#: ../../../src/evox/algorithms/so/es_variants/des.py:43
msgid "The temperature parameter for the softmax. Defaults to 12.5."
msgstr "软max的温度参数。默认为12.5。"

#: ../../../src/evox/algorithms/so/es_variants/des.py:44
msgid "The initial standard deviation of the noise. Defaults to 0.1."
msgstr "噪声的初始标准差。默认为 0.1。"

#: ../../../src/evox/algorithms/so/es_variants/des.py:46
msgid ""
"Step the DES algorithm by sampling the population, evaluating the fitness, "
"and updating the center."
msgstr "通过对种群进行采样、评估适应度和更新中心，逐步执行DES算法。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.esmc`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.esmc`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.esmc.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`ESMC <evox.algorithms.so.es_variants.esmc.ESMC>`"
msgstr "{py:obj}`ESMC <evox.algorithms.so.es_variants.esmc.ESMC>`"

#: ../../../src/evox/algorithms/so/es_variants/esmc.py:35
msgid ""
"Reference: Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"
msgstr ""
"参考文献：Learn2Hop: Learned Optimization on Rough Landscapes "
"(https://proceedings.mlr.press/v139/merchant21a.html)"

#: ../../../src/evox/algorithms/so/es_variants/esmc.py:39
msgid "Initialize the ESMC algorithm with the given parameters."
msgstr "用给定的参数初始化ESMC算法。"

#: ../../../src/evox/algorithms/so/es_variants/esmc.py:46
msgid "One iteration of the ESMC algorithm."
msgstr "ESMC算法的一次迭代。"

#: ../../../src/evox/algorithms/so/es_variants/esmc.py:48
msgid ""
"This function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "此函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.guided_es`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.guided_es`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.guided_es.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`GuidedES <evox.algorithms.so.es_variants.guided_es.GuidedES>`"
msgstr ""
"{py:obj}`GuidedES <evox.algorithms.so.es_variants.guided_es.GuidedES>`"

#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:20
#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:33
msgid "The implementation of the Guided-ES algorithm."
msgstr "Guided-ES 算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:35
msgid ""
"Reference: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"
msgstr ""
"参考文献: Guided evolutionary strategies: Augmenting random search with "
"surrogate gradients (https://arxiv.org/abs/1806.10230)"

#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:39
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:39
msgid "Initialize the Guided-ES algorithm with the given parameters."
msgstr "用给定的参数初始化 Guided-ES 算法。"

#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:46
msgid "Run one step of the Guided-ES algorithm."
msgstr "运行 Guided-ES 算法的一步。"

#: ../../../src/evox/algorithms/so/es_variants/guided_es.py:48
#: ../../../src/evox/algorithms/so/es_variants/snes.py:48
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and standard deviation of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估他们的适应度，然后使用抽样的种群更新算法的中心和标准差。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.nes`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.nes`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`XNES <evox.algorithms.so.es_variants.nes.XNES>`"
msgstr "{py:obj}`XNES <evox.algorithms.so.es_variants.nes.XNES>`"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:20
#: ../../../src/evox/algorithms/so/es_variants/nes.py:37
msgid "The implementation of the xNES algorithm."
msgstr "xNES 算法的实现。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.nes.md:22
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`SeparableNES <evox.algorithms.so.es_variants.nes.SeparableNES>`"
msgstr ""
"{py:obj}`SeparableNES <evox.algorithms.so.es_variants.nes.SeparableNES>`"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:24
#: ../../../src/evox/algorithms/so/es_variants/nes.py:66
msgid "The implementation of the Separable NES algorithm."
msgstr "可分 NES 算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:39
msgid ""
"Reference: Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"
msgstr ""
"参考文献：Exponential Natural Evolution Strategies "
"(https://dl.acm.org/doi/abs/10.1145/1830483.1830557)"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:43
msgid "Initialize the xNES algorithm with the given parameters."
msgstr "使用给定的参数初始化 xNES 算法。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:45
#: ../../../src/evox/algorithms/so/es_variants/nes.py:74
msgid "The initial mean vector of the population. Must be a 1D tensor."
msgstr "种群的初始均值向量。必须是一个一维张量。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:46
msgid "The initial covariance matrix of the population. Must be a 2D tensor."
msgstr "种群的初始协方差矩阵。必须是一个二维张量。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:47
#: ../../../src/evox/algorithms/so/es_variants/nes.py:76
msgid "The size of the population. Defaults to None."
msgstr "种群的大小。默认值为 None。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:48
#: ../../../src/evox/algorithms/so/es_variants/nes.py:77
msgid "The recombination weights of the population. Defaults to None."
msgstr "种群的重组权重。默认为 None。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:49
#: ../../../src/evox/algorithms/so/es_variants/nes.py:78
msgid "The learning rate for the mean vector. Defaults to None."
msgstr "均值向量的学习率。默认值为 None。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:50
#: ../../../src/evox/algorithms/so/es_variants/nes.py:79
msgid "The learning rate for the variance vector. Defaults to None."
msgstr "方差向量的学习率。默认为 None。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:51
msgid "The learning rate for the B matrix. Defaults to None."
msgstr "B 矩阵的学习率。默认值为 None。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:52
msgid ""
"Whether to use the covariance matrix as a Cholesky factorization result. "
"Defaults to False."
msgstr "是否将协方差矩阵用作 Cholesky 分解的结果。默认为 False。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:50
msgid "Run one step of the xNES algorithm."
msgstr "运行 xNES 算法的一步。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:52
#: ../../../src/evox/algorithms/so/es_variants/nes.py:81
msgid ""
"The function will sample a population, evaluate their fitness, and then "
"update the center and covariance of the algorithm using the sampled "
"population."
msgstr "该函数将对一个种群进行抽样，评估它们的适应度，然后使用抽样的种群更新算法的中心和协方差。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:68
#: ../../../src/evox/algorithms/so/es_variants/snes.py:35
msgid ""
"Reference: Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"
msgstr ""
"参考文献：Natural Evolution Strategies "
"(https://www.jmlr.org/papers/volume15/wierstra14a/wierstra14a.pdf)"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:72
msgid "Initialize the Separable NES algorithm with the given parameters."
msgstr "使用给定参数初始化 Separable NES 算法。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:75
msgid ""
"The initial standard deviation for each dimension. Must be a 1D tensor."
msgstr "每个维度的初始标准差。必须是一个 1D 张量。"

#: ../../../src/evox/algorithms/so/es_variants/nes.py:79
msgid "Run one step of the Separable NES algorithm."
msgstr "运行 Separable NES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.noise_reuse_es`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.noise_reuse_es`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.noise_reuse_es.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.so.es_variants.noise_reuse_es.NoiseReuseES>`"
msgstr ""
"{py:obj}`NoiseReuseES "
"<evox.algorithms.so.es_variants.noise_reuse_es.NoiseReuseES>`"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:20
#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:33
msgid "The implementation of the Noise-Reuse-ES algorithm."
msgstr "噪声重用ES算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:35
msgid ""
"Reference: Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"
msgstr ""
"参考文献：Noise-Reuse in Online Evolution Strategies "
"(https://arxiv.org/pdf/2304.12180.pdf)"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:48
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:48
msgid "The inner problem length. Defaults to 100."
msgstr "内部问题长度。默认为 100。"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:49
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:49
msgid "The number of inner problems. Defaults to 10."
msgstr "内部问题的数量。默认值为 10。"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:46
msgid "Take a single step of the NoiseReuseES algorithm."
msgstr "执行 NoiseReuseES 算法的一步操作。"

#: ../../../src/evox/algorithms/so/es_variants/noise_reuse_es.py:48
msgid ""
"This function follows the algorithm described in the reference paper. It "
"first generates a set of perturbations for the current population. Then, it "
"evaluates the fitness of the population with the perturbations. Afterwards, "
"it calculates the gradient of the policy parameters using the perturbations "
"and the fitness. Finally, it updates the policy parameters using the "
"gradient and the learning rate."
msgstr ""
"此函数遵循参考论文中描述的算法。它首先为当前族群生成一组扰动。然后，它评估带有扰动的族群的适应度。之后，它使用扰动和适应度计算策略参数的梯度。最后，它使用梯度和学习率更新策略参数。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.open_es`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.open_es`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.open_es.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`OpenES <evox.algorithms.so.es_variants.open_es.OpenES>`"
msgstr "{py:obj}`OpenES <evox.algorithms.so.es_variants.open_es.OpenES>`"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:20
#: ../../../src/evox/algorithms/so/es_variants/open_es.py:33
msgid ""
"The OpenES algorithm as described in \"Evolution Strategies as a Scalable "
"Alternative to Reinforcement Learning\" from "
"https://arxiv.org/abs/1703.03864."
msgstr ""
"OpenES算法，如文章“Evolution Strategies as a Scalable Alternative to Reinforcement"
" Learning”中所描述：https://arxiv.org/abs/1703.03864。"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:39
msgid "Initialize the OpenES algorithm with the given parameters."
msgstr "用给定的参数初始化 OpenES 算法。"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:43
msgid "The learning rate for the optimizer."
msgstr "优化器的学习率。"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:44
msgid "The standard deviation of the noise."
msgstr "噪声的标准差。"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:46
msgid "Whether to use mirrored sampling. Defaults to True."
msgstr "是否使用镜像采样。默认值为 True。"

#: ../../../src/evox/algorithms/so/es_variants/open_es.py:46
msgid ""
"Step the OpenES algorithm by evaluating the fitness of the current "
"population and updating the center."
msgstr "通过评估当前种群的适应度并更新中心，执行 OpenES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.persistent_es`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.persistent_es`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.persistent_es.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`PersistentES "
"<evox.algorithms.so.es_variants.persistent_es.PersistentES>`"
msgstr ""
"{py:obj}`PersistentES "
"<evox.algorithms.so.es_variants.persistent_es.PersistentES>`"

#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:20
#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:33
msgid "The implementation of the Persistent ES algorithm."
msgstr "持续ES算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:35
msgid ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"
msgstr ""
"Reference: Unbiased Gradient Estimation in Unrolled Computation Graphs with "
"Persistent Evolution Strategies "
"(http://proceedings.mlr.press/v139/vicol21a.html)"

#: ../../../src/evox/algorithms/so/es_variants/persistent_es.py:39
msgid "Initialize the Persistent-ES algorithm with the given parameters."
msgstr "用给定的参数初始化 Persistent-ES 算法。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.snes`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.snes`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.snes.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`SNES <evox.algorithms.so.es_variants.snes.SNES>`"
msgstr "{py:obj}`SNES <evox.algorithms.so.es_variants.snes.SNES>`"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:20
#: ../../../src/evox/algorithms/so/es_variants/snes.py:33
msgid "The implementation of the SNES algorithm."
msgstr "SNES算法的实现。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:39
msgid "Initialize the SNES algorithm with the given parameters."
msgstr "用给定的参数初始化SNES算法。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:44
msgid "The learning rate for the mean. Defaults to 1.0."
msgstr "均值的学习率。默认值为 1.0。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:45
msgid "The standard deviation of the noise. Defaults to 1.0."
msgstr "噪声的标准差。默认为 1.0。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:46
msgid "The temperature of the softmax in computing weights. Defaults to 12.5."
msgstr "计算权重时 softmax 的温度。默认值为 12.5。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:47
msgid "The type of weights to use. Defaults to \"temp\"."
msgstr "权重的类型。默认为 \"temp\"。"

#: ../../../src/evox/algorithms/so/es_variants/snes.py:46
msgid "Run one step of the SNES algorithm."
msgstr "运行 SNES 算法的一步。"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.sort_utils.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.es_variants.sort_utils`"
msgstr "{py:mod}`evox.algorithms.so.es_variants.sort_utils`"

#: ../../source/apidocs/evox/evox.algorithms.so.es_variants.sort_utils.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`sort_by_key "
"<evox.algorithms.so.es_variants.sort_utils.sort_by_key>`"
msgstr ""
"{py:obj}`sort_by_key "
"<evox.algorithms.so.es_variants.sort_utils.sort_by_key>`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:34
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.algorithms.so.pso_variants.__all__>`"
msgstr "{py:obj}`__all__ <evox.algorithms.so.pso_variants.__all__>`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.md:46
msgid "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"
msgstr "['CLPSO', 'CSO', 'DMSPSOEL', 'FSPSO', 'PSO', 'SLPSOGS', 'SLPSOUS']"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.clpso`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.clpso`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.clpso.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`CLPSO <evox.algorithms.so.pso_variants.clpso.CLPSO>`"
msgstr "{py:obj}`CLPSO <evox.algorithms.so.pso_variants.clpso.CLPSO>`"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:20
#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:33
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:20
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:33
msgid "The basic CSO algorithm."
msgstr "基本的CSO算法。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:37
msgid ""
"`__init__`: Initializes the CLPSO algorithm with given static parameters "
"including lower and upper bounds for particle positions."
msgstr "`__init__`: 初始化 CLPSO 算法，使用给定的静态参数，包括粒子位置的下限和上限。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:38
msgid ""
"`setup`: Initializes the CLPSO algorithm and sets up initial population, "
"velocity, and buffers for tracking best local and global positions and "
"fitness values."
msgstr "`setup`: 初始化 CLPSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:39
msgid ""
"`step`: Performs a single optimization step using CLPSO, updating local best"
" positions and fitness values, and adjusting velocity and positions based on"
" inertia, cognitive, and social components."
msgstr ""
"**单步优化** (`step`): \n"
"使用CLPSO执行单步优化，更新个人最佳位置和适应值，根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/cso.py:41
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:42
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:40
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:41
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:41
msgid ""
"Note that the `evaluate` method is not defined in this class, it is a proxy "
"function of `Problem.evaluate` set by workflow; therefore, it cannot be used"
" in class methods other than `step`."
msgstr ""
"请注意，`evaluate`方法在此类中未定义，它是由工作流设置的`Problem.evaluate`的代理函数；因此，它无法在除`step`之外的类方法中使用。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:39
msgid "Initialize the CLPSO algorithm with the given static parameters."
msgstr "用给定的静态参数初始化 CLPSO 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:44
msgid "The inertia weight (w). Defaults to 0.5."
msgstr "惯性权重 (w)。默认值为 0.5。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:45
msgid "The cognitive weight (c). Defaults to 1.5."
msgstr "认知权重（c）。默认为1.5。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:46
msgid "The social weight (P_c). Defaults to 0.05."
msgstr "社会权重 (P_c)。默认为 0.05。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:51
msgid "Perform a single optimization step using CLPSO."
msgstr "使用 CLPSO 执行单次优化步骤。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:53
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:48
msgid ""
"This function evaluates the fitness of the current population, updates the "
"local best positions and fitness values, and adjusts the velocity and "
"positions of particles based on inertia, cognitive, and social components. "
"It ensures that the updated positions and velocities are clamped within the "
"specified bounds."
msgstr ""
"该函数用于评估当前种群的适应度，更新局部最优位置和适应度值并根据惯性、认知和社会组件调整粒子的速度和位置该函数确保在更新位置和速度后，粒子的位置和速度都在指定的范围内。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:59
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:54
msgid ""
"The local best positions and fitness values are updated if the current "
"fitness is better than the recorded local best. The global best position and"
" fitness are determined using helper functions."
msgstr "如果当前的适应度比记录的局部最佳更好，则更新局部最佳位置和适应度值。全局最佳位置和适应度通过辅助函数确定。"

#: ../../../src/evox/algorithms/so/pso_variants/clpso.py:63
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:58
msgid ""
"The velocity is updated based on the weighted sum of the previous velocity, "
"the cognitive component (personal best), and the social component (global "
"best). The population positions are then updated using the new velocities."
msgstr "速度是基于以前速度的加权总和、认知成分（个人最好）和社会成分（全局最好）进行更新的。然后，使用新的速度更新种群位置。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.cso`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.cso`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.cso.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`CSO <evox.algorithms.so.pso_variants.cso.CSO>`"
msgstr "{py:obj}`CSO <evox.algorithms.so.pso_variants.cso.CSO>`"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:37
msgid "`__init__`: Initializes the CSO algorithm with given parameters."
msgstr "`__init__`: 使用给定参数初始化 CSO 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:38
msgid ""
"`setup`: Initializes the CSO algorithm with given lower and upper bounds for"
" particle positions, and sets up initial population, velocity, and buffers "
"for tracking best local and global positions and fitness values."
msgstr "`setup`: 使用给定的粒子位置下限和上限初始化 CSO 算法，并设置初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:39
msgid ""
"`step`: Performs a single optimization step using CSO, updating local best "
"positions and fitness values, and adjusting velocity and positions based on "
"inertia, cognitive, and social components."
msgstr "`step`：使用 CSO 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交组件调整速度和位置。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:39
msgid "Initialize the CSO algorithm with the given parameters."
msgstr "使用给定的参数初始化CSO算法。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:44
msgid "The inertia weight. Defaults to 0.0."
msgstr "惯性权重。默认值为 0.0。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:45
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:47
msgid "The mean of the normal distribution. Defaults to None."
msgstr "正态分布的均值。默认为 None。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:46
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:48
msgid "The standard deviation of the normal distribution. Defaults to None."
msgstr "正态分布的标准差。默认为 None。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:51
msgid "Perform a single optimization step using CSO."
msgstr "使用 CSO 进行单次优化步骤。"

#: ../../../src/evox/algorithms/so/pso_variants/cso.py:53
msgid ""
"This function updates the position and velocity of each particle in the "
"population using the CSO algorithm. The CSO algorithm is an optimization "
"algorithm that uses a combination of both the PSO and the DE algorithms to "
"search for the optimal solution."
msgstr "该函数使用CSO算法更新种群中每个粒子的位置和速度。CSO算法是一种优化算法，它结合了PSO和DE算法来搜索最佳解决方案。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.dms_pso_el`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.dms_pso_el`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.dms_pso_el.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`DMSPSOEL <evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL>`"
msgstr ""
"{py:obj}`DMSPSOEL <evox.algorithms.so.pso_variants.dms_pso_el.DMSPSOEL>`"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:20
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:33
msgid "The DMSPSOEL algorithm."
msgstr "DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:37
msgid "`__init__`: Initializes the DMSPSOEL algorithm with given parameters."
msgstr "`__init__`: 通过给定的参数来初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:38
msgid ""
"`setup`: Initializes the DMSPSOEL algorithm with given lower and upper "
"bounds for particle positions, and sets up initial population, velocity, and"
" buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`: 初始化 DMSPSOEL 算法，设置粒子位置的下限和上限，并配置初始种群、速度，以及用于跟踪最佳局部和全局位置与适应度值的缓冲区。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:39
msgid ""
"`step`: Performs a single optimization step using DMSPSOEL, updating local "
"best positions and fitness values, and adjusting velocity and positions "
"based on inertia, cognitive, and social components."
msgstr "`step`: 使用 DMSPSOEL 执行单次优化步骤，更新本地最佳位置和适应度值，并根据惯性、认知和社会组件调整速度和位置。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:39
msgid "Initialize the DMSPSOEL algorithm with the given parameters."
msgstr "使用给定参数初始化 DMSPSOEL 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:43
msgid "The size of the dynamic sub-swarm. Defaults to 10."
msgstr "动态子种群的大小。默认值：10。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:44
msgid "The number of dynamic sub-swarms. Defaults to 5."
msgstr "动态子种群的数量。默认为5。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:45
msgid "The size of the following sub-swarm. Defaults to 10."
msgstr "以下子群体的大小。默认为10。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:46
msgid "The number of iterations for regrouping. Defaults to 50."
msgstr "重组的迭代次数。默认为50。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:47
msgid "The maximum number of iterations. Defaults to 100."
msgstr "最大迭代次数。默认为 100。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:48
msgid "The inertia weight. Defaults to 0.7."
msgstr "惯性权重。默认值为0.7。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:49
msgid "The cognitive weight. Defaults to 1.5."
msgstr "认知权重。默认为 1.5。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:50
msgid "The social weight. Defaults to 1.5."
msgstr "社会权重。默认为 1.5。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:51
#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:52
msgid "The social weight. Defaults to 1.0."
msgstr "社交权重。默认为 1.0。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:51
msgid "Perform a single step of the DMSPSOEL algorithm."
msgstr "执行 DMSPSOEL 算法的单步操作。"

#: ../../../src/evox/algorithms/so/pso_variants/dms_pso_el.py:53
msgid ""
"This function updates the population, velocity, personal best location, and "
"personal best fitness based on the current fitness values. It also updates "
"the local and global best positions and fitness values based on the dynamic "
"sub-swarm and following sub-swarm. Finally, it updates the iteration count."
msgstr ""
"此函数根据当前的适应度值更新种群、速度、个人最佳位置和个人最佳适应度。它还根据动态子群和跟随子群更新局部和全局最佳位置及适应度值。最后，它更新迭代计数。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.fs_pso`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.fs_pso`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.fs_pso.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`FSPSO <evox.algorithms.so.pso_variants.fs_pso.FSPSO>`"
msgstr "{py:obj}`FSPSO <evox.algorithms.so.pso_variants.fs_pso.FSPSO>`"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:20
#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:33
msgid "The Feature Selection PSO algorithm."
msgstr "特征选择 PSO 算法"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:39
msgid "Initialize the FSPSO algorithm with the given parameters."
msgstr "使用给定参数初始化FSPSO算法。"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:44
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:42
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:44
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:44
msgid "The inertia weight. Defaults to 0.6."
msgstr "惯性权重。默认值为0.6。"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:45
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:43
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:45
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:45
msgid "The cognitive weight. Defaults to 2.5."
msgstr "认知权重。默认为 2.5。"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:46
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:44
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:46
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:46
msgid "The social weight. Defaults to 0.8."
msgstr "社会权重。默认值为 0.8。"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:49
msgid "The mutation rate. Defaults to 0.01."
msgstr "变异率。默认为 0.01。"

#: ../../../src/evox/algorithms/so/pso_variants/fs_pso.py:51
msgid "Perform a normal optimization step using FSPSO."
msgstr "使用 FSPSO 执行常规优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.pso`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.pso`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.pso.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`PSO <evox.algorithms.so.pso_variants.pso.PSO>`"
msgstr "{py:obj}`PSO <evox.algorithms.so.pso_variants.pso.PSO>`"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:20
#: ../../../src/evox/algorithms/so/pso_variants/pso.py:33
msgid "The basic Particle Swarm Optimization (PSO) algorithm."
msgstr "基本粒子群优化算法 (PSO)"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:37
msgid ""
"`__init__`: Initializes the PSO algorithm with given parameters (population "
"size, lower and upper bounds, inertia weight, cognitive weight, and social "
"weight)."
msgstr ""
"**__init__**\n"
"初始化 PSO 算法（Particle Swarm Optimization）与给定的参数（人口大小、下限和上限、惯性权重、认知权重和社会权重）。"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:38
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (PSO), updating local best positions and fitness values, and "
"adjusting velocity and positions based on inertia, cognitive, and social "
"components."
msgstr "`step`: 执行单次粒子群优化（PSO）步骤，更新局部最佳位置和适应度值，并基于惯性、认知和社会组件调整速度和位置。\n"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:39
msgid "Initialize the PSO algorithm with the given parameters."
msgstr "使用给定参数初始化PSO算法。"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:46
msgid "Perform a normal optimization step using PSO."
msgstr "使用PSO执行常规优化步骤。"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:54
msgid "Perform the first step of the PSO optimization."
msgstr "执行 PSO 优化的第一步。"

#: ../../../src/evox/algorithms/so/pso_variants/pso.py:56
msgid "See `step` for more details."
msgstr "请查看 `step` 以获取更多详细信息。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.sl_pso_gs`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.sl_pso_gs`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_gs.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`SLPSOGS <evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS>`"
msgstr "{py:obj}`SLPSOGS <evox.algorithms.so.pso_variants.sl_pso_gs.SLPSOGS>`"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:20
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Gaussian "
"Sampling for Demonstrator Choice (SLPSOGS) algorithm."
msgstr "基本的粒子群优化社交学习 PSO 使用高斯采样进行示范选择 (SLPSOGS) 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:37
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:37
msgid ""
"`__init__`: Initializes the SLPSOGS algorithm with given parameters "
"(population size, inertia weight, cognitive weight, and social weight)."
msgstr "`__init__`: 使用给定的参数（种群大小、惯性权重、认知权重和社会权重）初始化SLPSOGS算法。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:38
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:38
msgid ""
"`setup`: Initializes the SLPSOGS algorithm with given lower and upper bounds"
" for particle positions, and sets up initial population, velocity, and "
"buffers for tracking best local and global positions and fitness values."
msgstr ""
"`setup`：初始化 SLPSOGS 算法，设置粒子位置的下界和上界，并建立初始种群、速度以及用于跟踪最佳局部和全局位置及适应度值的缓冲区。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:39
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:39
msgid ""
"`step`: Performs a single optimization step using Particle Swarm "
"Optimization (SLPSOGS), updating local best positions and fitness values, "
"and adjusting velocity and positions based on inertia, cognitive, and social"
" components."
msgstr ""
"`step`: 使用粒子群优化 (SLPSOGS) 执行单个优化步骤，更新局部最佳位置和适应度值，并根据惯性、认知和社交成分调整速度和位置。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:39
msgid "Initialize the SLPSOGS algorithm with the given parameters."
msgstr "使用给定参数初始化 SLPSOGS 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_gs.py:51
msgid "Perform a normal optimization step using SLPSOGS."
msgstr "使用 SLPSOGS 执行一个正常的优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.sl_pso_us`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.sl_pso_us`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.sl_pso_us.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`SLPSOUS <evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS>`"
msgstr "{py:obj}`SLPSOUS <evox.algorithms.so.pso_variants.sl_pso_us.SLPSOUS>`"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:20
#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:33
msgid ""
"The basic Particle Swarm Optimization Social Learning PSO Using Uniform "
"Sampling for Demonstrator Choice (SLPSOUS) algorithm."
msgstr "基本的粒子群优化社会学习 PSO 使用均匀采样进行演示选择 (SLPSOUS) 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:39
msgid "Initialize the SLPSOUS algorithm with the given parameters."
msgstr "用给定的参数初始化 SLPSOUS 算法。"

#: ../../../src/evox/algorithms/so/pso_variants/sl_pso_us.py:51
msgid "Perform a normal optimization step using SLPSOUS."
msgstr "执行一个使用 SLPSOUS 的正常优化步骤。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.algorithms.so.pso_variants.utils`"
msgstr "{py:mod}`evox.algorithms.so.pso_variants.utils`"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`min_by <evox.algorithms.so.pso_variants.utils.min_by>`"
msgstr "{py:obj}`min_by <evox.algorithms.so.pso_variants.utils.min_by>`"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:20
#: ../../../src/evox/algorithms/so/pso_variants/utils.py:34
msgid "Find the value with the minimum key."
msgstr "找到具有最小键的值。"

#: ../../source/apidocs/evox/evox.algorithms.so.pso_variants.utils.md:22
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.so.pso_variants.utils.random_select_from_mask>`"
msgstr ""
"{py:obj}`random_select_from_mask "
"<evox.algorithms.so.pso_variants.utils.random_select_from_mask>`"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:24
#: ../../../src/evox/algorithms/so/pso_variants/utils.py:41
msgid "Randomly select `s` elements from a 1D mask using uniform noise."
msgstr "随机从 1D 掩码中使用均匀噪声随机选择 `s` 个元素。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:36
msgid "A tensor or list of tensors."
msgstr "一个张量或一个列表的张量"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:37
msgid "A tensor or list of tensors corresponding to the values."
msgstr "一个张量或与值对应的张量列表。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:39
msgid "The value with the minimum key and the corresponding key."
msgstr "具有最小键的值及其对应的键。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:43
msgid "A tensor used as the random seed."
msgstr "用于随机种子的张量。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:44
#, python-brace-format
msgid "A tensor of shape (N,) containing {0, 1}."
msgstr "一个形状为 (N,) 的张量，包含 {0, 1}。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:45
msgid "The number of elements to select."
msgstr "要选择的元素数量。"

#: ../../../src/evox/algorithms/so/pso_variants/utils.py:47
msgid "A new mask tensor with exactly s elements set to 1."
msgstr "一个新的掩码张量，其中恰好有 s 个元素设置为 1。"

#: ../../source/apidocs/evox/evox.core.md:1
#, python-brace-format
msgid "{py:mod}`evox.core`"
msgstr "{py:mod}`evox.core`"

#: ../../source/apidocs/evox/evox.core.md:28
#, python-brace-format
msgid "{py:obj}`__all__ <evox.core.__all__>`"
msgstr "{py:obj}`__all__ <evox.core.__all__>`"

#: ../../source/apidocs/evox/evox.core.md:40
msgid ""
"['Parameter', 'Mutable', 'ModuleBase', 'compile', 'use_state', 'vmap', "
"'Algorithm', 'Problem', 'Work..."
msgstr ""
"['Parameter', 'Mutable', 'ModuleBase', 'compile', 'use_state', 'vmap', "
"'Algorithm', 'Problem', 'Work...']"

#: ../../source/apidocs/evox/evox.core.components.md:1
#, python-brace-format
msgid "{py:mod}`evox.core.components`"
msgstr "{py:mod}`evox.core.components`"

#: ../../source/apidocs/evox/evox.core.components.md:18
#, python-brace-format
msgid "{py:obj}`Algorithm <evox.core.components.Algorithm>`"
msgstr "{py:obj}`Algorithm <evox.core.components.Algorithm>`"

#: ../../../src/evox/core/components.py:20
#: ../../../src/evox/core/components.py:45
msgid "Base class for all algorithms"
msgstr "所有算法的基类"

#: ../../source/apidocs/evox/evox.core.components.md:22
#, python-brace-format
msgid "{py:obj}`Problem <evox.core.components.Problem>`"
msgstr "{py:obj}`Problem <evox.core.components.Problem>`"

#: ../../../src/evox/core/components.py:24
#: ../../../src/evox/core/components.py:102
msgid "Base class for all problems"
msgstr "所有问题的基类"

#: ../../source/apidocs/evox/evox.core.components.md:26
#, python-brace-format
msgid "{py:obj}`Workflow <evox.core.components.Workflow>`"
msgstr "{py:obj}`Workflow <evox.core.components.Workflow>`"

#: ../../../src/evox/core/components.py:28
#: ../../../src/evox/core/components.py:126
msgid "The base class for workflow."
msgstr "工作流的基类。"

#: ../../source/apidocs/evox/evox.core.components.md:30
#, python-brace-format
msgid "{py:obj}`Monitor <evox.core.components.Monitor>`"
msgstr "{py:obj}`Monitor <evox.core.components.Monitor>`"

#: ../../../src/evox/core/components.py:32
#: ../../../src/evox/core/components.py:166
msgid "The monitor base class."
msgstr "监视器基类。"

#: ../../source/apidocs/evox/evox.core.components.md:42
#: ../../source/apidocs/evox/evox.core.components.md:99
#: ../../source/apidocs/evox/evox.core.components.md:123
#: ../../source/apidocs/evox/evox.core.components.md:163
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.module.ModuleBase`, {py:obj}`abc.ABC`"

#: ../../../src/evox/core/components.py:132
#: ../../../src/evox/core/components.py:172
#: ../../../src/evox/core/module.py:51 ../../../src/evox/core/module.py:83
#: ../../../src/evox/core/module.py:108
msgid "Initialize the ModuleBase."
msgstr "初始化 ModuleBase。"

#: ../../../src/evox/core/components.py:134
#: ../../../src/evox/core/components.py:174
#: ../../../src/evox/core/module.py:53 ../../../src/evox/core/module.py:85
#: ../../../src/evox/core/module.py:110
msgid "Variable length argument list, passed to the parent class initializer."
msgstr "可变长度参数列表，传递给父类的初始化函数。"

#: ../../../src/evox/core/components.py:135
#: ../../../src/evox/core/components.py:175
#: ../../../src/evox/core/module.py:54 ../../../src/evox/core/module.py:86
#: ../../../src/evox/core/module.py:111
msgid "Arbitrary keyword arguments, passed to the parent class initializer."
msgstr "任意关键字参数，传递给父类初始化器。"

#: ../../../src/evox/core/components.py:137
#: ../../../src/evox/core/components.py:177
#: ../../../src/evox/core/module.py:56 ../../../src/evox/core/module.py:88
#: ../../../src/evox/core/module.py:113
msgid ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."
msgstr ""
"Attributes:     __static_names__ (list): A list to store static member "
"names."

#: ../../../src/evox/core/components.py:58
msgid "Execute the algorithm procedure for one step."
msgstr "执行算法过程的一步。"

#: ../../../src/evox/core/components.py:66
msgid ""
"Initialize the algorithm and execute the algorithm procedure for the first "
"step."
msgstr "初始化算法并执行算法过程的第一步。"

#: ../../../src/evox/core/components.py:74
msgid "Execute the algorithm procedure for the final step."
msgstr "执行算法流程的最终步骤。"

#: ../../../src/evox/core/components.py:83
msgid ""
"Evaluate the fitness at given points. This function is a proxy function of "
"`Problem.evaluate` set by workflow. By default, this functions raises "
"`NotImplementedError`."
msgstr ""
"在给定点评估适应度。这个函数是由工作流设置的 `Problem.evaluate` 的代理函数。默认情况下，这个函数会引发 "
"`NotImplementedError`。"

#: ../../../src/evox/core/components.py:87
#: ../../../src/evox/core/components.py:117
msgid "The population."
msgstr "种群。"

#: ../../../src/evox/core/components.py:89
#: ../../../src/evox/core/components.py:119
msgid "The fitness."
msgstr "适应度。"

#: ../../../src/evox/core/components.py:91
msgid "Record the current step."
msgstr "记录当前步骤。"

#: ../../../src/evox/core/components.py:115
msgid "Evaluate the fitness at given points"
msgstr "在给定点评估适应度"

#: ../../../src/evox/core/components.py:121
msgid "Notice"
msgstr "注意"

#: ../../../src/evox/core/components.py:122
msgid ""
"If this function contains external evaluations that cannot be compiled by "
"`torch.compile`, please wrap it with `torch.compiler.disable` or use "
"`evox.utils.register_vmap_op` to register external functions as operators."
msgstr ""
"如果此函数包含无法通过 `torch.compile` 编译的外部评估，请使用 `torch.compiler.disable` 将其包裹，或者使用 "
"`evox.utils.register_vmap_op` 将外部函数注册为操作符。"

#: ../../../src/evox/core/components.py:139
#: ../../../src/evox/workflows/std_workflow.py:67
msgid "Perform the first optimization step of the workflow."
msgstr "用于让工作流执行一步的函数。"

#: ../../../src/evox/core/components.py:147
msgid "The basic function to step a workflow."
msgstr "基本功能以逐步执行工作流。"

#: ../../../src/evox/core/components.py:155
msgid "Perform the final optimization step of the workflow."
msgstr "执行工作流的最终优化步骤。"

#: ../../../src/evox/core/components.py:168
msgid ""
"Monitors are used to monitor the evolutionary process. They contains a set "
"of callbacks, which will be called at specific points during the execution "
"of the workflow. Monitor itself lives outside the main workflow, so jit is "
"not required."
msgstr ""
"监视器用于监控进化过程。它们包含一组回调，这些回调将在工作流执行的特定时刻被调用。Monitor 本身位于主工作流之外，因此不需要 jit。"

#: ../../../src/evox/core/components.py:173
msgid ""
"To implements a monitor, implement your own callbacks and override the hooks"
" method. The hooks method should return a list of strings, which are the "
"names of the callbacks. Currently the supported callbacks are:"
msgstr ""
"要实现一个监视器，您需要实现自己的回调并重写 hooks 方法。hooks 方法应返回一个字符串列表，这些字符串是回调的名称。目前支持的回调有："

#: ../../../src/evox/core/components.py:177
msgid "`post_ask`, `pre_eval`, `post_eval`, and `pre_tell`."
msgstr "`post_ask`、`pre_eval`、`post_eval` 和 `pre_tell`。"

#: ../../../src/evox/core/components.py:179
msgid "Set the static variables according to `config`."
msgstr "根据 `config` 设置静态变量。"

#: ../../../src/evox/core/components.py:181
msgid "The configuration."
msgstr "配置。"

#: ../../../src/evox/core/components.py:183
msgid "This module."
msgstr "此模块。"

#: ../../../src/evox/core/components.py:187
msgid "Record the auxiliary information."
msgstr "记录辅助信息。"

#: ../../../src/evox/core/components.py:189
msgid "The auxiliary information."
msgstr "辅助信息。"

#: ../../../src/evox/core/components.py:195
msgid "The hook function to be executed before the solution transformation."
msgstr "解决方案转换前执行的钩子函数。"

#: ../../../src/evox/core/components.py:197
msgid ""
"The population (candidate solutions) before the solution transformation."
msgstr "种群（候选解）的初始演化状态"

#: ../../../src/evox/core/components.py:203
msgid "The hook function to be executed after the solution transformation."
msgstr "解决方案转换后执行的钩子函数。"

#: ../../../src/evox/core/components.py:205
msgid ""
"The population (candidate solutions) after the solution transformation."
msgstr "经过解的转换后的种群（候选解）。"

#: ../../../src/evox/core/components.py:211
msgid "The hook function to be executed before the fitness transformation."
msgstr "在适应度转换之前执行的钩子函数。"

#: ../../../src/evox/core/components.py:213
msgid "The fitnesses before the fitness transformation."
msgstr "在适应度转换之前的适应度。"

#: ../../../src/evox/core/components.py:219
msgid "The hook function to be executed after the fitness transformation."
msgstr "在适应度转换后要执行的钩子函数。"

#: ../../../src/evox/core/components.py:221
msgid "The fitnesses after the fitness transformation."
msgstr "适应度变换后的适应度值。"

#: ../../source/apidocs/evox/evox.core.module.md:1
#, python-brace-format
msgid "{py:mod}`evox.core.module`"
msgstr "{py:mod}`evox.core.module`"

#: ../../source/apidocs/evox/evox.core.module.md:18
#, python-brace-format
msgid "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"
msgstr "{py:obj}`ModuleBase <evox.core.module.ModuleBase>`"

#: ../../../src/evox/core/module.py:20 ../../../src/evox/core/module.py:77
msgid ""
"The base module for all algorithms, problems, and workflows in the library."
msgstr "用于库中所有算法、问题和工作流的基础模块。"

#: ../../source/apidocs/evox/evox.core.module.md:22
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`TransformGetSetItemToIndex "
"<evox.core.module.TransformGetSetItemToIndex>`"
msgstr ""
"{py:obj}`TransformGetSetItemToIndex "
"<evox.core.module.TransformGetSetItemToIndex>`"

#: ../../source/apidocs/evox/evox.core.module.md:32
#, python-brace-format
msgid "{py:obj}`Parameter <evox.core.module.Parameter>`"
msgstr "{py:obj}`Parameter <evox.core.module.Parameter>`"

#: ../../../src/evox/core/module.py:34 ../../../src/evox/core/module.py:60
msgid ""
"Wraps a value as parameter with `requires_grad=False`. This is often used to"
" label a value in an algorithm as a hyperparameter that can be identified by"
" the `HPOProblemWrapper`."
msgstr ""
"将值包装为参数，并设置`requires_grad=False`。这通常用于在算法中将某个值标记为超参数，这些超参数可以通过`HPOProblemWrapper`识别。"

#: ../../source/apidocs/evox/evox.core.module.md:36
#, python-brace-format
msgid "{py:obj}`Mutable <evox.core.module.Mutable>`"
msgstr "{py:obj}`Mutable <evox.core.module.Mutable>`"

#: ../../../src/evox/core/module.py:38 ../../../src/evox/core/module.py:67
msgid ""
"Wraps a value as a mutable tensor. This is often used to label a value in an"
" algorithm as a mutable tensor that may changes during iteration(s)."
msgstr "将一个值包装为可变张量。这通常用于在算法中将某个值标记为可变张量，该值可能会在迭代过程中发生改变。"

#: ../../source/apidocs/evox/evox.core.module.md:40
#, fuzzy, python-brace-format
msgid "{py:obj}`compile <evox.core.module.compile>`"
msgstr "{py:obj}`compile <evox.core.module.compile>`"

#: ../../../src/evox/core/module.py:42 ../../../src/evox/core/module.py:110
msgid ""
"Fix the `torch.compile`'s issue with __getitem__ and __setitem__ that "
"recognizes scalar indexes as `.item()` and causes graph breaks. Related "
"issue: https://github.com/pytorch/pytorch/issues/124423."
msgstr ""
"修复 `torch.compile` 中的 __getitem__ 和 __setitem__ 问题，该问题将标量索引识别为 `.item()` "
"并导致图断裂。相关问题链接：https://github.com/pytorch/pytorch/issues/124423。"

#: ../../source/apidocs/evox/evox.core.module.md:44
#, fuzzy, python-brace-format
msgid "{py:obj}`vmap <evox.core.module.vmap>`"
msgstr "{py:obj}`vmap <evox.core.module.vmap>`"

#: ../../../src/evox/core/module.py:46 ../../../src/evox/core/module.py:117
msgid ""
"Fix the `torch.vmap`'s issue with __getitem__ and __setitem__. Related "
"issue: https://github.com/pytorch/pytorch/issues/124423."
msgstr ""
"修复 `torch.vmap` 中与 `__getitem__` 和 `__setitem__` "
"相关的问题。相关问题：https://github.com/pytorch/pytorch/issues/124423。"

#: ../../source/apidocs/evox/evox.core.module.md:48
#, python-brace-format
msgid "{py:obj}`use_state <evox.core.module.use_state>`"
msgstr "{py:obj}`use_state <evox.core.module.use_state>`"

#: ../../../src/evox/core/module.py:50 ../../../src/evox/core/module.py:124
msgid ""
"Transform a `torch.nn.Module`'s method or an `torch.nn.Module` into a "
"stateful function. When using `torch.nn.Module`, the stateful version of the"
" default `forward` method will be created. The stateful function will have a"
" signature of `fn(params_and_buffers, *args, **kwargs) -> params_and_buffers"
" | Tuple[params_and_buffers, <original_returns>]]`."
msgstr ""
"将一个 `torch.nn.Module` 的方法或一个 `torch.nn.Module` 转换为状态函数。当使用 `torch.nn.Module`"
" 时，将会创建默认 `forward` 方法的状态版本。状态函数的签名为 `fn(params_and_buffers, *args, "
"**kwargs) -> params_and_buffers | Tuple[params_and_buffers, "
"<original_returns>]]`。"

#: ../../../src/evox/core/module.py:63
msgid "The parameter value."
msgstr "参数值。"

#: ../../../src/evox/core/module.py:64
msgid "The dtype of the parameter. Defaults to None."
msgstr "参数的数据类型。默认为 None。"

#: ../../../src/evox/core/module.py:65
msgid "The device of the parameter. Defaults to None."
msgstr "参数的设备。默认值为 None。"

#: ../../../src/evox/core/module.py:66
msgid "Whether the parameter requires gradient. Defaults to False."
msgstr "参数是否需要梯度。默认值为 False。"

#: ../../../src/evox/core/module.py:68
msgid "The parameter."
msgstr "参数。"

#: ../../../src/evox/core/module.py:70
msgid "The value to be wrapped."
msgstr "要包装的值。"

#: ../../../src/evox/core/module.py:71
msgid "The dtype of the tensor. Defaults to None."
msgstr "张量的 dtype。默认值为 None。"

#: ../../../src/evox/core/module.py:72
msgid "The device of the tensor. Defaults to None."
msgstr "张量的设备。默认为 None。"

#: ../../../src/evox/core/module.py:74
msgid "The wrapped tensor."
msgstr "被包装的张量。"

#: ../../source/apidocs/evox/evox.core.module.md:74
#, python-brace-format
msgid "Bases: {py:obj}`torch.nn.Module`"
msgstr "Bases: {py:obj}`torch.nn.Module`"

#: ../../../src/evox/core/module.py:80
msgid "To prevent ambiguity, `ModuleBase.eval()` is disabled."
msgstr "为防止产生歧义，`ModuleBase.eval()` 已被禁用。"

#: ../../source/apidocs/evox/evox.core.module.md:95
#, fuzzy, python-brace-format
msgid "Bases: {py:obj}`torch.overrides.TorchFunctionMode`"
msgstr "Bases: {py:obj}`torch.overrides.TorchFunctionMode`"

#: ../../source/apidocs/evox/evox.metrics.md:1
#, python-brace-format
msgid "{py:mod}`evox.metrics`"
msgstr "{py:mod}`evox.metrics`"

#: ../../source/apidocs/evox/evox.metrics.md:29
#, python-brace-format
msgid "{py:obj}`__all__ <evox.metrics.__all__>`"
msgstr "{py:obj}`__all__ <evox.metrics.__all__>`"

#: ../../source/apidocs/evox/evox.metrics.md:41
msgid "['gd', 'hv', 'igd']"
msgstr "['gd', 'hv', 'igd']"

#: ../../source/apidocs/evox/evox.metrics.gd.md:1
#, python-brace-format
msgid "{py:mod}`evox.metrics.gd`"
msgstr "{py:mod}`evox.metrics.gd`"

#: ../../source/apidocs/evox/evox.metrics.gd.md:18
#, python-brace-format
msgid "{py:obj}`gd <evox.metrics.gd.gd>`"
msgstr "{py:obj}`gd <evox.metrics.gd.gd>`"

#: ../../../src/evox/metrics/gd.py:20 ../../../src/evox/metrics/gd.py:30
msgid ""
"Calculate the Generational Distance (GD) metric between a set of solutions "
"and the Pareto front."
msgstr "计算一组解与帕累托前沿之间的世代距离（GD）指标。"

#: ../../../src/evox/metrics/gd.py:32 ../../../src/evox/metrics/igd.py:32
msgid ""
"A tensor of shape (n, m), where n is the number of solutions and m is the "
"number of objectives. Represents the set of solutions to be evaluated."
msgstr "一个形状为 (n, m) 的张量，其中 n 是解的数量，m 是目标的数量。表示要评估的解集。"

#: ../../../src/evox/metrics/gd.py:34 ../../../src/evox/metrics/igd.py:34
msgid ""
"A tensor of shape (k, m), where k is the number of points on the Pareto "
"front and m is the number of objectives. Represents the true Pareto front."
msgstr "一个形状为 (k, m) 的张量，其中 k 是帕累托前沿上的点数，m 是目标数量。表示真实的帕累托前沿。"

#: ../../../src/evox/metrics/gd.py:37
msgid ""
"The GD score, a scalar representing the average distance of the solutions to"
" the Pareto front."
msgstr "GD 分数是一种标量，代表着解与帕雷托前沿的平均距离。"

#: ../../../src/evox/metrics/gd.py:40
msgid ""
"A lower GD score indicates that the approximation is closer to the Pareto "
"front."
msgstr "较低的 GD 分数表明近似值更接近 Pareto 前沿。"

#: ../../source/apidocs/evox/evox.metrics.hv.md:1
#, python-brace-format
msgid "{py:mod}`evox.metrics.hv`"
msgstr "{py:mod}`evox.metrics.hv`"

#: ../../source/apidocs/evox/evox.metrics.hv.md:18
#, python-brace-format
msgid "{py:obj}`hv <evox.metrics.hv.hv>`"
msgstr "{py:obj}`hv <evox.metrics.hv.hv>`"

#: ../../../src/evox/metrics/hv.py:20 ../../../src/evox/metrics/hv.py:30
msgid "Monte Carlo Hypervolume Calculation using bounding cube method."
msgstr "蒙特卡罗超体积计算使用边界立方体方法。"

#: ../../../src/evox/metrics/hv.py:32
msgid "Objective points of shape (n_points, n_objs)."
msgstr "目标点的形状为 (n_points, n_objs)。"

#: ../../../src/evox/metrics/hv.py:33
msgid "Reference point of shape (n_objs, )."
msgstr "形状为 (n_objs, ) 的参考点。"

#: ../../../src/evox/metrics/hv.py:34
msgid "Number of Monte Carlo samples."
msgstr "蒙特卡罗样本数量。"

#: ../../../src/evox/metrics/hv.py:35
msgid "Estimated hypervolume."
msgstr "估计的超体积"

#: ../../source/apidocs/evox/evox.metrics.igd.md:1
#, python-brace-format
msgid "{py:mod}`evox.metrics.igd`"
msgstr "{py:mod}`evox.metrics.igd`"

#: ../../source/apidocs/evox/evox.metrics.igd.md:18
#, python-brace-format
msgid "{py:obj}`igd <evox.metrics.igd.igd>`"
msgstr "{py:obj}`igd <evox.metrics.igd.igd>`"

#: ../../../src/evox/metrics/igd.py:20 ../../../src/evox/metrics/igd.py:30
msgid ""
"Calculate the Inverted Generational Distance (IGD) metric between a set of "
"solutions and the Pareto front."
msgstr "计算一组解决方案与帕累托前沿之间的逆向代际距离 (IGD) 指标。"

#: ../../../src/evox/metrics/igd.py:36
msgid ""
"The power parameter used in the calculation (default is 1). This defines the"
" distance metric (L^p norm)."
msgstr "计算中使用的幂参数（默认为1）。这定义了距离度量（L^p 范数）。"

#: ../../../src/evox/metrics/igd.py:38
msgid ""
"The IGD score, a scalar representing the average distance of the solutions "
"to the Pareto front."
msgstr "IGD得分是一个标量，表示解到帕累托前沿的平均距离。"

#: ../../../src/evox/metrics/igd.py:41
msgid ""
"A lower IGD score indicates that the approximation is closer to the Pareto "
"front."
msgstr "较低的 IGD 分数表示该近似值更接近 Pareto 前沿。"

#: ../../source/apidocs/evox/evox.operators.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators`"
msgstr "{py:mod}`evox.operators`"

#: ../../source/apidocs/evox/evox.operators.md:30
#, python-brace-format
msgid "{py:obj}`__all__ <evox.operators.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.__all__>`"

#: ../../source/apidocs/evox/evox.operators.md:42
msgid ""
"['crossover', 'mutation', 'sampling', 'selection', 'crowding_distance', "
"'non_dominate_rank']"
msgstr "['交叉', '变异', '采样', '选择', '拥挤距离', '非支配等级']"

#: ../../source/apidocs/evox/evox.operators.crossover.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.crossover`"
msgstr "{py:mod}`evox.operators.crossover`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:29
#, python-brace-format
msgid "{py:obj}`__all__ <evox.operators.crossover.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.crossover.__all__>`"

#: ../../source/apidocs/evox/evox.operators.crossover.md:41
msgid ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."
msgstr ""
"['DE_differential_sum', 'DE_exponential_crossover', 'DE_binary_crossover', "
"'DE_arithmetic_recombinat..."

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.crossover.differential_evolution`"
msgstr "{py:mod}`evox.operators.crossover.differential_evolution`"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:18
#, python-brace-format
msgid ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"
msgstr ""
"{py:obj}`DE_differential_sum "
"<evox.operators.crossover.differential_evolution.DE_differential_sum>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:20
#: ../../../src/evox/operators/crossover/differential_evolution.py:42
msgid "Computes the difference vectors' sum in differential evolution."
msgstr "计算差分演化中的差异向量总和。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:22
#, python-brace-format
msgid ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"
msgstr ""
"{py:obj}`DE_binary_crossover "
"<evox.operators.crossover.differential_evolution.DE_binary_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:24
#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "Performs binary crossover in differential evolution."
msgstr "在差分演化中执行二进制交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:26
#, python-brace-format
msgid ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"
msgstr ""
"{py:obj}`DE_exponential_crossover "
"<evox.operators.crossover.differential_evolution.DE_exponential_crossover>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:28
#: ../../../src/evox/operators/crossover/differential_evolution.py:56
msgid "Performs exponential crossover in differential evolution."
msgstr "在差分演化中执行指数交叉。"

#: ../../source/apidocs/evox/evox.operators.crossover.differential_evolution.md:30
#, python-brace-format
msgid ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"
msgstr ""
"{py:obj}`DE_arithmetic_recombination "
"<evox.operators.crossover.differential_evolution.DE_arithmetic_recombination>`"

#: ../../../src/evox/operators/crossover/differential_evolution.py:32
#: ../../../src/evox/operators/crossover/differential_evolution.py:63
msgid "Performs arithmetic recombination in differential evolution."
msgstr "在演化算法中进行差分进化的算术重组。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:44
msgid "The number of padding difference vectors."
msgstr "padding差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:45
msgid "The number of difference vectors used in mutation."
msgstr "变异过程中使用的差异向量的数量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:46
msgid "The index of current individual."
msgstr "当前个体的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:47
msgid "The population tensor."
msgstr "种群张量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:49
msgid "The difference sum and the index of first difference vector."
msgstr "差分总和和第一个差分向量的索引。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:51
#: ../../../src/evox/operators/crossover/differential_evolution.py:58
#: ../../../src/evox/operators/crossover/differential_evolution.py:65
msgid "The mutated vector for each individual in the population."
msgstr "种群中每个个体的变异向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:52
#: ../../../src/evox/operators/crossover/differential_evolution.py:59
#: ../../../src/evox/operators/crossover/differential_evolution.py:66
msgid "The current vector for each individual in the population."
msgstr "每个个体在种群中的当前向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:53
#: ../../../src/evox/operators/crossover/differential_evolution.py:60
msgid "The crossover probability for each individual."
msgstr "每个个体的交叉概率。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:55
#: ../../../src/evox/operators/crossover/differential_evolution.py:62
msgid "The trial vector after crossover for each individual."
msgstr "每个个体交叉后的试验向量。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:67
msgid "The coefficient for each individual."
msgstr "每个个体的系数。"

#: ../../../src/evox/operators/crossover/differential_evolution.py:69
msgid "The trial vector after recombination for each individual."
msgstr "每个个体重组后的试验向量。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.crossover.sbx`"
msgstr "{py:mod}`evox.operators.crossover.sbx`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx.md:18
#, python-brace-format
msgid ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"
msgstr ""
"{py:obj}`simulated_binary <evox.operators.crossover.sbx.simulated_binary>`"

#: ../../../src/evox/operators/crossover/sbx.py:20
#: ../../../src/evox/operators/crossover/sbx.py:30
msgid "Simulated binary crossover (SBX)"
msgstr "模拟二进制交叉 (SBX)"

#: ../../../src/evox/operators/crossover/sbx.py:32
#: ../../../src/evox/operators/crossover/sbx_half.py:32
msgid "Parent solutions in a 2D tensor (size: n x d)."
msgstr "在二维张量中的父解 (大小: n x d)。"

#: ../../../src/evox/operators/crossover/sbx.py:33
#: ../../../src/evox/operators/crossover/sbx_half.py:33
msgid "Probability of doing crossover."
msgstr "进行交叉的概率。"

#: ../../../src/evox/operators/crossover/sbx.py:34
#: ../../../src/evox/operators/crossover/sbx_half.py:34
msgid "Distribution index of SBX."
msgstr "SBX的分配指数。"

#: ../../../src/evox/operators/crossover/sbx.py:36
#: ../../../src/evox/operators/crossover/sbx_half.py:36
msgid "Offspring solutions after crossover."
msgstr "交叉后的后代解。"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.crossover.sbx_half`"
msgstr "{py:mod}`evox.operators.crossover.sbx_half`"

#: ../../source/apidocs/evox/evox.operators.crossover.sbx_half.md:18
#, python-brace-format
msgid ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"
msgstr ""
"{py:obj}`simulated_binary_half "
"<evox.operators.crossover.sbx_half.simulated_binary_half>`"

#: ../../../src/evox/operators/crossover/sbx_half.py:20
#: ../../../src/evox/operators/crossover/sbx_half.py:30
msgid ""
"Generate half of the offspring solutions after simulated binary crossover "
"(SBX)."
msgstr "在进行模拟二进制交叉（SBX）后生成一半的后代解。"

#: ../../source/apidocs/evox/evox.operators.mutation.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.mutation`"
msgstr "{py:mod}`evox.operators.mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:27
#, python-brace-format
msgid "{py:obj}`__all__ <evox.operators.mutation.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.mutation.__all__>`"

#: ../../source/apidocs/evox/evox.operators.mutation.md:39
msgid "['polynomial_mutation']"
msgstr "['polynomial_mutation']"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.mutation.pm_mutation`"
msgstr "{py:mod}`evox.operators.mutation.pm_mutation`"

#: ../../source/apidocs/evox/evox.operators.mutation.pm_mutation.md:18
#, python-brace-format
msgid ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"
msgstr ""
"{py:obj}`polynomial_mutation "
"<evox.operators.mutation.pm_mutation.polynomial_mutation>`"

#: ../../../src/evox/operators/mutation/pm_mutation.py:20
#: ../../../src/evox/operators/mutation/pm_mutation.py:30
msgid "Polynomial mutation. Inspired by PlatEMO."
msgstr "多项式变异。灵感来自 PlatEMO。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:33
msgid "The input population (size: n x d)."
msgstr "输入种群（大小：n x d）。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:36
msgid "Probability of mutation."
msgstr "突变概率。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:37
msgid "The distribution index for polynomial mutation."
msgstr "多项式变异的分布指数。"

#: ../../../src/evox/operators/mutation/pm_mutation.py:39
msgid "The mutated population. (size: n x d)"
msgstr "变异种群。(大小: n x d)"

#: ../../source/apidocs/evox/evox.operators.sampling.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.sampling`"
msgstr "{py:mod}`evox.operators.sampling`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:29
#, python-brace-format
msgid "{py:obj}`__all__ <evox.operators.sampling.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.sampling.__all__>`"

#: ../../source/apidocs/evox/evox.operators.sampling.md:41
msgid ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."
msgstr ""
"['grid_sampling', 'latin_hypercube_sampling', "
"'latin_hypercube_sampling_standard', 'uniform_sampling..."

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.sampling.gird`"
msgstr "{py:mod}`evox.operators.sampling.gird`"

#: ../../source/apidocs/evox/evox.operators.sampling.gird.md:18
#, python-brace-format
msgid "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"
msgstr "{py:obj}`grid_sampling <evox.operators.sampling.gird.grid_sampling>`"

#: ../../../src/evox/operators/sampling/gird.py:20
#: ../../../src/evox/operators/sampling/gird.py:30
msgid "Grid sampling. Inspired by PlatEMO."
msgstr "网格采样。受PlatEMO启发。"

#: ../../../src/evox/operators/sampling/gird.py:33
msgid "Number of grid points along each axis."
msgstr "每个轴上的网格点数。"

#: ../../../src/evox/operators/sampling/gird.py:34
msgid "Dimensionality of the grid (number of axes)."
msgstr "网格的维度（轴的数量）。"

#: ../../../src/evox/operators/sampling/gird.py:36
msgid "Grid points, and the number of samples."
msgstr "网格点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.sampling.latin_hypercube`"
msgstr "{py:mod}`evox.operators.sampling.latin_hypercube`"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:18
#, python-brace-format
msgid ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling_standard "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling_standard>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:20
#: ../../../src/evox/operators/sampling/latin_hypercube.py:34
msgid "Generate Latin Hypercube samples in the unit hypercube."
msgstr "在单位超立方体中生成拉丁超立方体样本。"

#: ../../source/apidocs/evox/evox.operators.sampling.latin_hypercube.md:22
#, python-brace-format
msgid ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"
msgstr ""
"{py:obj}`latin_hypercube_sampling "
"<evox.operators.sampling.latin_hypercube.latin_hypercube_sampling>`"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:24
#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"Generate Latin Hypercube samples in the given hypercube defined by `lb` and "
"`ub`."
msgstr ""
"**生成拉丁超立方样本**\n"
"\n"
"生成拉丁超立方样本在给定的超立方体中，该超立方体由 `lb` 和 `ub` 定义。\n"
"\n"
"```python\n"
"self.latins = Algorithms.latin_hypercube_sample(self.lb, self.ub, self.population_size)\n"
"```"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:36
#: ../../../src/evox/operators/sampling/latin_hypercube.py:43
msgid "The number of sample points to generate."
msgstr "生成的采样点数量。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:37
msgid "The dimensionality of the samples."
msgstr "样本的维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:38
msgid "The device on which to generate the samples."
msgstr "生成样本的设备。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:39
#: ../../../src/evox/operators/sampling/latin_hypercube.py:46
msgid ""
"Whether to generate sample in random positions in the cells or not. Defaults"
" to True."
msgstr "是否在单元格中的随机位置生成样本。默认值为 True。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:41
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，每列代表一个维度。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:44
msgid ""
"The lower bounds of the hypercube. Must be a 1D tensor of size d with same "
"shape, dtype, and device as ub."
msgstr "超立方体的下界。必须是大小为 d 的一维张量，并且具有与 ub 相同的形状、数据类型和设备。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:45
msgid ""
"The upper bounds of the hypercube. Must be a 1D tensor of size d with same "
"shape, dtype, and device as lb."
msgstr "超立方体的上界。必须是大小为 d 的一维张量，并且与 lb 具有相同的形状、数据类型和设备。"

#: ../../../src/evox/operators/sampling/latin_hypercube.py:48
msgid ""
"A tensor of shape (n, d), where each row represents a sample point and each "
"column represents a dimension whose device is the same as lb and ub."
msgstr "一个形状为 (n, d) 的张量，其中每行代表一个样本点，各列代表一个维度，其设备与 lb 和 ub 一致。"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.sampling.uniform`"
msgstr "{py:mod}`evox.operators.sampling.uniform`"

#: ../../source/apidocs/evox/evox.operators.sampling.uniform.md:18
#, python-brace-format
msgid ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"
msgstr ""
"{py:obj}`uniform_sampling "
"<evox.operators.sampling.uniform.uniform_sampling>`"

#: ../../../src/evox/operators/sampling/uniform.py:20
#: ../../../src/evox/operators/sampling/uniform.py:30
msgid ""
"Uniform sampling using Das and Dennis's method, Deb and Jain's method. "
"Inspired by PlatEMO's NBI algorithm."
msgstr "使用Das和Dennis的方法进行均匀采样，Deb和Jain的方法。灵感来源于PlatEMO的NBI算法。"

#: ../../../src/evox/operators/sampling/uniform.py:33
msgid "Number of points to generate."
msgstr "生成的点数。"

#: ../../../src/evox/operators/sampling/uniform.py:34
msgid "Dimensionality of the grid."
msgstr "网格的维度。"

#: ../../../src/evox/operators/sampling/uniform.py:36
msgid "The generated points, and the number of samples."
msgstr "生成的点和样本数量。"

#: ../../source/apidocs/evox/evox.operators.selection.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.selection`"
msgstr "{py:mod}`evox.operators.selection`"

#: ../../source/apidocs/evox/evox.operators.selection.md:30
#, python-brace-format
msgid "{py:obj}`__all__ <evox.operators.selection.__all__>`"
msgstr "{py:obj}`__all__ <evox.operators.selection.__all__>`"

#: ../../source/apidocs/evox/evox.operators.selection.md:42
msgid ""
"['crowding_distance', 'nd_environmental_selection', 'non_dominate_rank', "
"'ref_vec_guided', 'select_r..."
msgstr ""
"['crowding_distance', 'nd_environmental_selection', 'non_dominate_rank', "
"'ref_vec_guided', 'select_r...']"

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.selection.find_pbest`"
msgstr "{py:mod}`evox.operators.selection.find_pbest`"

#: ../../source/apidocs/evox/evox.operators.selection.find_pbest.md:18
#, python-brace-format
msgid ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"
msgstr ""
"{py:obj}`select_rand_pbest "
"<evox.operators.selection.find_pbest.select_rand_pbest>`"

#: ../../../src/evox/operators/selection/find_pbest.py:20
#: ../../../src/evox/operators/selection/find_pbest.py:30
msgid ""
"Selects a random personal-best vector from the population for each "
"individual."
msgstr "从种群中为每个个体随机选择一个个人最佳向量。"

#: ../../../src/evox/operators/selection/find_pbest.py:32
msgid ""
"The proportion of the population to consider as best. Must be between 0 and "
"1."
msgstr "种群中考虑为最好的比例。必须在 0 和 1 之间。"

#: ../../../src/evox/operators/selection/find_pbest.py:33
msgid "The population tensor of shape (pop_size, dim)."
msgstr "种群张量，形状为 (pop_size, dim)。"

#: ../../../src/evox/operators/selection/find_pbest.py:34
msgid "The fitness tensor of shape (pop_size,)."
msgstr "适应度张量的形状为 (pop_size,)。"

#: ../../../src/evox/operators/selection/find_pbest.py:36
msgid ""
"A tensor containing the selected personal-best vector for each individual."
msgstr "一个张量，包含每个个体的选择的个人最佳向量。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.selection.non_dominate`"
msgstr "{py:mod}`evox.operators.selection.non_dominate`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:18
#, python-brace-format
msgid ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"
msgstr ""
"{py:obj}`dominate_relation "
"<evox.operators.selection.non_dominate.dominate_relation>`"

#: ../../../src/evox/operators/selection/non_dominate.py:20
#: ../../../src/evox/operators/selection/non_dominate.py:70
#, python-brace-format
msgid ""
"Return the domination relation matrix A, where A_{ij} is True if x_i "
"dominates y_j."
msgstr "返回支配关系矩阵 A，其中 A_{ij} 为 True，如果 x_i 支配 y_j。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:22
#, python-brace-format
msgid ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"
msgstr ""
"{py:obj}`update_dc_and_rank "
"<evox.operators.selection.non_dominate.update_dc_and_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:24
#: ../../../src/evox/operators/selection/non_dominate.py:77
msgid "Update the dominate count and ranks for the current Pareto front."
msgstr "更新当前帕累托前沿的主导计数和等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:26
#, fuzzy, python-brace-format
msgid "{py:obj}`_igr_fake <evox.operators.selection.non_dominate._igr_fake>`"
msgstr "{py:obj}`_igr_fake <evox.operators.selection.non_dominate._igr_fake>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:30
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_igr_fake_vmap "
"<evox.operators.selection.non_dominate._igr_fake_vmap>`"
msgstr ""
"{py:obj}`_igr_fake_vmap "
"<evox.operators.selection.non_dominate._igr_fake_vmap>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:34
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_vmap_iterative_get_ranks_compile "
"<evox.operators.selection.non_dominate._vmap_iterative_get_ranks_compile>`"
msgstr ""
"{py:obj}`_vmap_iterative_get_ranks_compile "
"<evox.operators.selection.non_dominate._vmap_iterative_get_ranks_compile>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:38
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_vmap_iterative_get_ranks "
"<evox.operators.selection.non_dominate._vmap_iterative_get_ranks>`"
msgstr ""
"{py:obj}`_vmap_iterative_get_ranks "
"<evox.operators.selection.non_dominate._vmap_iterative_get_ranks>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:42
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_iterative_get_ranks_compile "
"<evox.operators.selection.non_dominate._iterative_get_ranks_compile>`"
msgstr ""
"{py:obj}`_iterative_get_ranks_compile "
"<evox.operators.selection.non_dominate._iterative_get_ranks_compile>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:46
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_iterative_get_ranks "
"<evox.operators.selection.non_dominate._iterative_get_ranks>`"
msgstr ""
"{py:obj}`_iterative_get_ranks "
"<evox.operators.selection.non_dominate._iterative_get_ranks>`"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:50
#, python-brace-format
msgid ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"
msgstr ""
"{py:obj}`non_dominate_rank "
"<evox.operators.selection.non_dominate.non_dominate_rank>`"

#: ../../../src/evox/operators/selection/non_dominate.py:52
#: ../../../src/evox/operators/selection/non_dominate.py:126
msgid ""
"Compute the non-domination rank for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的非支配等级。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:54
#, python-brace-format
msgid ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"
msgstr ""
"{py:obj}`crowding_distance "
"<evox.operators.selection.non_dominate.crowding_distance>`"

#: ../../../src/evox/operators/selection/non_dominate.py:56
#: ../../../src/evox/operators/selection/non_dominate.py:133
msgid ""
"Compute the crowding distance for a set of solutions in multi-objective "
"optimization."
msgstr "计算多目标优化中一组解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.non_dominate.md:58
#, python-brace-format
msgid ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"
msgstr ""
"{py:obj}`nd_environmental_selection "
"<evox.operators.selection.non_dominate.nd_environmental_selection>`"

#: ../../../src/evox/operators/selection/non_dominate.py:60
#: ../../../src/evox/operators/selection/non_dominate.py:140
msgid ""
"Perform environmental selection based on non-domination rank and crowding "
"distance."
msgstr "基于非支配等级和拥挤距离进行环境选择。"

#: ../../../src/evox/operators/selection/non_dominate.py:72
msgid ""
"An array with shape (n1, m) where n1 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n1, m) 的数组，其中 n1 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:73
msgid ""
"An array with shape (n2, m) where n2 is the population size and m is the "
"number of objectives."
msgstr "一个形状为 (n2, m) 的数组，其中 n2 是种群大小，m 是目标数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:75
msgid "The domination relation matrix of x and y."
msgstr "x 和 y 的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:79
msgid "The domination relation matrix between individuals."
msgstr "个体之间的支配关系矩阵。"

#: ../../../src/evox/operators/selection/non_dominate.py:80
msgid "The count of how many individuals dominate each individual."
msgstr "每个个体被多少个体所支配的计数。"

#: ../../../src/evox/operators/selection/non_dominate.py:81
msgid "A tensor indicating which individuals are in the current Pareto front."
msgstr "一个张量表示当前帕累托前沿中的个体。"

#: ../../../src/evox/operators/selection/non_dominate.py:82
msgid "A tensor storing the rank of each individual."
msgstr "每个个体的等级的张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:83
msgid "The current Pareto front rank."
msgstr "当前帕累托前沿排名"

#: ../../../src/evox/operators/selection/non_dominate.py:85
msgid ""
"rank: Updated rank tensor.  dominate_count: Updated dominate count tensor."
msgstr ""
"**rank:** 更新的排名张量。\n"
"**dominate_count:** 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:86
msgid "**rank**: Updated rank tensor."
msgstr "**rank**: 更新后的等级张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:87
msgid "**dominate_count**: Updated dominate count tensor."
msgstr "**dominate_count**: 更新的支配计数张量。"

#: ../../../src/evox/operators/selection/non_dominate.py:128
msgid ""
"The non-domination rank is a measure of the Pareto optimality of each "
"solution."
msgstr "每个解的帕累托最优度被称为非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:130
#: ../../../src/evox/operators/selection/non_dominate.py:137
#: ../../../src/evox/operators/selection/non_dominate.py:143
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" an objective."
msgstr "一个二维张量，其中每一行代表一个解，每一列代表一个目标。"

#: ../../../src/evox/operators/selection/non_dominate.py:132
msgid "A 1D tensor containing the non-domination rank for each solution."
msgstr "一个 1D 张量，包含每个解的非支配排名。"

#: ../../../src/evox/operators/selection/non_dominate.py:135
msgid ""
"The crowding distance is a measure of the diversity of solutions within a "
"Pareto front."
msgstr ""
"**Pareto 前景中解的多样性度量：**\n"
"\n"
"**Crowding Distance**\n"
"\n"
"Crowding距离是Pareto前景中解的多样性度量。 \n"
"\n"
"**References**\n"
"\n"
"[1] \n"
"[2]"

#: ../../../src/evox/operators/selection/non_dominate.py:138
msgid "A 1D boolean tensor indicating which solutions should be considered."
msgstr "一个 1D 布尔张量，指示哪些解决方案应该被考虑。"

#: ../../../src/evox/operators/selection/non_dominate.py:140
msgid "A 1D tensor containing the crowding distance for each solution."
msgstr "一个 1D 张量，包含每个解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:142
msgid ""
"A 2D tensor where each row represents a solution, and each column represents"
" a decision variable."
msgstr "一个二维张量，其中每行代表一个解决方案，每列代表一个决策变量。"

#: ../../../src/evox/operators/selection/non_dominate.py:144
msgid "The number of solutions to select."
msgstr "选择的解的数量。"

#: ../../../src/evox/operators/selection/non_dominate.py:146
msgid ""
"A tuple of four tensors:x: The selected solutions.  f: The corresponding "
"objective values.  rank: The non-domination rank of the selected solutions."
"  crowding_dis: The crowding distance of the selected solutions."
msgstr ""
"一个由四个张量组成的元组：x：选择的解。 f：对应的目标值。 rank：选择的解的非支配等级。 crowding_dis：选择的解的拥挤距离。"

#: ../../../src/evox/operators/selection/non_dominate.py:147
msgid "A tuple of four tensors:"
msgstr "一个包含四个张量的元组："

#: ../../../src/evox/operators/selection/non_dominate.py:148
msgid "**x**: The selected solutions."
msgstr "**x**: 选中的解。"

#: ../../../src/evox/operators/selection/non_dominate.py:149
msgid "**f**: The corresponding objective values."
msgstr "**f**: 对应的目标值。"

#: ../../../src/evox/operators/selection/non_dominate.py:150
msgid "**rank**: The non-domination rank of the selected solutions."
msgstr "**rank**: 演化算法中的非支配等级，即选定的解决方案的非支配等级。"

#: ../../../src/evox/operators/selection/non_dominate.py:151
msgid "**crowding_dis**: The crowding distance of the selected solutions."
msgstr "**crowding_dis**: 所选解的拥挤距离。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.selection.rvea_selection`"
msgstr "{py:mod}`evox.operators.selection.rvea_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:18
#, python-brace-format
msgid "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"
msgstr "{py:obj}`apd_fn <evox.operators.selection.rvea_selection.apd_fn>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:20
#: ../../../src/evox/operators/selection/rvea_selection.py:34
msgid "Compute the APD (Angle-Penalized Distance) based on the given inputs."
msgstr "根据给定的输入计算APD（角惩罚距离）。"

#: ../../source/apidocs/evox/evox.operators.selection.rvea_selection.md:22
#, python-brace-format
msgid ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"
msgstr ""
"{py:obj}`ref_vec_guided "
"<evox.operators.selection.rvea_selection.ref_vec_guided>`"

#: ../../../src/evox/operators/selection/rvea_selection.py:24
#: ../../../src/evox/operators/selection/rvea_selection.py:41
msgid ""
"Perform the Reference Vector Guided Evolutionary Algorithm (RVEA) selection "
"process."
msgstr "执行参考向量指导演化算法 (RVEA) 选择过程。"

#: ../../../src/evox/operators/selection/rvea_selection.py:36
msgid "A tensor representing the indices of the partition."
msgstr "表示分区索引的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:37
msgid "A tensor representing the gamma."
msgstr "一个表示伽马的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:38
msgid "A tensor representing the angle."
msgstr "表示角度的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:39
msgid "A tensor of shape (n, m) representing the objectives of the solutions."
msgstr "一个形状为 (n, m) 的张量，表示解的目标。"

#: ../../../src/evox/operators/selection/rvea_selection.py:40
msgid ""
"A tensor representing the parameter theta used for scaling the reference "
"vector."
msgstr "一个张量表示用于缩放参考向量的参数 theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:42
msgid "A tensor containing the APD values for each solution."
msgstr "一个包含每个解的 APD 值的张量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:43
msgid ""
"This function selects solutions based on the Reference Vector Guided "
"Evolutionary Algorithm. It calculates the distances and angles between "
"solutions and reference vectors, and returns the next set of solutions to be"
" evolved."
msgstr "此函数基于参考向量引导的演化算法选择解决方案。它计算解决方案与参考向量之间的距离和角度，并返回下一组待演化的解决方案。"

#: ../../../src/evox/operators/selection/rvea_selection.py:47
msgid ""
"A tensor of shape (n, d) representing the current population solutions."
msgstr "一个形状为 (n, d) 的张量，表示当前种群的解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:48
#: ../../../src/evox/problems/numerical/dtlz.py:64
msgid ""
"A tensor of shape (n, m) representing the objective values for each "
"solution."
msgstr "表示每个解的目标值的张量，以形状 (n, m) 表示。"

#: ../../../src/evox/operators/selection/rvea_selection.py:49
msgid "A tensor of shape (r, m) representing the reference vectors."
msgstr "一个形状为 (r, m) 的张量，表示参考向量。"

#: ../../../src/evox/operators/selection/rvea_selection.py:50
msgid "A tensor representing the parameter theta used in the APD calculation."
msgstr "一个张量，表示在APD计算中使用的参数theta。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid ""
"A tuple containing:next_x: The next selected solutions.  next_f: The "
"objective values of the next selected solutions."
msgstr "一个元组包含：next_x：下一个选定的解决方案。 next_f：下一个选定的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:52
msgid "A tuple containing:"
msgstr "一个元组包含："

#: ../../../src/evox/operators/selection/rvea_selection.py:53
msgid "next_x: The next selected solutions."
msgstr "next_x: 下一步选择的解。"

#: ../../../src/evox/operators/selection/rvea_selection.py:54
msgid "next_f: The objective values of the next selected solutions."
msgstr "next_f: 下一个选择的解决方案的目标值。"

#: ../../../src/evox/operators/selection/rvea_selection.py:57
msgid ""
"The function computes the distances between the solutions and reference "
"vectors, and selects the solutions with the minimum APD. It currently uses a"
" suboptimal selection implementation, and future improvements will optimize "
"the process using a `segment_sort` or `segment_argmin` in CUDA."
msgstr ""
"该函数计算解与参考向量之间的距离，并选择具有最小APD的解。它当前使用的是次优选择实现，未来的改进将使用CUDA中的`segment_sort`或`segment_argmin`来优化该过程。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:1
#, python-brace-format
msgid "{py:mod}`evox.operators.selection.tournament_selection`"
msgstr "{py:mod}`evox.operators.selection.tournament_selection`"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:18
#, python-brace-format
msgid ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"
msgstr ""
"{py:obj}`tournament_selection_multifit "
"<evox.operators.selection.tournament_selection.tournament_selection_multifit>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:20
#: ../../../src/evox/operators/selection/tournament_selection.py:34
msgid "Perform tournament selection based on multiple fitness values."
msgstr "基于多个适应度值执行锦标赛选择。"

#: ../../source/apidocs/evox/evox.operators.selection.tournament_selection.md:22
#, python-brace-format
msgid ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"
msgstr ""
"{py:obj}`tournament_selection "
"<evox.operators.selection.tournament_selection.tournament_selection>`"

#: ../../../src/evox/operators/selection/tournament_selection.py:24
#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid "Perform tournament selection based on single fitness values."
msgstr "根据单一适应度值执行锦标赛选择。"

#: ../../../src/evox/operators/selection/tournament_selection.py:36
#: ../../../src/evox/operators/selection/tournament_selection.py:43
msgid "Number of rounds of selection (how many solutions to select)."
msgstr "选择轮数（选择多少个解）。"

#: ../../../src/evox/operators/selection/tournament_selection.py:37
msgid ""
"A list of 1D tensors, each representing the fitness values of candidates for"
" different objectives."
msgstr "一个1D张量的列表，每个张量表示不同目标的候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:38
#: ../../../src/evox/operators/selection/tournament_selection.py:45
msgid "Number of candidates in each tournament. Defaults to 2."
msgstr "每个锦标赛中的候选人数量。 默认值为 2。"

#: ../../../src/evox/operators/selection/tournament_selection.py:39
#: ../../../src/evox/operators/selection/tournament_selection.py:46
msgid "Indices of the selected solutions after tournament selection."
msgstr "所选解决方案在锦标赛选择后的索引。"

#: ../../../src/evox/operators/selection/tournament_selection.py:41
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values across multiple objectives."
msgstr "此函数通过随机选择每轮的一组候选者进行锦标赛选择，并根据他们在多个目标上的适应度值从每组中选择最佳者。"

#: ../../../src/evox/operators/selection/tournament_selection.py:44
msgid "A 1D tensor representing the fitness values of candidates."
msgstr "一个一维张量，表示候选者的适应度值。"

#: ../../../src/evox/operators/selection/tournament_selection.py:48
msgid ""
"This function performs tournament selection by randomly selecting a group of"
" candidates for each round, and selecting the best one from each group based"
" on their fitness values."
msgstr "此函数通过随机选择每轮的候选者组来执行锦标赛选择，并根据他们的适应度值从每组中选择最佳者。"

#: ../../source/apidocs/evox/evox.problems.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems`"
msgstr "{py:mod}`evox.problems`"

#: ../../source/apidocs/evox/evox.problems.md:37
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.problems.__all__>`"
msgstr "{py:obj}`__all__ <evox.problems.__all__>`"

#: ../../source/apidocs/evox/evox.problems.md:49
msgid "['neuroevolution', 'numerical', 'hpo_wrapper']"
msgstr "['神经演化', '数值', 'hpo_wrapper']"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.hpo_wrapper`"
msgstr "{py:mod}`evox.problems.hpo_wrapper`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:18
#, python-brace-format
msgid "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"
msgstr "{py:obj}`HPOMonitor <evox.problems.hpo_wrapper.HPOMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:20
#: ../../../src/evox/problems/hpo_wrapper.py:45
msgid ""
"The base class for hyper parameter optimization (HPO) monitors used in "
"`HPOProblem.workflow.monitor`."
msgstr "用于`HPOProblem.workflow.monitor`中的超参数优化（HPO）监控的基类。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:22
#, python-brace-format
msgid ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"
msgstr ""
"{py:obj}`HPOFitnessMonitor <evox.problems.hpo_wrapper.HPOFitnessMonitor>`"

#: ../../../src/evox/problems/hpo_wrapper.py:24
#: ../../../src/evox/problems/hpo_wrapper.py:70
msgid ""
"The monitor for hyper parameter optimization (HPO) that records the best "
"fitness found so far in the optimization process."
msgstr "用于超参数优化（HPO）的监视器，记录在优化过程中迄今为止发现的最佳适应度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:26
#, python-brace-format
msgid ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"
msgstr ""
"{py:obj}`HPOProblemWrapper <evox.problems.hpo_wrapper.HPOProblemWrapper>`"

#: ../../../src/evox/problems/hpo_wrapper.py:28
#: ../../../src/evox/problems/hpo_wrapper.py:102
msgid "The problem for hyper parameter optimization (HPO)."
msgstr "超参数优化（HPO）问题。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:30
#, fuzzy, python-brace-format
msgid "{py:obj}`HPOData <evox.problems.hpo_wrapper.HPOData>`"
msgstr "{py:obj}`HPOData <evox.problems.hpo_wrapper.HPOData>`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:42
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"
msgstr "Bases: {py:obj}`evox.core.Monitor`, {py:obj}`abc.ABC`"

#: ../../../src/evox/problems/hpo_wrapper.py:59
#: ../../../src/evox/problems/hpo_wrapper.py:91
msgid ""
"Get the best fitness found so far in the optimization process that this "
"monitor is monitoring."
msgstr "在此监控器监控的优化过程中，获取迄今为止找到的最佳适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:61
#: ../../../src/evox/problems/hpo_wrapper.py:93
msgid "The best fitness so far."
msgstr "迄今为止的最佳适应度。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:67
#, python-brace-format
msgid "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"
msgstr "Bases: {py:obj}`evox.problems.hpo_wrapper.HPOMonitor`"

#: ../../../src/evox/problems/hpo_wrapper.py:76
msgid "Initialize the HPO fitness monitor."
msgstr "初始化 HPO 适应度监控器。"

#: ../../../src/evox/problems/hpo_wrapper.py:78
msgid ""
"The metric function to use for multi-objective optimization, unused in "
"single-objective optimization. Currently we only support \"IGD\" or \"HV\" "
"for multi-objective optimization. Defaults to None."
msgstr "用于多目标优化的度量函数，在单目标优化中不使用。目前，我们仅支持多目标优化的“IGD”或“HV”。默认为None。"

#: ../../../src/evox/problems/hpo_wrapper.py:83
msgid ""
"Update the best fitness value found so far based on the provided fitness "
"tensor and multi-objective metric."
msgstr "根据提供的适应度张量和多目标度量更新迄今为止找到的最佳适应度值。"

#: ../../../src/evox/problems/hpo_wrapper.py:85
msgid ""
"A tensor representing fitness values. It can be either a 1D tensor for "
"single-objective optimization or a 2D tensor for multi-objective "
"optimization."
msgstr "表示适应度值的张量。对于单目标优化，它可以是一个一维张量；对于多目标优化，它可以是一个二维张量。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md
#: ../../source/apidocs/evox/evox.problems.numerical.md
msgid "Raises"
msgstr "引发"

#: ../../../src/evox/problems/hpo_wrapper.py:87
msgid "If the dimensionality of the fitness tensor is not 1 or 2."
msgstr "如果适应度张量的维度不是1或2。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:99
#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:30
#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:30
#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:94
#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:44
#: ../../source/apidocs/evox/evox.problems.numerical.md:287
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.Problem`"
msgstr "Bases: {py:obj}`evox.core.Problem`"

#: ../../../src/evox/problems/hpo_wrapper.py:108
msgid "Initialize the HPO problem wrapper."
msgstr "初始化 HPO 问题包装器。"

#: ../../../src/evox/problems/hpo_wrapper.py:110
msgid "The number of iterations to be executed in the optimization process."
msgstr "在优化过程中要执行的迭代次数。"

#: ../../../src/evox/problems/hpo_wrapper.py:111
msgid ""
"The number of instances to be executed in parallel in the optimization "
"process, i.e., the population size of the outer algorithm."
msgstr "在优化过程中并行执行的实例数量，即外层算法的种群大小。"

#: ../../../src/evox/problems/hpo_wrapper.py:112
msgid ""
"The workflow to be used in the optimization process. Must be wrapped by "
"core.jit_class."
msgstr "在优化过程中使用的工作流。必须由 core.jit_class 包装。"

#: ../../../src/evox/problems/hpo_wrapper.py:113
msgid ""
"The number of times to repeat the evaluation process for each instance. "
"Defaults to 1."
msgstr "每个实例重复评估过程的次数。默认值为1。"

#: ../../../src/evox/problems/hpo_wrapper.py:114
msgid ""
"Whether to copy the initial state of the workflow for each evaluation. "
"Defaults to True. If your workflow contains operations that IN-PLACE modify "
"the tensor(s) in initial state, this should be set to True. Otherwise, you "
"can set it to False to save memory."
msgstr ""
"是否为每次评估复制工作流的初始状态。默认为 True。如果您的工作流包含对初始状态中的张量进行原地修改的操作，则应将其设置为 "
"True。否则，您可以将其设置为 False 以节省内存。"

#: ../../../src/evox/problems/hpo_wrapper.py:115
msgid ""
"Evaluate the fitness (given by the internal workflow's monitor) of the batch"
" of hyper parameters by running the internal workflow."
msgstr "评估一批超参数的适应度（由内部工作流的监控器提供），通过运行内部工作流。"

#: ../../../src/evox/problems/hpo_wrapper.py:117
msgid "The hyper parameters to evaluate."
msgstr "需要评估的超参数。"

#: ../../../src/evox/problems/hpo_wrapper.py:119
msgid "The final fitness of the hyper parameters."
msgstr "最终的超参数适应度。"

#: ../../../src/evox/problems/hpo_wrapper.py:123
msgid ""
"Return the initial hyper-parameters dictionary of the underlying workflow."
msgstr "返回底层工作流的初始超参数字典。"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:139
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:42
#, python-brace-format
msgid "Bases: {py:obj}`typing.NamedTuple`"
msgstr "Bases: {py:obj}`typing.NamedTuple`"

#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:149
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:160
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:171
#: ../../source/apidocs/evox/evox.problems.hpo_wrapper.md:182
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:52
#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:63
msgid "None"
msgstr "None"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.neuroevolution`"
msgstr "{py:mod}`evox.problems.neuroevolution`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.neuroevolution.brax`"
msgstr "{py:mod}`evox.problems.neuroevolution.brax`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.brax.md:18
#, python-brace-format
msgid "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"
msgstr "{py:obj}`BraxProblem <evox.problems.neuroevolution.brax.BraxProblem>`"

#: ../../../src/evox/problems/neuroevolution/brax.py:20
#: ../../../src/evox/problems/neuroevolution/brax.py:33
msgid "The Brax problem wrapper."
msgstr "Brax 问题封装器。"

#: ../../../src/evox/problems/neuroevolution/brax.py:39
msgid ""
"Construct a Brax-based problem. Firstly, you need to define a policy model. "
"Then you need to set the `environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`, the maximum episode "
"length, the number of episodes to evaluate for each individual. For each "
"individual, it will run the policy with the environment for num_episodes "
"times with different seed, and use the reduce_fn to reduce the rewards "
"(default to average). Different individuals will share the same set of "
"random keys in each iteration."
msgstr ""
"构建一个基于 Brax 的问题。首先，您需要定义一个策略模型。然后，您需要设置`environment name "
"<https://github.com/google/brax/tree/main/brax/envs>`，最大 episode "
"长度，以及用于评估每个个体的 episode 数量。对于每个个体，它将在环境中运行策略 num_episodes 次，每次使用不同的种子，并使用 "
"reduce_fn 函数对奖励进行归约（默认为取平均值）。在每次迭代中，不同个体将共享同一组随机键。"

#: ../../../src/evox/problems/neuroevolution/brax.py:48
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:48
msgid ""
"The policy model whose forward function is :code:forward(batched_obs) -> "
"action."
msgstr "该策略模型的前向函数是: `forward(batched_obs) -> action"

#: ../../../src/evox/problems/neuroevolution/brax.py:49
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:49
msgid "The environment name."
msgstr "环境名。"

#: ../../../src/evox/problems/neuroevolution/brax.py:50
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:50
msgid "The maximum number of time steps of each episode."
msgstr "每个episode的最大时间步数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:51
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:51
msgid "The number of episodes to evaluate for each individual."
msgstr "用于评估每个个体的幕数量。"

#: ../../../src/evox/problems/neuroevolution/brax.py:52
msgid ""
"The seed used to create a PRNGKey for the brax environment. When None, "
"randomly select one. Default to None."
msgstr "用于为 brax 环境创建 PRNGKey 的 seed。当为 None 时，随机选择一个。默认值为 None。"

#: ../../../src/evox/problems/neuroevolution/brax.py:53
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:53
msgid ""
"The size of the population to be evaluated. If None, we expect the input to "
"have a population size of 1."
msgstr "要评估的种群大小。如果为 None，我们期望输入的种群大小为 1。"

#: ../../../src/evox/problems/neuroevolution/brax.py:54
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:54
msgid ""
"Indicates whether to rotate the random key for each iteration (default is "
"True). <br/> If True, the random key will rotate after each iteration, "
"resulting in non-deterministic and potentially noisy fitness evaluations. "
"This means that identical policy weights may yield different fitness values "
"across iterations. <br/> If False, the random key remains the same for all "
"iterations, ensuring consistent fitness evaluations."
msgstr ""
"表示是否在每次迭代中旋转随机键（默认为 True）。<br/> 如果为 "
"True，随机键将在每次迭代后旋转，从而导致非确定性且可能有噪声的适应度评估。这意味着相同的策略权重在不同迭代中可能会产生不同的适应度值。<br/> "
"如果为 False，随机键在所有迭代中保持不变，以确保适应度评估的一致性。"

#: ../../../src/evox/problems/neuroevolution/brax.py:55
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:55
msgid ""
"The function to reduce the rewards of multiple episodes. Default to "
"torch.mean."
msgstr "用于减少多个episode奖励的函数。默认值为torch.mean。"

#: ../../../src/evox/problems/neuroevolution/brax.py:56
msgid ""
"Brax's backend. If None, the default backend of the environment will be "
"used. Default to None."
msgstr "Brax 的后端。如果为 None，将使用环境的默认后端。默认为 None。"

#: ../../../src/evox/problems/neuroevolution/brax.py:57
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:56
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:46
msgid ""
"The device to run the computations on. Defaults to the current default "
"device."
msgstr "用于运行计算的设备。默认为当前默认设备。"

#: ../../../src/evox/problems/neuroevolution/brax.py:58
msgid "Whether to compile the policy model. Default to True."
msgstr "是否编译策略模型。默认值为 True。"

#: ../../../src/evox/problems/neuroevolution/brax.py:60
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:58
#: ../../source/index.md:14
msgid "Examples"
msgstr "示例"

#: ../../../src/evox/problems/neuroevolution/brax.py:74
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:72
msgid "The initial key is obtained from `torch.random.get_rng_state()`."
msgstr "初始密钥是从 `torch.random.get_rng_state()` 获得的。"

#: ../../../src/evox/problems/neuroevolution/brax.py:78
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:76
msgid ""
"This problem does NOT support HPO wrapper "
"(`problems.hpo_wrapper.HPOProblemWrapper`) out-of-box, i.e., the workflow "
"containing this problem CANNOT be vmapped. *However*, by setting `pop_size` "
"to the multiplication of inner population size and outer population size, "
"you can still use this problem in a HPO workflow. Yet, the `num_repeats` of "
"HPO wrapper *must* be set to 1, please use the parameter `num_episodes` "
"instead."
msgstr ""
"此问题不支持 HPO 包装器 (`problems.hpo_wrapper.HPOProblemWrapper`) 默认使用，即包含此问题的工作流无法被"
" vmapped*然而*，通过将 `pop_size` 设置为内种群大小与外种群大小的乘积，仍然可以在 HPO 工作流中使用此问题。但 HPO 包装器的"
" `num_repeats` *必须* 设置为 1，请使用参数 `num_episodes` 替代。"

#: ../../../src/evox/problems/neuroevolution/brax.py:54
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:54
msgid ""
"Evaluate the final rewards of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批量）的最终奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:56
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:56
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:80
msgid ""
"A dictionary of parameters where each key is a parameter name and each value"
" is a tensor of shape (batch_size, *param_shape) representing the batched "
"parameters of batched models."
msgstr "参数字典，其中每个键是参数名称，每个值是形状为 (batch_size, *param_shape) 的张量，表示批量模型的批量参数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:58
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:58
msgid ""
"A tensor of shape (batch_size,) containing the reward of each sample in the "
"population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的奖励。"

#: ../../../src/evox/problems/neuroevolution/brax.py:62
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:62
msgid "Visualize the brax environment with the given policy and weights."
msgstr "可视化带有指定策略和权重的brax环境。"

#: ../../../src/evox/problems/neuroevolution/brax.py:64
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:64
msgid "The weights of the policy model. Which is a dictionary of parameters."
msgstr "策略模型的权重。这是一个参数字典。"

#: ../../../src/evox/problems/neuroevolution/brax.py:65
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:65
msgid ""
"The seed used to create a PRNGKey for the brax environment. When None, use "
"the current key. Default to None."
msgstr "用于为 brax 环境创建 PRNGKey 的种子。当为 None 时，使用当前的 key。默认值为 None。"

#: ../../../src/evox/problems/neuroevolution/brax.py:66
msgid ""
"The output type of the visualization, \"HTML\" or \"rgb_array\". Default to "
"\"HTML\"."
msgstr "可视化的输出类型，“HTML”或“rgb_array”。默认为“HTML”。"

#: ../../../src/evox/problems/neuroevolution/brax.py:67
msgid "Additional arguments to be passed to the visualization function."
msgstr "传递给可视化函数的附加参数。"

#: ../../../src/evox/problems/neuroevolution/brax.py:69
msgid "The visualization output."
msgstr "可视化输出。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.problems.neuroevolution.mujoco_playground`"
msgstr "{py:mod}`evox.problems.neuroevolution.mujoco_playground`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.mujoco_playground.md:18
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`MujocoProblem "
"<evox.problems.neuroevolution.mujoco_playground.MujocoProblem>`"
msgstr ""
"{py:obj}`MujocoProblem "
"<evox.problems.neuroevolution.mujoco_playground.MujocoProblem>`"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:20
#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:33
msgid "The MJX problem wrapper."
msgstr "MJX 问题封装器。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:39
msgid ""
"Construct a MujocoPlayground-based problem. Firstly, you need to define a "
"policy model. Then you need to set the `environment name "
"<https://github.com/google-"
"deepmind/mujoco_playground/tree/main/mujoco_playground/_src/registry.py>`, "
"the maximum episode length, the number of episodes to evaluate for each "
"individual. For each individual, it will run the policy with the environment"
" for num_episodes times with different seed, and use the reduce_fn to reduce"
" the rewards (default to average). Different individuals will share the same"
" set of random keys in each iteration."
msgstr ""
"构建一个基于MujocoPlayground的问题。首先，你需要定义一个policy模型。然后，你需要设置`environment name "
"<https://github.com/google-"
"deepmind/mujoco_playground/tree/main/mujoco_playground/_src/registry.py>`，最大episode长度，以及评估每个个体的episode数量。对于每个个体，将使用不同的seed在环境中运行该policy"
" num_episodes次，并使用reduce_fn来合并奖励（默认是平均值）。在每次迭代中，不同个体将共享同一组随机键。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:52
msgid ""
"The seed used to create a PRNGKey for the Mujoco environment. When None, "
"randomly select one. Default to None."
msgstr "用于为Mujoco环境创建PRNGKey的种子。当为None时，随机选择一个。默认值为None。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:66
msgid "The output type of the visualization, \"mp4\" or \"gif\". Default to \"mp4\"."
msgstr "可视化的输出类型，“mp4”或“gif”。默认值为“mp4”。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:67
msgid "The path to save the output video. Default to \"output_video\"."
msgstr "保存输出视频的路径。默认值为 \"output_video\"。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:68
msgid "Additional arguments to be passed to the MjxEnv.render() function."
msgstr "传递给 MjxEnv.render() 函数的额外参数。"

#: ../../../src/evox/problems/neuroevolution/mujoco_playground.py:70
msgid "The path to the saved file."
msgstr "保存文件的路径。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.neuroevolution.supervised_learning`"
msgstr "{py:mod}`evox.problems.neuroevolution.supervised_learning`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.supervised_learning.md:18
#, python-brace-format
msgid ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"
msgstr ""
"{py:obj}`SupervisedLearningProblem "
"<evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem>`"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:20
#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:33
msgid ""
"The supervised learning problem to test a model's parameters or a batch of "
"parameters with given data and criterion."
msgstr "监督学习问题是使用给定的数据和标准来测试模型参数或一批参数。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:39
msgid "Initialize the `SupervisedLearningProblem`."
msgstr "初始化 `SupervisedLearningProblem`。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:41
msgid "The neural network model whose parameters need to be evaluated."
msgstr "需要评估参数的神经网络模型。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:42
msgid "The data loader providing the dataset for evaluation."
msgstr "用于评估的数据加载器提供数据集。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:43
msgid "The loss function used to evaluate the parameters' performance."
msgstr "用于评估参数性能的损失函数。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:44
msgid ""
"The number of batches to be evaluated in a single evaluation. When set to "
"-1, will go through the whole dataset. Defaults to 1."
msgstr "每次评估中要计算的批次数。当设置为 -1 时，将遍历整个数据集。默认值为 1。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:45
msgid ""
"The size of the population (batch size of the parameters) to be evaluated. "
"Defaults to None for single-run mode."
msgstr "种群的大小（参数的批量大小）需要进行评估。默认为 None，表示单次运行模式。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:47
msgid ""
"The reduction method for the criterion. 'mean' | 'sum'. Defaults to "
"\"mean\"."
msgstr "用于标准的归约方法。'mean' | 'sum'。默认值为“mean”。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:49
msgid "If the data loader contains no items."
msgstr "如果数据加载器不包含任何项目。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:52
msgid ""
"This problem does NOT support HPO wrapper "
"(`problems.hpo_wrapper.HPOProblemWrapper`), i.e., the workflow containing "
"this problem CANNOT be vmapped."
msgstr ""
"此问题不支持 HPO 包装器 (`problems.hpo_wrapper.HPOProblemWrapper`)，即包含此问题的工作流不能被 "
"vmapped。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:78
msgid "Evaluate the fitness of a population (batch) of model parameters."
msgstr "评估一组模型参数种群（批次）的适应度。"

#: ../../../src/evox/problems/neuroevolution/supervised_learning.py:82
msgid ""
"A tensor of shape (batch_size,) containing the fitness of each sample in the"
" population."
msgstr "形状为 (batch_size,) 的张量，包含种群中每个样本的适应度。"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.neuroevolution.utils`"
msgstr "{py:mod}`evox.problems.neuroevolution.utils`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:18
#, python-brace-format
msgid ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"
msgstr ""
"{py:obj}`ModelStateForwardResult "
"<evox.problems.neuroevolution.utils.ModelStateForwardResult>`"

#: ../../source/apidocs/evox/evox.problems.neuroevolution.utils.md:30
#, python-brace-format
msgid ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"
msgstr ""
"{py:obj}`get_vmap_model_state_forward "
"<evox.problems.neuroevolution.utils.get_vmap_model_state_forward>`"

#: ../../../src/evox/problems/neuroevolution/utils.py:32
#: ../../../src/evox/problems/neuroevolution/utils.py:74
msgid ""
"Get model state forward function for vmap and non-vmap models. When "
"`get_non_vmap` is False, the function returns only vmap model state forward "
"function. When `get_non_vmap` is True, the function returns both vmap and "
"non-vmap model state forward functions."
msgstr ""
"获取用于 vmap 和非 vmap 模型的模型状态前向函数。当 `get_non_vmap` 为 False 时，该函数仅返回 vmap "
"模型状态前向函数。当 `get_non_vmap` 为 True 时，该函数返回 vmap 和非 vmap 模型状态前向函数。"

#: ../../source/apidocs/evox/evox.problems.numerical.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.numerical`"
msgstr "{py:mod}`evox.problems.numerical`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:22
#: ../../source/apidocs/evox/evox.problems.numerical.md:29
#, python-brace-format
msgid "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"
msgstr "{py:obj}`Ackley <evox.problems.numerical.basic.Ackley>`"

#: ../../../src/evox/problems/numerical/basic.py:24
#: ../../../src/evox/problems/numerical/basic.py:31
#: ../../../src/evox/problems/numerical/basic.py:121
#: ../../../src/evox/problems/numerical/basic.py:122
msgid "The Ackley function whose minimum is x = [0, ..., 0]"
msgstr "Ackley 函数的最小值为 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:26
#: ../../source/apidocs/evox/evox.problems.numerical.md:33
#, python-brace-format
msgid "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"
msgstr "{py:obj}`Griewank <evox.problems.numerical.basic.Griewank>`"

#: ../../../src/evox/problems/numerical/basic.py:28
#: ../../../src/evox/problems/numerical/basic.py:35
#: ../../../src/evox/problems/numerical/basic.py:145
#: ../../../src/evox/problems/numerical/basic.py:146
msgid "The Griewank function whose minimum is x = [0, ..., 0]"
msgstr "Griewank 函数的最小值是 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.md:37
#, python-brace-format
msgid "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"
msgstr "{py:obj}`Rastrigin <evox.problems.numerical.basic.Rastrigin>`"

#: ../../../src/evox/problems/numerical/basic.py:32
#: ../../../src/evox/problems/numerical/basic.py:39
#: ../../../src/evox/problems/numerical/basic.py:169
#: ../../../src/evox/problems/numerical/basic.py:170
msgid "The Rastrigin function whose minimum is x = [0, ..., 0]"
msgstr "Rastrigin 函数的最小值是 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:34
#: ../../source/apidocs/evox/evox.problems.numerical.md:41
#, python-brace-format
msgid "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"
msgstr "{py:obj}`Rosenbrock <evox.problems.numerical.basic.Rosenbrock>`"

#: ../../../src/evox/problems/numerical/basic.py:36
#: ../../../src/evox/problems/numerical/basic.py:43
#: ../../../src/evox/problems/numerical/basic.py:193
#: ../../../src/evox/problems/numerical/basic.py:194
msgid "The Rosenbrock function whose minimum is x = [1, ..., 1]"
msgstr "Rosenbrock 函数的最小值为 x = [1, ..., 1]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:38
#: ../../source/apidocs/evox/evox.problems.numerical.md:45
#, python-brace-format
msgid "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"
msgstr "{py:obj}`Schwefel <evox.problems.numerical.basic.Schwefel>`"

#: ../../../src/evox/problems/numerical/basic.py:40
#: ../../../src/evox/problems/numerical/basic.py:47
#: ../../../src/evox/problems/numerical/basic.py:217
#: ../../../src/evox/problems/numerical/basic.py:218
msgid "The Schwefel function whose minimum is x = [420.9687, ..., 420.9687]"
msgstr "Schwefel 函数的最小值为 x = [420.9687, ..., 420.9687]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:42
#: ../../source/apidocs/evox/evox.problems.numerical.md:49
#, python-brace-format
msgid "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"
msgstr "{py:obj}`Sphere <evox.problems.numerical.basic.Sphere>`"

#: ../../../src/evox/problems/numerical/basic.py:44
#: ../../../src/evox/problems/numerical/basic.py:51
#: ../../../src/evox/problems/numerical/basic.py:241
#: ../../../src/evox/problems/numerical/basic.py:242
msgid "The sphere function whose minimum is x = [0, ..., 0]"
msgstr "球体函数（sphere function），其最小值为 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:46
#: ../../source/apidocs/evox/evox.problems.numerical.md:53
#, fuzzy, python-brace-format
msgid "{py:obj}`Ellipsoid <evox.problems.numerical.basic.Ellipsoid>`"
msgstr "{py:obj}`Ellipsoid <evox.problems.numerical.basic.Ellipsoid>`"

#: ../../../src/evox/problems/numerical/basic.py:48
#: ../../../src/evox/problems/numerical/basic.py:55
#: ../../../src/evox/problems/numerical/basic.py:265
#: ../../../src/evox/problems/numerical/basic.py:266
msgid "The Ellipsoid function whose minimum is x = [0, ..., 0]"
msgstr "椭球函数，其最小值为 x = [0, ..., 0]"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:18
#: ../../source/apidocs/evox/evox.problems.numerical.md:57
#, python-brace-format
msgid "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"
msgstr "{py:obj}`CEC2022 <evox.problems.numerical.cec2022.CEC2022>`"

#: ../../../src/evox/problems/numerical/cec2022.py:20
#: ../../../src/evox/problems/numerical/cec2022.py:33
#: ../../../src/evox/problems/numerical/cec2022.py:59
#: ../../../src/evox/problems/numerical/cec2022.py:290
msgid "The CEC 2022 single-objective test suite Problem"
msgstr "CEC 2022 单目标测试套件问题"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:22
#: ../../source/apidocs/evox/evox.problems.numerical.md:61
#, python-brace-format
msgid "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"
msgstr "{py:obj}`DTLZ1 <evox.problems.numerical.dtlz.DTLZ1>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:24
#: ../../source/apidocs/evox/evox.problems.numerical.md:63
#, python-brace-format
msgid "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"
msgstr "{py:obj}`DTLZ2 <evox.problems.numerical.dtlz.DTLZ2>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:26
#: ../../source/apidocs/evox/evox.problems.numerical.md:65
#, python-brace-format
msgid "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"
msgstr "{py:obj}`DTLZ3 <evox.problems.numerical.dtlz.DTLZ3>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:28
#: ../../source/apidocs/evox/evox.problems.numerical.md:67
#, python-brace-format
msgid "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"
msgstr "{py:obj}`DTLZ4 <evox.problems.numerical.dtlz.DTLZ4>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:30
#: ../../source/apidocs/evox/evox.problems.numerical.md:69
#, python-brace-format
msgid "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"
msgstr "{py:obj}`DTLZ5 <evox.problems.numerical.dtlz.DTLZ5>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:32
#: ../../source/apidocs/evox/evox.problems.numerical.md:71
#, python-brace-format
msgid "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"
msgstr "{py:obj}`DTLZ6 <evox.problems.numerical.dtlz.DTLZ6>`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:34
#: ../../source/apidocs/evox/evox.problems.numerical.md:73
#, python-brace-format
msgid "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"
msgstr "{py:obj}`DTLZ7 <evox.problems.numerical.dtlz.DTLZ7>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:58
#: ../../source/apidocs/evox/evox.problems.numerical.md:83
#, python-brace-format
msgid "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"
msgstr "{py:obj}`ackley_func <evox.problems.numerical.basic.ackley_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:62
#: ../../source/apidocs/evox/evox.problems.numerical.md:87
#, python-brace-format
msgid "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"
msgstr "{py:obj}`griewank_func <evox.problems.numerical.basic.griewank_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:66
#: ../../source/apidocs/evox/evox.problems.numerical.md:91
#, python-brace-format
msgid ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"
msgstr ""
"{py:obj}`rastrigin_func <evox.problems.numerical.basic.rastrigin_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:70
#: ../../source/apidocs/evox/evox.problems.numerical.md:95
#, python-brace-format
msgid ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"
msgstr ""
"{py:obj}`rosenbrock_func <evox.problems.numerical.basic.rosenbrock_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:74
#: ../../source/apidocs/evox/evox.problems.numerical.md:99
#, python-brace-format
msgid "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"
msgstr "{py:obj}`schwefel_func <evox.problems.numerical.basic.schwefel_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:78
#: ../../source/apidocs/evox/evox.problems.numerical.md:103
#, python-brace-format
msgid "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"
msgstr "{py:obj}`sphere_func <evox.problems.numerical.basic.sphere_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:82
#: ../../source/apidocs/evox/evox.problems.numerical.md:107
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`ellipsoid_func <evox.problems.numerical.basic.ellipsoid_func>`"
msgstr ""
"{py:obj}`ellipsoid_func <evox.problems.numerical.basic.ellipsoid_func>`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:118
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:142
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:166
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:190
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:214
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:238
#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:262
#: ../../source/apidocs/evox/evox.problems.numerical.md:119
#: ../../source/apidocs/evox/evox.problems.numerical.md:143
#: ../../source/apidocs/evox/evox.problems.numerical.md:167
#: ../../source/apidocs/evox/evox.problems.numerical.md:191
#: ../../source/apidocs/evox/evox.problems.numerical.md:215
#: ../../source/apidocs/evox/evox.problems.numerical.md:239
#: ../../source/apidocs/evox/evox.problems.numerical.md:263
#, python-brace-format
msgid ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"
msgstr ""
"Bases: {py:obj}`evox.problems.numerical.basic.ShiftAffineNumericalProblem`"

#: ../../../src/evox/problems/numerical/basic.py:127
#: ../../../src/evox/problems/numerical/basic.py:128
msgid "Initialize the Ackley function with the given parameters."
msgstr "用给定的参数初始化 Ackley 函数。"

#: ../../../src/evox/problems/numerical/basic.py:129
#: ../../../src/evox/problems/numerical/basic.py:130
msgid "The parameter a in the equation. Defaults to 20.0."
msgstr "方程中的参数a。默认值为20.0。"

#: ../../../src/evox/problems/numerical/basic.py:130
#: ../../../src/evox/problems/numerical/basic.py:131
msgid "The parameter b in the equation. Defaults to 0.2."
msgstr "方程中的参数 b。默认值为 0.2。"

#: ../../../src/evox/problems/numerical/basic.py:131
#: ../../../src/evox/problems/numerical/basic.py:132
msgid "The parameter c in the equation. Defaults to 2 * pi."
msgstr "方程中的参数c。默认值为2 * pi。"

#: ../../../src/evox/problems/numerical/basic.py:132
#: ../../../src/evox/problems/numerical/basic.py:133
#: ../../../src/evox/problems/numerical/basic.py:153
#: ../../../src/evox/problems/numerical/basic.py:154
#: ../../../src/evox/problems/numerical/basic.py:177
#: ../../../src/evox/problems/numerical/basic.py:178
#: ../../../src/evox/problems/numerical/basic.py:201
#: ../../../src/evox/problems/numerical/basic.py:202
#: ../../../src/evox/problems/numerical/basic.py:225
#: ../../../src/evox/problems/numerical/basic.py:226
#: ../../../src/evox/problems/numerical/basic.py:249
#: ../../../src/evox/problems/numerical/basic.py:250
#: ../../../src/evox/problems/numerical/basic.py:273
#: ../../../src/evox/problems/numerical/basic.py:274
msgid ""
"The keyword arguments (shift and affine) to pass to the superclass "
"ShiftAffineNumericalProblem."
msgstr "传递给超类 ShiftAffineNumericalProblem 的关键字参数（shift 和 affine）。"

#: ../../../src/evox/problems/numerical/basic.py:151
#: ../../../src/evox/problems/numerical/basic.py:152
#: ../../../src/evox/problems/numerical/basic.py:175
#: ../../../src/evox/problems/numerical/basic.py:176
#: ../../../src/evox/problems/numerical/basic.py:199
#: ../../../src/evox/problems/numerical/basic.py:200
#: ../../../src/evox/problems/numerical/basic.py:223
#: ../../../src/evox/problems/numerical/basic.py:224
#: ../../../src/evox/problems/numerical/basic.py:247
#: ../../../src/evox/problems/numerical/basic.py:248
msgid "Initialize the Griewank function with the given parameters."
msgstr "用给定的参数初始化 Griewank 函数。"

#: ../../../src/evox/problems/numerical/basic.py:271
#: ../../../src/evox/problems/numerical/basic.py:272
msgid "Initialize the Ellipsoid function with the given parameters."
msgstr "使用给定参数初始化 Ellipsoid 函数。"

#: ../../../src/evox/problems/numerical/cec2022.py:39
#: ../../../src/evox/problems/numerical/cec2022.py:296
msgid ""
"Initialize a single test function instance from the CEC2022 test suite."
msgstr "从CEC2022测试套件初始化一个单一测试函数实例。"

#: ../../../src/evox/problems/numerical/cec2022.py:41
#: ../../../src/evox/problems/numerical/cec2022.py:298
msgid ""
"The index for the specific test function to be used. Must be ranged from 1 "
"to 12."
msgstr "特定测试函数的索引。必须在1到12之间。"

#: ../../../src/evox/problems/numerical/cec2022.py:42
#: ../../../src/evox/problems/numerical/cec2022.py:299
msgid "The dimensionality of the problem. Must be one of [2, 10, 20]."
msgstr "问题的维度。必须是 [2, 10, 20] 之一。"

#: ../../../src/evox/problems/numerical/cec2022.py:43
#: ../../../src/evox/problems/numerical/cec2022.py:300
msgid "The device on which tensors will be allocated. Defaults to None."
msgstr "张量将被分配的设备。默认值为 None。"

#: ../../../src/evox/problems/numerical/cec2022.py:45
#: ../../../src/evox/problems/numerical/cec2022.py:302
msgid ""
"If the dimension is not one of the allowed values or if the function is not "
"defined."
msgstr "如果维度不是允许的值之一，或者函数未定义。"

#: ../../../src/evox/problems/numerical/cec2022.py:46
#: ../../../src/evox/problems/numerical/cec2022.py:303
msgid "If the necessary data files for the problem are not found."
msgstr "如果未找到该问题所需的数据文件。"

#: ../../../src/evox/problems/numerical/cec2022.py:46
#: ../../../src/evox/problems/numerical/cec2022.py:303
msgid "Shift the input vector."
msgstr "将输入向量移位。"

#: ../../../src/evox/problems/numerical/cec2022.py:54
#: ../../../src/evox/problems/numerical/cec2022.py:311
msgid "Rotate the input vector."
msgstr "旋转输入向量。"

#: ../../../src/evox/problems/numerical/cec2022.py:70
#: ../../../src/evox/problems/numerical/cec2022.py:327
msgid "Shift and rotate function with rate."
msgstr "平移和旋转函数与速率。"

#: ../../../src/evox/problems/numerical/cec2022.py:86
#: ../../../src/evox/problems/numerical/cec2022.py:343
msgid "Zakharov Function"
msgstr "Zakharov 函数"

#: ../../../src/evox/problems/numerical/cec2022.py:94
#: ../../../src/evox/problems/numerical/cec2022.py:351
msgid "Rosenbrock Function"
msgstr "Rosenbrock Function  \n"

#: ../../../src/evox/problems/numerical/cec2022.py:102
#: ../../../src/evox/problems/numerical/cec2022.py:359
msgid "Schaffer F7 Function"
msgstr "Schaffer F7 函数"

#: ../../../src/evox/problems/numerical/cec2022.py:110
#: ../../../src/evox/problems/numerical/cec2022.py:367
msgid "Step Rastrigin Function (Noncontinuous Rastrigin's)"
msgstr "Rastrigin 函数步骤（不连续的 Rastrigin's）"

#: ../../../src/evox/problems/numerical/cec2022.py:118
#: ../../../src/evox/problems/numerical/cec2022.py:375
msgid "Levy Function"
msgstr ""
"Levy Function  \n"
"Levy Function"

#: ../../../src/evox/problems/numerical/cec2022.py:126
#: ../../../src/evox/problems/numerical/cec2022.py:383
msgid "Hybrid Function 2"
msgstr "混合函数2"

#: ../../../src/evox/problems/numerical/cec2022.py:134
#: ../../../src/evox/problems/numerical/cec2022.py:391
msgid "Hybrid Function 10"
msgstr "混合函数 10"

#: ../../../src/evox/problems/numerical/cec2022.py:142
#: ../../../src/evox/problems/numerical/cec2022.py:399
msgid "Hybrid Function 6"
msgstr "混合函数6"

#: ../../../src/evox/problems/numerical/cec2022.py:150
#: ../../../src/evox/problems/numerical/cec2022.py:407
msgid "Composition Function 1"
msgstr "Composition Function 1"

#: ../../../src/evox/problems/numerical/cec2022.py:158
#: ../../../src/evox/problems/numerical/cec2022.py:415
msgid "Composition Function 2"
msgstr "Composition Function 2"

#: ../../../src/evox/problems/numerical/cec2022.py:166
#: ../../../src/evox/problems/numerical/cec2022.py:423
msgid "Composition Function 6"
msgstr "Composition Function 6"

#: ../../../src/evox/problems/numerical/cec2022.py:174
#: ../../../src/evox/problems/numerical/cec2022.py:431
msgid "Composition Function 7"
msgstr "Composition Function 7"

#: ../../../src/evox/problems/numerical/cec2022.py:182
#: ../../../src/evox/problems/numerical/cec2022.py:439
msgid "Problem number = 1."
msgstr "问题编号 = 1。"

#: ../../../src/evox/problems/numerical/cec2022.py:190
#: ../../../src/evox/problems/numerical/cec2022.py:447
msgid "Problem number = 4."
msgstr "问题编号 = 4。"

#: ../../../src/evox/problems/numerical/cec2022.py:198
#: ../../../src/evox/problems/numerical/cec2022.py:455
msgid "Problem number = 5."
msgstr "问题编号 = 5。"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:77
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:89
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:130
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:147
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:164
#: ../../source/apidocs/evox/evox.problems.numerical.md:580
#: ../../source/apidocs/evox/evox.problems.numerical.md:592
#: ../../source/apidocs/evox/evox.problems.numerical.md:633
#: ../../source/apidocs/evox/evox.problems.numerical.md:650
#: ../../source/apidocs/evox/evox.problems.numerical.md:667
#, fuzzy, python-brace-format
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ`"
msgstr "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:106
#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:118
#: ../../source/apidocs/evox/evox.problems.numerical.md:609
#: ../../source/apidocs/evox/evox.problems.numerical.md:621
#, python-brace-format
msgid "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"
msgstr "Bases: {py:obj}`evox.problems.numerical.dtlz.DTLZ2`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.numerical.basic`"
msgstr "{py:mod}`evox.problems.numerical.basic`"

#: ../../source/apidocs/evox/evox.problems.numerical.basic.md:18
#, python-brace-format
msgid ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"
msgstr ""
"{py:obj}`ShiftAffineNumericalProblem "
"<evox.problems.numerical.basic.ShiftAffineNumericalProblem>`"

#: ../../../src/evox/problems/numerical/basic.py:20
#: ../../../src/evox/problems/numerical/basic.py:97
msgid ""
"A numerical problem with a shift and affine transformations to the input "
"points."
msgstr "一个数值问题，包含对输入点的平移和仿射变换。"

#: ../../../src/evox/problems/numerical/basic.py:103
msgid "Initialize the ShiftAffineNumericalProblem."
msgstr "初始化 ShiftAffineNumericalProblem。"

#: ../../../src/evox/problems/numerical/basic.py:105
msgid "The shift vector. Defaults to None. None represents no shift."
msgstr "偏移向量。默认为 None。None 表示没有偏移。"

#: ../../../src/evox/problems/numerical/basic.py:106
msgid ""
"The affine transformation matrix. Defaults to None. None represents no "
"affine transformation."
msgstr "仿射变换矩阵。默认为 None。None 表示没有仿射变换。"

#: ../../../src/evox/problems/numerical/basic.py:110
msgid ""
"Evaluate the given population by shifting and applying an affine "
"transformation to the input points first, and then evaluating the points "
"with the actual function."
msgstr "首先对给定的种群进行平移和仿射变换，然后用实际函数评估这些点。"

#: ../../../src/evox/problems/numerical/basic.py:112
msgid "The population of points to evaluate."
msgstr "要评估的点的种群。"

#: ../../../src/evox/problems/numerical/basic.py:114
msgid "The evaluated fitness of the population."
msgstr "种群的适应度评估结果。"

#: ../../source/apidocs/evox/evox.problems.numerical.cec2022.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.numerical.cec2022`"
msgstr "{py:mod}`evox.problems.numerical.cec2022`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:1
#, python-brace-format
msgid "{py:mod}`evox.problems.numerical.dtlz`"
msgstr "{py:mod}`evox.problems.numerical.dtlz`"

#: ../../source/apidocs/evox/evox.problems.numerical.dtlz.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`DTLZ <evox.problems.numerical.dtlz.DTLZ>`"
msgstr "{py:obj}`DTLZ <evox.problems.numerical.dtlz.DTLZ>`"

#: ../../../src/evox/problems/numerical/dtlz.py:20
#: ../../../src/evox/problems/numerical/dtlz.py:47
msgid ""
"Base class for DTLZ test suite problems in multi-objective optimization."
msgstr "用于多目标优化中DTLZ测试套件问题的基类。"

#: ../../../src/evox/problems/numerical/dtlz.py:49
msgid "Inherit this class to implement specific DTLZ problem variants."
msgstr "继承此类以实现特定的DTLZ问题变体。"

#: ../../../src/evox/problems/numerical/dtlz.py:51
msgid "Number of decision variables."
msgstr "决策变量的数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:52
msgid "Number of objectives."
msgstr "目标数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:53
msgid "Number of reference points used in the problem."
msgstr "问题中使用的参考点数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:53
msgid "Override the setup method to initialize the parameters"
msgstr "重写 `setup` 方法以初始化参数。"

#: ../../../src/evox/problems/numerical/dtlz.py:61
msgid ""
"Abstract method to evaluate the objective values for given decision "
"variables."
msgstr "抽象方法用于评估给定决策变量的目标值。"

#: ../../../src/evox/problems/numerical/dtlz.py:63
msgid ""
"A tensor of shape (n, d), where n is the number of solutions and d is the "
"number of decision variables."
msgstr "形状为 (n, d) 的张量，其中 n 是解的数量，d 是决策变量的数量。"

#: ../../../src/evox/problems/numerical/dtlz.py:69
msgid "Return the Pareto front for the problem."
msgstr "返回问题的帕累托前沿。"

#: ../../../src/evox/problems/numerical/dtlz.py:71
msgid "A tensor representing the Pareto front."
msgstr "表示帕累托前沿的张量。"

#: ../../source/apidocs/evox/evox.utils.md:1
#, python-brace-format
msgid "{py:mod}`evox.utils`"
msgstr "{py:mod}`evox.utils`"

#: ../../source/apidocs/evox/evox.utils.md:30
#, python-brace-format
msgid "{py:obj}`__all__ <evox.utils.__all__>`"
msgstr "{py:obj}`__all__ <evox.utils.__all__>`"

#: ../../source/apidocs/evox/evox.utils.md:42
msgid ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."
msgstr ""
"['switch', 'clamp', 'clamp_int', 'clamp_float', 'clip', 'maximum', "
"'minimum', 'maximum_float', 'mini..."

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:1
#, python-brace-format
msgid "{py:mod}`evox.utils.jit_fix_operator`"
msgstr "{py:mod}`evox.utils.jit_fix_operator`"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:18
#, python-brace-format
msgid "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"
msgstr "{py:obj}`switch <evox.utils.jit_fix_operator.switch>`"

#: ../../../src/evox/utils/jit_fix_operator.py:20
#: ../../../src/evox/utils/jit_fix_operator.py:86
msgid ""
"Element-wise switch select operator that generates a tensor from a list of "
"tensors based on the label tensor."
msgstr "基于标签张量从张量列表中生成张量的逐元素切换选择运算符。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:22
#, python-brace-format
msgid "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"
msgstr "{py:obj}`clamp <evox.utils.jit_fix_operator.clamp>`"

#: ../../../src/evox/utils/jit_fix_operator.py:24
#: ../../../src/evox/utils/jit_fix_operator.py:93
msgid ""
"Clamp the values of the input tensor `a` to be within the given lower (`lb`)"
" and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的值限制在给定的下界 (`lb`) 和上界 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:26
#, python-brace-format
msgid "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"
msgstr "{py:obj}`clamp_float <evox.utils.jit_fix_operator.clamp_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:28
#: ../../../src/evox/utils/jit_fix_operator.py:100
msgid ""
"Clamp the float values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的浮点值限制在给定的下界 (`lb`) 和上界 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:30
#, python-brace-format
msgid "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"
msgstr "{py:obj}`clamp_int <evox.utils.jit_fix_operator.clamp_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:32
#: ../../../src/evox/utils/jit_fix_operator.py:107
msgid ""
"Clamp the int values of the input tensor `a` to be within the given lower "
"(`lb`) and upper (`ub`) bounds."
msgstr "将输入张量 `a` 的整数值限制在给定的下限 (`lb`) 和上限 (`ub`) 之间。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:34
#, python-brace-format
msgid "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"
msgstr "{py:obj}`clip <evox.utils.jit_fix_operator.clip>`"

#: ../../../src/evox/utils/jit_fix_operator.py:36
#: ../../../src/evox/utils/jit_fix_operator.py:114
msgid "Clip the values of the input tensor `a` to be within the range [0, 1]."
msgstr "将输入张量 `a` 的值裁剪到 [0, 1] 范围内。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:38
#, python-brace-format
msgid "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"
msgstr "{py:obj}`maximum <evox.utils.jit_fix_operator.maximum>`"

#: ../../../src/evox/utils/jit_fix_operator.py:40
#: ../../../src/evox/utils/jit_fix_operator.py:121
msgid "Element-wise maximum of two input tensors `a` and `b`."
msgstr "两个输入张量 `a` 和 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:42
#, python-brace-format
msgid "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"
msgstr "{py:obj}`minimum <evox.utils.jit_fix_operator.minimum>`"

#: ../../../src/evox/utils/jit_fix_operator.py:44
#: ../../../src/evox/utils/jit_fix_operator.py:128
msgid "Element-wise minimum of two input tensors `a` and `b`."
msgstr "两个输入张量 `a` 和 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:46
#, python-brace-format
msgid "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"
msgstr "{py:obj}`maximum_float <evox.utils.jit_fix_operator.maximum_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:48
#: ../../../src/evox/utils/jit_fix_operator.py:135
msgid "Element-wise maximum of input tensor `a` and float `b`."
msgstr "输入张量 `a` 和浮点数 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:50
#, python-brace-format
msgid "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"
msgstr "{py:obj}`minimum_float <evox.utils.jit_fix_operator.minimum_float>`"

#: ../../../src/evox/utils/jit_fix_operator.py:52
#: ../../../src/evox/utils/jit_fix_operator.py:142
msgid "Element-wise minimum of input tensor `a` and float `b`."
msgstr "输入张量 `a` 和浮点数 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:54
#, python-brace-format
msgid "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"
msgstr "{py:obj}`maximum_int <evox.utils.jit_fix_operator.maximum_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:56
#: ../../../src/evox/utils/jit_fix_operator.py:149
msgid "Element-wise maximum of input tensor `a` and int `b`."
msgstr "输入张量 `a` 和整数 `b` 的逐元素最大值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:58
#, python-brace-format
msgid "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"
msgstr "{py:obj}`minimum_int <evox.utils.jit_fix_operator.minimum_int>`"

#: ../../../src/evox/utils/jit_fix_operator.py:60
#: ../../../src/evox/utils/jit_fix_operator.py:156
msgid "Element-wise minimum of input tensor `a` and int `b`."
msgstr "输入张量 `a` 和整数 `b` 的逐元素最小值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:62
#, python-brace-format
msgid "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"
msgstr "{py:obj}`lexsort <evox.utils.jit_fix_operator.lexsort>`"

#: ../../../src/evox/utils/jit_fix_operator.py:64
#: ../../../src/evox/utils/jit_fix_operator.py:163
msgid ""
"Perform lexicographical sorting of multiple tensors, considering each tensor"
" as a key."
msgstr "对多个张量进行字典序排序，将每个张量视为一个键。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:66
#, python-brace-format
msgid "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"
msgstr "{py:obj}`nanmin <evox.utils.jit_fix_operator.nanmin>`"

#: ../../../src/evox/utils/jit_fix_operator.py:68
#: ../../../src/evox/utils/jit_fix_operator.py:170
msgid ""
"Compute the minimum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr "计算张量在指定维度上的最小值，忽略NaN值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:70
#, python-brace-format
msgid "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"
msgstr "{py:obj}`nanmax <evox.utils.jit_fix_operator.nanmax>`"

#: ../../../src/evox/utils/jit_fix_operator.py:72
#: ../../../src/evox/utils/jit_fix_operator.py:177
msgid ""
"Compute the maximum of a tensor along a specified dimension, ignoring NaN "
"values."
msgstr "计算张量在指定维度上的最大值，忽略NaN值。"

#: ../../source/apidocs/evox/evox.utils.jit_fix_operator.md:74
#, fuzzy, python-brace-format
msgid "{py:obj}`randint <evox.utils.jit_fix_operator.randint>`"
msgstr "{py:obj}`randint <evox.utils.jit_fix_operator.randint>`"

#: ../../../src/evox/utils/jit_fix_operator.py:76
#: ../../../src/evox/utils/jit_fix_operator.py:184
msgid ""
"Randomly generate a tensor of integers within a specified range like "
"`torch.randint`. However, the low and high values are now tensors."
msgstr "随机生成一个整数张量，范围由指定的低值和高值张量决定，类似于 `torch.randint`。然而，现在低值和高值是张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:88
msgid ""
"A tensor containing labels used to select from the list of tensors. Must be "
"broadcastable to the shape of rest arguments."
msgstr "一个张量，包含用于从张量列表中选择的标签。必须可以广播到其余参数的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:89
msgid ""
"A list of tensors from which one is selected based on the label. All tensors"
" in the list must be broadcastable to the same shape."
msgstr "根据标签从中选择的张量列表。列表中的所有张量必须可以广播到相同的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:92
msgid ""
"A tensor where each element is selected from the list of tensors based on "
"the corresponding element in the label tensor."
msgstr "一个张量，其中每个元素都是根据标签张量中的相应元素从张量列表中选择的。"

#: ../../../src/evox/utils/jit_fix_operator.py:95
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"the corresponding element of `lb` and not greater than the corresponding "
"element of `ub`."
msgstr "此函数确保张量 `a` 的每个元素不小于 `lb` 的相应元素且不大于 `ub` 的相应元素。"

#: ../../../src/evox/utils/jit_fix_operator.py:99
#: ../../../src/evox/utils/jit_fix_operator.py:105
#: ../../../src/evox/utils/jit_fix_operator.py:112
msgid ""
"This is a fix function for "
"[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html) "
"since it is not supported in JIT operator fusion yet."
msgstr ""
"这是一个修复函数，适用于[`torch.clamp`](https://pytorch.org/docs/stable/generated/torch.clamp.html)，因为它尚未在JIT操作符融合中支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:101
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a`, `lb` or `ub` is a"
" float tensor and may suffer from numerical precision losses. Please use "
"`torch.clamp` instead if a precise clamp is required."
msgstr ""
"这不是`torch.clamp`的精确复制，如果`a`、`lb`或`ub`是浮点张量，可能会遭受数值精度损失。如果需要精确的限制，请使用`torch.clamp"

#: ../../../src/evox/utils/jit_fix_operator.py:103
#: ../../../src/evox/utils/jit_fix_operator.py:109
#: ../../../src/evox/utils/jit_fix_operator.py:116
msgid "The input tensor to be clamped."
msgstr "要被限制的输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:104
msgid "The lower bound tensor. Must be broadcastable to the shape of a."
msgstr "下界张量。必须可以广播到 a 的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:105
msgid "The upper bound tensor. Must be broadcastable to the shape of a."
msgstr "上界张量。必须可以广播到a的形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:107
#: ../../../src/evox/utils/jit_fix_operator.py:113
#: ../../../src/evox/utils/jit_fix_operator.py:120
msgid ""
"A tensor where each element is clamped to be within the specified bounds."
msgstr "张量，其中每个元素都被限制在指定的界限内。"

#: ../../../src/evox/utils/jit_fix_operator.py:102
#: ../../../src/evox/utils/jit_fix_operator.py:109
msgid ""
"This function ensures that each element of the tensor `a` is not less than "
"`lb` and not greater than `ub`."
msgstr "此函数确保张量 `a` 的每个元素不小于 `lb` 且不大于 `ub"

#: ../../../src/evox/utils/jit_fix_operator.py:107
#: ../../../src/evox/utils/jit_fix_operator.py:114
msgid ""
"This is NOT a precise replication of `torch.clamp` if `a` is a float tensor "
"and may suffer from numerical precision losses. Please use `torch.clamp` "
"instead if a precise clamp is required."
msgstr ""
"这不是`torch.clamp`的精确复制，如果`a`是浮点张量，可能会遭受数值精度损失。如果需要精确的限制，请使用`torch.clamp"

#: ../../../src/evox/utils/jit_fix_operator.py:110
#: ../../../src/evox/utils/jit_fix_operator.py:117
msgid ""
"The lower bound value. Each element of a will be clamped to be not less than"
" lb."
msgstr "下界值。a 的每个元素将被限制为不小于 lb。"

#: ../../../src/evox/utils/jit_fix_operator.py:111
#: ../../../src/evox/utils/jit_fix_operator.py:118
msgid ""
"The upper bound value. Each element of a will be clamped to be not greater "
"than ub."
msgstr "上限值。a 的每个元素将被限制为不大于 ub。"

#: ../../../src/evox/utils/jit_fix_operator.py:116
msgid "Notice: This function invokes `clamp(a, 0, 1)`."
msgstr "注意：此函数调用 `clamp(a, 0, 1)"

#: ../../../src/evox/utils/jit_fix_operator.py:118
msgid "The input tensor to be clipped."
msgstr "要裁剪的输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:120
msgid "A tensor where each element is clipped to be within [0, 1]."
msgstr "一个张量，其中每个元素都被限制在 [0, 1] 范围内。"

#: ../../../src/evox/utils/jit_fix_operator.py:124
#: ../../../src/evox/utils/jit_fix_operator.py:138
#: ../../../src/evox/utils/jit_fix_operator.py:152
msgid ""
"This is a fix function for "
"[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html]"
" since it is not supported in JIT operator fusion yet."
msgstr ""
"这是一个修复函数，用于[`torch.maximum`](https://pytorch.org/docs/stable/generated/torch.maximum.html)，因为它在JIT操作符融合中尚不支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:126
msgid ""
"This is NOT a precise replication of `torch.maximum` if `a` or `b` is a "
"float tensor and may suffer from numerical precision losses. Please use "
"`torch.maximum` instead if a precise maximum is required."
msgstr ""
"这并不是对 `torch.maximum` 的精确复现，如果 `a` 或 `b` 是浮点张量，可能会存在数值精度损失。如果需要精确的最大值，请使用 "
"`torch.maximum`。"

#: ../../../src/evox/utils/jit_fix_operator.py:128
#: ../../../src/evox/utils/jit_fix_operator.py:135
#: ../../../src/evox/utils/jit_fix_operator.py:142
#: ../../../src/evox/utils/jit_fix_operator.py:149
#: ../../../src/evox/utils/jit_fix_operator.py:156
#: ../../../src/evox/utils/jit_fix_operator.py:163
msgid "The first input tensor."
msgstr "第一个输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:129
#: ../../../src/evox/utils/jit_fix_operator.py:136
msgid "The second input tensor."
msgstr "第二个输入张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:131
#: ../../../src/evox/utils/jit_fix_operator.py:145
#: ../../../src/evox/utils/jit_fix_operator.py:159
msgid "The element-wise maximum of a and b."
msgstr "a 和 b 的逐元素最大值。"

#: ../../../src/evox/utils/jit_fix_operator.py:131
#: ../../../src/evox/utils/jit_fix_operator.py:145
#: ../../../src/evox/utils/jit_fix_operator.py:159
msgid ""
"This is a fix function for "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html]"
" since it is not supported in JIT operator fusion yet."
msgstr ""
"这是一个用于 "
"[`torch.minimum`](https://pytorch.org/docs/stable/generated/torch.minimum.html)"
" 的修正功能，因为它目前尚未在 JIT 操作符融合中得到支持。"

#: ../../../src/evox/utils/jit_fix_operator.py:133
msgid ""
"This is NOT a precise replication of `torch.minimum` if `a` or `b` is a "
"float tensor and may suffer from numerical precision losses. Please use "
"`torch.minimum` instead if a precise minimum is required."
msgstr ""
"这并不是 `torch.minimum` 的精确复制，如果 `a` 或 `b` 是浮点张量，可能会受到数值精度损失的影响。如果需要精确的最小值，请使用 "
"`torch.minimum`。"

#: ../../../src/evox/utils/jit_fix_operator.py:138
#: ../../../src/evox/utils/jit_fix_operator.py:152
#: ../../../src/evox/utils/jit_fix_operator.py:166
msgid "The element-wise minimum of a and b."
msgstr "a 和 b 的元素级最小值。"

#: ../../../src/evox/utils/jit_fix_operator.py:140
#: ../../../src/evox/utils/jit_fix_operator.py:154
msgid ""
"This is NOT a precise replication of `torch.maximum` if `a` is a float "
"tensor and may suffer from numerical precision losses. Please use "
"`torch.maximum` instead if a precise maximum is required."
msgstr ""
"这不是 `torch.maximum` 的精确复制，如果 `a` 是一个浮点张量，可能会受到数值精度损失的影响。如果需要精确的最大值，请使用 "
"`torch.maximum`。"

#: ../../../src/evox/utils/jit_fix_operator.py:143
#: ../../../src/evox/utils/jit_fix_operator.py:150
msgid "The second input float, which is a scalar value."
msgstr "第二个输入是一个浮点数，它是一个标量值。"

#: ../../../src/evox/utils/jit_fix_operator.py:147
#: ../../../src/evox/utils/jit_fix_operator.py:161
msgid ""
"This is NOT a precise replication of `torch.minimum` if `a` is a float "
"tensor and may suffer from numerical precision losses. Please use "
"`torch.minimum` instead if a precise minimum is required."
msgstr ""
"这并不是对 `torch.minimum` 的精确复制，如果 `a` 是一个浮点张量，可能会出现数值精度损失。如果需要精确的最小值，请使用 "
"`torch.minimum`。"

#: ../../../src/evox/utils/jit_fix_operator.py:157
#: ../../../src/evox/utils/jit_fix_operator.py:164
msgid "The second input int, which is a scalar value."
msgstr "第二个输入是一个整数，它是一个标量值。"

#: ../../../src/evox/utils/jit_fix_operator.py:165
msgid ""
"This function sorts the given tensors lexicographically, where sorting is "
"performed by the first key, then by the second key in case of ties in the "
"first key, and so on. It works similarly to NumPy's `lexsort`, but is "
"designed for PyTorch tensors."
msgstr ""
"此函数按字典顺序对给定的张量进行排序，首先按第一个键排序，如果第一个键相同，则按第二个键排序，依此类推。它的工作方式类似于NumPy的`lexsort`，但专为PyTorch张量设计。"

#: ../../../src/evox/utils/jit_fix_operator.py:169
msgid ""
"A list of tensors to be sorted, where each tensor represents a sorting key. "
"All tensors must have the same length along the specified dimension (dim)."
msgstr "要排序的张量列表，其中每个张量代表一个排序键。所有张量在指定维度（dim）上必须具有相同的长度。"

#: ../../../src/evox/utils/jit_fix_operator.py:172
msgid ""
"The dimension along which to perform the sorting. Defaults to -1 (the last "
"dimension)."
msgstr "执行排序的维度。默认为 -1（最后一个维度）。"

#: ../../../src/evox/utils/jit_fix_operator.py:174
msgid ""
"A tensor containing indices that will sort the input tensors "
"lexicographically. These indices indicate the order of elements in the "
"sorted tensors."
msgstr "一个张量，包含按字典顺序对输入张量进行排序的索引。这些索引指示排序后张量中元素的顺序。"

#: ../../../src/evox/utils/jit_fix_operator.py:187
msgid "You can use `torch.unbind` to split the tensor into list."
msgstr "您可以使用 `torch.unbind` 将张量拆分为列表。"

#: ../../../src/evox/utils/jit_fix_operator.py:172
msgid ""
"This function replaces `NaN` values in the input tensor with `infinity` , "
"and then computes the minimum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr "此函数将输入张量中的 `NaN` 值替换为 `infinity`，然后在指定维度上计算最小值，有效地忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:175
#: ../../../src/evox/utils/jit_fix_operator.py:182
msgid ""
"The input tensor, which may contain NaN values. It can be of any shape."
msgstr "输入张量，可能包含NaN值。它可以是任何形状。"

#: ../../../src/evox/utils/jit_fix_operator.py:177
msgid ""
"The dimension along which to compute the minimum. Default is -1, which "
"corresponds to the last dimension."
msgstr "计算最小值的维度。默认值为-1，对应于最后一个维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:179
#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"Whether to retain the reduced dimension in the result. Default is False. If "
"True, the output tensor will have the same number of dimensions as the "
"input, with the size of the reduced dimension set to 1."
msgstr "是否在结果中保留减少的维度。默认值为 False。如果为 True，输出张量将与输入具有相同数量的维度，减少的维度大小将设置为 1。"

#: ../../../src/evox/utils/jit_fix_operator.py:183
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" minimum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the minimum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""
"一个命名元组，包含两个字段：values (torch.Tensor)：一个张量，包含沿指定维度计算的最小值，忽略NaN值。indices "
"(torch.Tensor)：一个张量，包含沿指定维度的最小值的索引。返回的张量values和indices将与输入张量具有相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:183
#: ../../../src/evox/utils/jit_fix_operator.py:190
msgid "A named tuple with two fields:"
msgstr "一个具有两个字段的命名元组："

#: ../../../src/evox/utils/jit_fix_operator.py:184
msgid ""
"`values` (`torch.Tensor`): A tensor containing the minimum values computed "
"along the specified dimension,   ignoring `NaN` values."
msgstr "`values` (`torch.Tensor`): 一个张量，包含沿指定维度计算的最小值，忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the minimum "
"values along the specified dimension."
msgstr "`indices` (`torch.Tensor`): 一个张量，包含沿指定维度的最小值的索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:188
#: ../../../src/evox/utils/jit_fix_operator.py:195
msgid ""
"The returned tensors `values` and `indices` will have the same shape as the "
"input tensor, except for the dimension(s) over which the operation was "
"performed."
msgstr "返回的张量 `values` 和 `indices` 将具有与输入张量相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:199
msgid ""
"`NaN` values are ignored by replacing them with `infinity` before computing "
"the minimum."
msgstr "在计算最小值之前，通过将 `NaN` 值替换为 `infinity` 来忽略它们。"

#: ../../../src/evox/utils/jit_fix_operator.py:200
msgid ""
"If all values along a dimension are `NaN`, the result will be `infinity` for"
" that dimension, and the index will be returned as the first valid index."
msgstr "如果一个维度上的所有值都是`NaN`，那么该维度的结果将是`infinity`，并且索引将返回为第一个有效索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:179
msgid ""
"This function replaces `NaN` values in the input tensor with `-infinity`, "
"and then computes the maximum over the specified dimension, effectively "
"ignoring `NaN` values."
msgstr "此函数将输入张量中的 `NaN` 值替换为 `-infinity`，然后在指定维度上计算最大值，从而有效地忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:184
msgid ""
"The dimension along which to compute the maximum. Default is -1, which "
"corresponds to the last dimension."
msgstr "计算最大值的维度。默认值是 -1，对应于最后一个维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:190
msgid ""
"A named tuple with two fields:values (torch.Tensor): A tensor containing the"
" maximum values computed along the specified dimension, ignoring NaN values."
"  indices (torch.Tensor): A tensor containing the indices of the maximum "
"values along the specified dimension.The returned tensors values and indices"
" will have the same shape as the input tensor, except for the dimension(s) "
"over which the operation was performed."
msgstr ""
"一个命名元组，包含两个字段：values (torch.Tensor)：一个张量，包含沿指定维度计算的最大值，忽略 NaN 值。indices "
"(torch.Tensor)：一个张量，包含沿指定维度的最大值的索引。返回的张量 values 和 indices "
"将与输入张量具有相同的形状，除了执行操作的维度。"

#: ../../../src/evox/utils/jit_fix_operator.py:191
msgid ""
"`values` (`torch.Tensor`): A tensor containing the maximum values computed "
"along the specified dimension,     ignoring `NaN` values."
msgstr "`values` (`torch.Tensor`): 一个张量，包含沿指定维度计算的最大值，忽略 `NaN` 值。"

#: ../../../src/evox/utils/jit_fix_operator.py:193
msgid ""
"`indices` (`torch.Tensor`): A tensor containing the indices of the maximum "
"values along the specified dimension."
msgstr "`indices` (`torch.Tensor`): 一个张量，包含沿指定维度的最大值的索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:206
msgid ""
"`NaN` values are ignored by replacing them with `-infinity` before computing"
" the maximum."
msgstr "在计算最大值之前，通过将 `NaN` 值替换为 `-infinity` 来忽略它们。"

#: ../../../src/evox/utils/jit_fix_operator.py:207
msgid ""
"If all values along a dimension are `NaN`, the result will be `-infinity` "
"for that dimension, and the index will be returned as the first valid index."
msgstr "如果一个维度上的所有值都是`NaN`，那么该维度的结果将是`-infinity`，并且索引将返回为第一个有效索引。"

#: ../../../src/evox/utils/jit_fix_operator.py:186
msgid ""
"This function first generate a uniform random tensor of floats with range "
"[0, 1), and then adjust the range with given low and high values."
msgstr "此函数首先生成一个范围为 [0, 1) 的均匀随机浮点张量，然后使用提供的低值和高值调整范围。"

#: ../../../src/evox/utils/jit_fix_operator.py:188
msgid "The input lower bound tensor (inclusive) or int. It must be a scalar."
msgstr "输入的下界张量（包含）或整数。必须是标量。"

#: ../../../src/evox/utils/jit_fix_operator.py:189
msgid "The input upper bound tensor (exclusive) or int. It must be a scalar."
msgstr "输入为上界张量（不包含上界）或整数。必须是标量。"

#: ../../../src/evox/utils/jit_fix_operator.py:190
msgid "The desired size of the output tensor."
msgstr "输出张量的目标大小。"

#: ../../../src/evox/utils/jit_fix_operator.py:191
msgid ""
"The desired data type of the output tensor. Default None means the same as "
"low or high."
msgstr "输出张量所需的数据类型。默认值为 None，表示与 low 或 high 相同。"

#: ../../../src/evox/utils/jit_fix_operator.py:192
msgid ""
"The desired device for the output tensor. Default None means the same as low"
" or high."
msgstr "输出张量的目标设备。默认值 None 表示与 low 或 high 相同。"

#: ../../../src/evox/utils/jit_fix_operator.py:193
msgid "The random number generator to use. Default is None."
msgstr "要使用的随机数生成器。默认值为 None。"

#: ../../../src/evox/utils/jit_fix_operator.py:195
msgid "A random tensor of integers within the specified range of given size."
msgstr "在指定范围内并具有给定大小的随机整数张量。"

#: ../../../src/evox/utils/jit_fix_operator.py:204
msgid ""
"When used with `torch.compile` and the the `low`, `high` or `size` can be "
"dynamic integers (e.g. size of another tensor), this function **MUST** be "
"used with `torch.compile(..., dynamic=False)`."
msgstr ""
"当与 `torch.compile` 一起使用，并且 `low`、`high` 或 `size` "
"可以是动态整数（例如另一个张量的大小）时，此函数**必须**与 `torch.compile(..., dynamic=False)` 一起使用。"

#: ../../source/apidocs/evox/evox.utils.op_register.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.utils.op_register`"
msgstr "{py:mod}`evox.utils.op_register`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`FnCallable <evox.utils.op_register.FnCallable>`"
msgstr "{py:obj}`FnCallable <evox.utils.op_register.FnCallable>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:22
#, fuzzy, python-brace-format
msgid "{py:obj}`VmapFnCallable <evox.utils.op_register.VmapFnCallable>`"
msgstr "{py:obj}`VmapFnCallable <evox.utils.op_register.VmapFnCallable>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:26
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`VmapWrapInputsCallable "
"<evox.utils.op_register.VmapWrapInputsCallable>`"
msgstr ""
"{py:obj}`VmapWrapInputsCallable "
"<evox.utils.op_register.VmapWrapInputsCallable>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:38
#, fuzzy, python-brace-format
msgid ""
"{py:obj}`_default_vmap_wrap_inputs "
"<evox.utils.op_register._default_vmap_wrap_inputs>`"
msgstr ""
"{py:obj}`_default_vmap_wrap_inputs "
"<evox.utils.op_register._default_vmap_wrap_inputs>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:42
#, python-brace-format
msgid ""
"{py:obj}`_register_vmap_level <evox.utils.op_register._register_vmap_level>`"
msgstr ""
"{py:obj}`_register_vmap_level <evox.utils.op_register._register_vmap_level>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:46
#, fuzzy, python-brace-format
msgid "{py:obj}`register_vmap_op <evox.utils.op_register.register_vmap_op>`"
msgstr "{py:obj}`register_vmap_op <evox.utils.op_register.register_vmap_op>`"

#: ../../../src/evox/utils/op_register.py:48
#: ../../../src/evox/utils/op_register.py:148
msgid ""
"Register a function as a custom operator with (optional) vectorized-map "
"(vmap) support. This function is a simple wrapper around "
"[`torch.library.custom_op`](https://pytorch.org/docs/stable/library.html#torch.library.custom_op),"
" see [PyTorch Custom "
"Op](https://pytorch.org/tutorials/advanced/python_custom_ops.html#python-"
"custom-ops-tutorial) and "
"[`torch.library.custom_op`](https://pytorch.org/docs/stable/library.html#torch.library.custom_op)"
" for more information."
msgstr ""
"将函数注册为带有（可选）矢量化映射（vmap）支持的自定义操作符。此函数是 "
"[`torch.library.custom_op`](https://pytorch.org/docs/stable/library.html#torch.library.custom_op)"
" 的简单包装器，更多信息请参见 [PyTorch Custom "
"Op](https://pytorch.org/tutorials/advanced/python_custom_ops.html#python-"
"custom-ops-tutorial) 和 "
"[`torch.library.custom_op`](https://pytorch.org/docs/stable/library.html#torch.library.custom_op)。"

#: ../../source/apidocs/evox/evox.utils.op_register.md:58
#, fuzzy, python-brace-format
msgid "{py:obj}`T <evox.utils.op_register.T>`"
msgstr "{py:obj}`T <evox.utils.op_register.T>`"

#: ../../source/apidocs/evox/evox.utils.op_register.md:70
msgid "'TypeVar(...)'"
msgstr "TypeVar(...)"

#: ../../source/apidocs/evox/evox.utils.op_register.md:80
#: ../../source/apidocs/evox/evox.utils.op_register.md:98
#: ../../source/apidocs/evox/evox.utils.op_register.md:116
#, python-brace-format
msgid "Bases: {py:obj}`typing.Protocol`\\[{py:obj}`evox.utils.op_register.T`\\]"
msgstr "基础: {py:obj}`typing.Protocol`\\[{py:obj}`evox.utils.op_register.T`\\]"

#: ../../../src/evox/utils/op_register.py:152
msgid "The operator function to register."
msgstr "要注册的操作函数。"

#: ../../../src/evox/utils/op_register.py:153
msgid "The fake (abstract evaluation) function to register to fn."
msgstr "假的（抽象评估）函数，用于注册到 fn。"

#: ../../../src/evox/utils/op_register.py:154
msgid ""
"The vmap function to register to fn. Default None means no vmap support."
msgstr "将 `vmap` 函数注册到 `fn`。默认值为 `None`，表示不支持 `vmap`。"

#: ../../../src/evox/utils/op_register.py:155
msgid ""
"The fake (abstract evaluation) vmap function to register to vmap_fn. Ignored"
" if vmap_fn is None; cannot be None otherwise."
msgstr "假（抽象评估）vmap函数，用于注册到vmap_fn。如果vmap_fn为None，则忽略；否则不能为None。"

#: ../../../src/evox/utils/op_register.py:156
msgid ""
"The function to deal with inputs for vmap_fn. Ignored if vmap_fn is None. "
"Default None will be replaced by _default_vmap_wrap_inputs, which moves all "
"inputs's vmap dimensions to the first dimensions (including pytree leafs), "
"and adds additional broadcast dimensions at the beginning if no vmap "
"dimension is present."
msgstr ""
"处理 vmap_fn 输入的函数。如果 vmap_fn 为 None，则忽略。默认值 None 将被 _default_vmap_wrap_inputs"
" 替代，该函数会将所有输入的 vmap 维度移动到第一维度（包括 pytree 的叶子部分），并在最前面添加额外的广播维度（如果不存在 vmap "
"维度）。"

#: ../../../src/evox/utils/op_register.py:157
msgid "The outputs' vmap dimensions of vmap_fn. Ignored if vmap_fn is None."
msgstr "vmap_fn 的输出 vmap 维度。如果 vmap_fn 为 None，则忽略。"

#: ../../../src/evox/utils/op_register.py:158
msgid ""
"The maximum vmap level to support. Default None means no vmap level if "
"vmap_fn is None, or 1 if vmap_fn is not None."
msgstr ""
"支持的最大 vmap 等级。默认值 None 表示如果 vmap_fn 为 None，则没有 vmap 等级；如果 vmap_fn 不为 None，则为"
" 1。"

#: ../../../src/evox/utils/op_register.py:159
msgid ""
"The name of the operator. Default None will be replaced by "
"\"evox::_custom_op_\" + fn.__name__."
msgstr "运算符的名称。默认值为 None，将被替换为 \"evox::_custom_op_\" + fn.__name__。"

#: ../../../src/evox/utils/op_register.py:160
msgid ""
"The names of args that the function mutates. This MUST be accurate, "
"otherwise, the behavior is undefined. See torch.library.custom_op for more "
"information."
msgstr "函数会修改的参数名称。这个必须是准确的，否则行为将是未定义的。请参阅 torch.library.custom_op 了解更多信息。"

#: ../../../src/evox/utils/op_register.py:161
msgid ""
"The device types that the operator supports. See torch.library.custom_op for"
" more information."
msgstr ""
"The device types that the operator supports. See torch.library.custom_op for"
" more information."

#: ../../../src/evox/utils/op_register.py:162
msgid ""
"The schema of the operator. See torch.library.custom_op for more "
"information."
msgstr "操作符的结构。有关更多信息，请参见 torch.library.custom_op。"

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:1
#, python-brace-format
msgid "{py:mod}`evox.utils.parameters_and_vector`"
msgstr "{py:mod}`evox.utils.parameters_and_vector`"

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:18
#, python-brace-format
msgid ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"
msgstr ""
"{py:obj}`ParamsAndVector <evox.utils.parameters_and_vector.ParamsAndVector>`"

#: ../../../src/evox/utils/parameters_and_vector.py:20
#: ../../../src/evox/utils/parameters_and_vector.py:33
msgid ""
"The class to convert (batched) parameters dictionary to vector(s) and vice "
"versa."
msgstr "将（批处理）参数字典转换为向量的类，反之亦然。"

#: ../../source/apidocs/evox/evox.utils.parameters_and_vector.md:30
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.ModuleBase`"
msgstr "Bases: {py:obj}`evox.core.ModuleBase`"

#: ../../../src/evox/utils/parameters_and_vector.py:39
msgid "Initialize the ParamsAndVector instance."
msgstr "初始化 ParamsAndVector 实例。"

#: ../../../src/evox/utils/parameters_and_vector.py:41
msgid ""
"A PyTorch model whose parameters will be used to initialize the parameter "
"and vector conversion attributes. Must be an initialized PyTorch model."
msgstr "一个 PyTorch 模型，其参数将用于初始化参数和向量转换属性。必须是已初始化的 PyTorch 模型。"

#: ../../../src/evox/utils/parameters_and_vector.py:62
msgid "Convert the input parameters dictionary to a single vector."
msgstr "将输入参数字典转换为单个向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:64
msgid "The input parameters dictionary."
msgstr "输入参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:66
msgid "The output vector obtained by concatenating the flattened parameters."
msgstr "通过连接展平的参数获得的输出向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:70
msgid "Convert a batched parameters dictionary to a batch of vectors."
msgstr "将批量参数字典转换为向量的批量。"

#: ../../../src/evox/utils/parameters_and_vector.py:72
msgid ""
"The input dictionary values must be batched parameters, i.e., they must have"
" the same shape at the first dimension."
msgstr "输入字典的值必须是批处理参数，即它们在第一维度上必须具有相同的形状。"

#: ../../../src/evox/utils/parameters_and_vector.py:74
msgid "The input batched parameters dictionary."
msgstr "输入批处理参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:76
msgid ""
"The output vectors obtained by concatenating the flattened batched "
"parameters. The first dimension of the output vector corresponds to the "
"batch size."
msgstr "通过连接展平的批处理参数获得的输出向量。输出向量的第一个维度对应于批处理大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:78
msgid "Convert a vector back to a parameters dictionary."
msgstr "将向量转换回参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:80
msgid "The input vector representing flattened model parameters."
msgstr "表示展平模型参数的输入向量。"

#: ../../../src/evox/utils/parameters_and_vector.py:82
msgid "The reconstructed parameters dictionary."
msgstr "重建的参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:86
msgid "Convert a batch of vectors back to a batched parameters dictionary."
msgstr "将一批向量转换回批量参数字典。"

#: ../../../src/evox/utils/parameters_and_vector.py:88
msgid ""
"The input batch of vectors representing flattened model parameters. The "
"first dimension of the tensor corresponds to the batch size."
msgstr "输入批量向量表示展平的模型参数。张量的第一个维度对应于批量大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:90
msgid ""
"The reconstructed batched parameters dictionary whose tensors' first "
"dimensions correspond to the batch size."
msgstr "重构后的批处理参数字典，其张量的第一个维度对应于批处理大小。"

#: ../../../src/evox/utils/parameters_and_vector.py:94
msgid ""
"The forward function for the `ParamsAndVector` module is an alias of "
"`batched_to_params` to cope with `StdWorkflow`."
msgstr ""
"`ParamsAndVector` 模块的 forward 函数是 `batched_to_params` 的别名，用于应对 `StdWorkflow"

#: ../../source/apidocs/evox/evox.utils.re_export.md:1
#, fuzzy, python-brace-format
msgid "{py:mod}`evox.utils.re_export`"
msgstr "{py:mod}`evox.utils.re_export`"

#: ../../source/apidocs/evox/evox.utils.re_export.md:18
#, fuzzy, python-brace-format
msgid "{py:obj}`__all__ <evox.utils.re_export.__all__>`"
msgstr "{py:obj}`__all__ <evox.utils.re_export.__all__>`"

#: ../../source/apidocs/evox/evox.utils.re_export.md:30
msgid "['tree_flatten', 'tree_unflatten']"
msgstr "['tree_flatten', 'tree_unflatten']"

#: ../../source/apidocs/evox/evox.vis_tools.md:1
#, python-brace-format
msgid "{py:mod}`evox.vis_tools`"
msgstr "{py:mod}`evox.vis_tools`"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:1
#, python-brace-format
msgid "{py:mod}`evox.vis_tools.exv`"
msgstr "{py:mod}`evox.vis_tools.exv`"

#: ../../../src/evox/vis_tools/exv.py:7
msgid "This module helps serialize data to EvoXVision storage format (exv)."
msgstr "此模块帮助将数据序列化为EvoXVision存储格式（exv）。"

#: ../../../src/evox/vis_tools/exv.py:13
msgid ""
"The numbers are stored in little-endian format. The metadata is a JSON utf-8"
" encoded string, which contains the schema of the binary data. The format of"
" the metadata is as follows:"
msgstr "数字以小端格式存储。元数据是一个 JSON utf-8 编码的字符串，其中包含二进制数据的模式。元数据的格式如下："

#: ../../../src/evox/vis_tools/exv.py:49
msgid ""
"where <type> represents the data type of the field, available types are:"
msgstr "在这里，<type> 代表字段的数据类型，可用的类型有："

#: ../../../src/evox/vis_tools/exv.py:50
msgid "\"u8\", \"u16\", \"u32\", \"u64\","
msgstr "\"u8\", \"u16\", \"u32\", \"u64\","

#: ../../../src/evox/vis_tools/exv.py:51
msgid "\"i16\", \"i32\", \"i64\","
msgstr "\"i16\", \"i32\", \"i64\","

#: ../../../src/evox/vis_tools/exv.py:52
msgid "\"f16\", \"f32\", \"f64\" The size and offset are in bytes."
msgstr "\"f16\", \"f32\", \"f64\" 大小和偏移量以字节为单位。"

#: ../../../src/evox/vis_tools/exv.py:56
msgid ""
"The magic number is used to identify the file format. 0x65787631 is the byte"
" code for \"exv1\". The binary data blob is a sequence of binary data "
"chunks. In EvoX, the algorithm is allowed to have a different behavior in "
"the first iteration (initialization phase), which can have a different chunk"
" size than the rest of the iterations. Therefore it contains two different "
"schemas for the initial iteration and the rest of the iterations."
msgstr ""
"魔术数字用于识别文件格式。0x65787631 是 \"exv1\" 的字节码。二进制数据块是二进制数据块的序列。在 EvoX "
"中，算法允许在第一次迭代（初始化阶段）中具有不同的行为，这可能与其余迭代的块大小不同。因此，它包含了初始迭代和其余迭代的两种不同模式。"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:18
#, python-brace-format
msgid "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"
msgstr "{py:obj}`EvoXVisionAdapter <evox.vis_tools.exv.EvoXVisionAdapter>`"

#: ../../../src/evox/vis_tools/exv.py:20 ../../../src/evox/vis_tools/exv.py:61
msgid ""
"EvoXVisionAdapter is a class that streams evolutionary optimization data to "
"an exv file. The exv file format is a binary format that created "
"specifically for the evolutionary optimization data. The format is designed "
"to be efficient for both stream reading and writing data, while being able "
"to randomly access data at any iteration."
msgstr ""
"EvoXVisionAdapter 是一个类，用于将演化优化数据流式传输到 exv 文件。exv "
"文件格式是一种专门为演化优化数据创建的二进制格式。该格式设计为在流式读取和写入数据时都能高效运行，同时能够在任何迭代中随机访问数据。"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:30
#, python-brace-format
msgid "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"
msgstr "{py:obj}`_get_data_type <evox.vis_tools.exv._get_data_type>`"

#: ../../source/apidocs/evox/evox.vis_tools.exv.md:34
#, python-brace-format
msgid "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"
msgstr "{py:obj}`new_exv_metadata <evox.vis_tools.exv.new_exv_metadata>`"

#: ../../../src/evox/vis_tools/exv.py:36 ../../../src/evox/vis_tools/exv.py:53
msgid ""
"Takes the input of the populaton and fitness from the first two iterations, "
"and returns the schema for exv file format."
msgstr "接收前两次迭代的种群和适应度输入，并返回 exv 文件格式的模式。"

#: ../../../src/evox/vis_tools/exv.py:67
msgid ""
"Create a new EvoXVisionAdapter instance, which writes data to an exv file. "
"To automatically inference the data schema, the EvoXVisionAdapter requires 2"
" iterations of data, therefore it will only start to write data after the 2 "
"iterations of the optimization loop are completed."
msgstr ""
"创建一个新的EvoXVisionAdapter实例，该实例将数据写入exv文件。为了自动推断数据模式，EvoXVisionAdapter需要2次数据迭代，因此它将在优化循环的2次迭代完成后才开始写入数据。"

#: ../../../src/evox/vis_tools/exv.py:71
msgid "The path to the exv file"
msgstr "通向exv文件的路径"

#: ../../../src/evox/vis_tools/exv.py:72
msgid ""
"The buffer size to use for file operations, passed directly to the open() "
"function. The default is 0, which disables buffering (unbuffered mode)."
msgstr "用于文件操作的缓冲区大小，直接传递给 `open()` 函数。默认值为 0，表示禁用缓冲（无缓冲模式）。"

#: ../../../src/evox/vis_tools/exv.py:76
msgid ""
"Buffering affects how data is written to the file to minimize system call "
"overhead. However, from a filesystem perspective, operations are always be "
"considered buffered."
msgstr "缓冲影响数据写入文件的方式，以最小化系统调用的开销。然而，从文件系统的角度来看，操作始终被视为是缓冲的。"

#: ../../../src/evox/vis_tools/exv.py:78
msgid ""
"Disabling buffering (`buffering=0`) is often recommended in scenarios where "
"system call overhead is not the bottleneck, as it ensures data is "
"immediately written without delay."
msgstr "在系统调用开销不是瓶颈的情况下，通常建议禁用缓冲（`buffering=0`），因为这可以确保数据被立即写入而不会延迟。"

#: ../../../src/evox/vis_tools/exv.py:80
msgid ""
"When buffering is enabled, it may be necessary to call `flush()` explicitly "
"to guarantee that all data is written to the file."
msgstr "当启用缓冲时，可能需要显式调用 `flush()` 以确保所有数据都写入文件。"

#: ../../../src/evox/vis_tools/exv.py:98
msgid "Write the header of the exv file."
msgstr "请写出 exv 文件的标题。"

#: ../../../src/evox/vis_tools/exv.py:106
msgid ""
"Stream data to the exv file. Depending on the `buffering` parameter, the "
"data may not be written immediately."
msgstr "将数据流传输到 exv 文件。根据 `buffering` 参数，数据可能不会立即写入。"

#: ../../../src/evox/vis_tools/exv.py:114
msgid "Flush the internal buffer to the file."
msgstr "将内部缓冲区刷新到文件。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:1
#, python-brace-format
msgid "{py:mod}`evox.vis_tools.plot`"
msgstr "{py:mod}`evox.vis_tools.plot`"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:18
#, python-brace-format
msgid "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"
msgstr "{py:obj}`plot_dec_space <evox.vis_tools.plot.plot_dec_space>`"

#: ../../../src/evox/vis_tools/plot.py:20
#: ../../../src/evox/vis_tools/plot.py:50
msgid ""
"A Built-in plot function for visualizing the population of single-objective "
"algorithm. Use plotly internally, so you need to install plotly to use this "
"function."
msgstr "内置绘图函数用于可视化单目标算法的种群。内部使用plotly，因此需要安装plotly才能使用此函数。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:22
#, python-brace-format
msgid "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"
msgstr "{py:obj}`plot_obj_space_1d <evox.vis_tools.plot.plot_obj_space_1d>`"

#: ../../../src/evox/vis_tools/plot.py:24
#: ../../../src/evox/vis_tools/plot.py:57
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem."
msgstr "可视化单目标优化问题中种群的适应度值。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:26
#, python-brace-format
msgid ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"
msgstr ""
"{py:obj}`plot_obj_space_1d_no_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_no_animation>`"

#: ../../../src/evox/vis_tools/plot.py:28
#: ../../../src/evox/vis_tools/plot.py:64
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. No animation."
msgstr "在单目标优化问题中可视化种群的适应度值。无动画。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:30
#, python-brace-format
msgid ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"
msgstr ""
"{py:obj}`plot_obj_space_1d_animation "
"<evox.vis_tools.plot.plot_obj_space_1d_animation>`"

#: ../../../src/evox/vis_tools/plot.py:32
#: ../../../src/evox/vis_tools/plot.py:71
msgid ""
"Visualize the fitness values of the population in a single-objective "
"optimization problem. With animation."
msgstr "在单目标优化问题中可视化种群的适应度值。带有动画。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:34
#, python-brace-format
msgid "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"
msgstr "{py:obj}`plot_obj_space_2d <evox.vis_tools.plot.plot_obj_space_2d>`"

#: ../../../src/evox/vis_tools/plot.py:36
#: ../../../src/evox/vis_tools/plot.py:78
msgid ""
"Visualize the fitness values of the population in a multi-objective (2 "
"objectives) optimization problem."
msgstr "可视化种群在多目标（2个目标）优化问题中的适应度值。"

#: ../../source/apidocs/evox/evox.vis_tools.plot.md:38
#, python-brace-format
msgid "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"
msgstr "{py:obj}`plot_obj_space_3d <evox.vis_tools.plot.plot_obj_space_3d>`"

#: ../../../src/evox/vis_tools/plot.py:40
#: ../../../src/evox/vis_tools/plot.py:85
msgid ""
"Visualize the fitness values of the population in a multi-objective (3 "
"objectives) optimization problem."
msgstr "可视化种群在多目标（3个目标）优化问题中的适应度值。"

#: ../../../src/evox/vis_tools/plot.py:53
msgid ""
"If the problem is provided, we will plot the fitness landscape of the "
"problem."
msgstr "如果提供了问题，我们将绘制该问题的适应度景观。"

#: ../../../src/evox/vis_tools/plot.py:55
msgid ""
"A list of arrays, each array represents the population of one generation."
msgstr "一个数组列表，每个数组代表一代的种群。"

#: ../../../src/evox/vis_tools/plot.py:56
#: ../../../src/evox/vis_tools/plot.py:61
#: ../../../src/evox/vis_tools/plot.py:83
#: ../../../src/evox/vis_tools/plot.py:90
msgid "Additional arguments to be passed to the plotly layout."
msgstr "传递给 plotly 布局的附加参数。"

#: ../../../src/evox/vis_tools/plot.py:58
#: ../../../src/evox/vis_tools/plot.py:63
#: ../../../src/evox/vis_tools/plot.py:85
#: ../../../src/evox/vis_tools/plot.py:92
msgid "A plotly figure."
msgstr "A plotly figure."

#: ../../../src/evox/vis_tools/plot.py:59
#: ../../../src/evox/vis_tools/plot.py:80
#: ../../../src/evox/vis_tools/plot.py:87
msgid ""
"A list of arrays, each array represents the fitness values of the population"
" of one generation."
msgstr "一组数组，每个数组代表一代种群的适应度值。"

#: ../../../src/evox/vis_tools/plot.py:60
msgid "Whether to show the animation of the fitness values over generations."
msgstr "是否显示适应度值随世代变化的动画。"

#: ../../../src/evox/vis_tools/plot.py:81
#: ../../../src/evox/vis_tools/plot.py:89
msgid "The Pareto front of the problem. Optional."
msgstr "问题的 Pareto 前沿。可选。"

#: ../../../src/evox/vis_tools/plot.py:82
#: ../../../src/evox/vis_tools/plot.py:88
msgid ""
"Whether to sort the points in the plot. This will only affect the animation "
"behavior."
msgstr "是否对图中的点进行排序。这只会影响动画行为。"

#: ../../source/apidocs/evox/evox.workflows.md:1
#, python-brace-format
msgid "{py:mod}`evox.workflows`"
msgstr "{py:mod}`evox.workflows`"

#: ../../source/apidocs/evox/evox.workflows.md:28
#, python-brace-format
msgid "{py:obj}`__all__ <evox.workflows.__all__>`"
msgstr "{py:obj}`__all__ <evox.workflows.__all__>`"

#: ../../source/apidocs/evox/evox.workflows.md:40
msgid "['EvalMonitor', 'StdWorkflow']"
msgstr "['EvalMonitor', 'StdWorkflow']"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:1
#, python-brace-format
msgid "{py:mod}`evox.workflows.eval_monitor`"
msgstr "{py:mod}`evox.workflows.eval_monitor`"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:18
#, python-brace-format
msgid "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"
msgstr "{py:obj}`EvalMonitor <evox.workflows.eval_monitor.EvalMonitor>`"

#: ../../../src/evox/workflows/eval_monitor.py:20
#: ../../../src/evox/workflows/eval_monitor.py:33
msgid ""
"Evaluation monitor. Used for both single-objective and multi-objective "
"workflow. Hooked around the evaluation process, can monitor the offspring, "
"their corresponding fitness and keep track of the evaluation count. "
"Moreover, it can also record the best solution or the pareto front on-the-"
"fly."
msgstr ""
"评估监控器被用于单目标和多目标工作流。它与评估流程挂钩，可以监控子代及其相应的适应度并对评估计数进行跟踪。此外，它还能即时记录最优解或帕累托前沿。"

#: ../../source/apidocs/evox/evox.workflows.eval_monitor.md:30
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.Monitor`"
msgstr "Bases: {py:obj}`evox.core.Monitor`"

#: ../../../src/evox/workflows/eval_monitor.py:39
msgid "Initialize the monitor."
msgstr "初始化监视器。"

#: ../../../src/evox/workflows/eval_monitor.py:41
msgid "Whether the optimization is multi-objective. Defaults to False."
msgstr "是否为多目标优化。默认值为 False。"

#: ../../../src/evox/workflows/eval_monitor.py:42
msgid ""
"Whether to record the full history of fitness value. Default to True. "
"Setting it to False may reduce memory usage."
msgstr "是否记录适应度值的完整历史。默认为True。将其设置为FALSE可能会减少内存使用。"

#: ../../../src/evox/workflows/eval_monitor.py:43
msgid ""
"Whether to record the full history of solutions. Default to False. Setting "
"it to True may increase memory usage."
msgstr "是否记录完整的解的历史。默认为 False。将其设置为 True 可能会增加内存使用量。"

#: ../../../src/evox/workflows/eval_monitor.py:44
msgid ""
"Only affect Single-objective optimization. The number of elite solutions to "
"record. Default to 1, which will record the best individual."
msgstr "只影响单目标优化。要记录的精英解决方案的数量。默认为 1，将记录最佳个人。"

#: ../../../src/evox/workflows/eval_monitor.py:45
msgid "The device of the monitor. Defaults to None."
msgstr "监视器的设备。默认值为 None。"

#: ../../../src/evox/workflows/eval_monitor.py:46
msgid ""
"The device to record the history. Defaults to None. If None, it will use "
"cpu."
msgstr "记录历史的设备。默认为 None。如果为 None，将使用 cpu。"

#: ../../../src/evox/workflows/eval_monitor.py:49
msgid ""
"Setting the `history_device` to the same device as the monitor will save the"
" data transfer time, but may increase the memory usage on the device."
msgstr "将 `history_device` 设置为与监视器相同的设备可以节省数据传输时间，但可能会增加设备上的内存使用量。"

#: ../../../src/evox/workflows/eval_monitor.py:54
msgid ""
"When `opt_direction=\"max\"` is used, fitness values are internally "
"multiplied by -1 to ensure that optimization logic always treats the best "
"fitness as the minimum value. As a result, raw fitness values (e.g., "
"`monitor.topk_fitness`, `monitor.fitness_history`, etc.) will appear "
"negated. However, access methods such as `monitor.get_best_fitness()` and "
"`monitor.get_pf_fitness()` automatically reverse this negation and return "
"the original, unmodified values."
msgstr ""
"当使用 `opt_direction=\"max\"` 时，适应度值会在内部被乘以 "
"-1，以确保优化逻辑始终将最优适应度视为最小值。因此，原始适应度值（例如，`monitor.topk_fitness`、`monitor.fitness_history`"
" 等）将显示为取反的值。然而，像 `monitor.get_best_fitness()` 和 `monitor.get_pf_fitness()` "
"这样的访问方法会自动反转这种取反操作并返回原始的、未修改的值。"

#: ../../../src/evox/workflows/eval_monitor.py:128
msgid "Get the fitness values from the latest iteration."
msgstr "从最新迭代中获取适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:136
msgid "Get the solution from the latest iteration."
msgstr "从最新的迭代中获取解决方案。"

#: ../../../src/evox/workflows/eval_monitor.py:144
msgid "Get the topk fitness values so far."
msgstr "获取当前前k个适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:152
msgid "Get the topk solutions so far."
msgstr "获取当前最优的前k个解。"

#: ../../../src/evox/workflows/eval_monitor.py:160
msgid "Get the best solution so far."
msgstr "获取迄今为止的最佳解决方案。"

#: ../../../src/evox/workflows/eval_monitor.py:168
msgid "Get the best fitness value so far."
msgstr "获取当前最佳适应度值。"

#: ../../../src/evox/workflows/eval_monitor.py:176
msgid ""
"Get the approximate pareto front fitness values of all the solutions "
"evaluated so far. Requires enabling `full_fit_history`."
msgstr "获取到目前为止评估的所有解决方案的近似帕累托前沿适应度值。需要启用 `full_fit_history`。"

#: ../../../src/evox/workflows/eval_monitor.py:184
msgid ""
"Get the approximate pareto front solutions of all the solutions evaluated so"
" far. Requires enabling both `full_sol_history` and `full_sol_history`. If "
"`deduplicate` is set to True, the duplicated solutions will be removed."
msgstr ""
"获取到目前为止已评估的所有解决方案的近似帕累托前沿解。需要启用 `full_sol_history` 和 `full_sol_history`。如果 "
"`deduplicate` 设置为 True，则重复的解决方案将被删除。"

#: ../../../src/evox/workflows/eval_monitor.py:192
msgid ""
"Get the approximate pareto front solutions and fitness values of all the "
"solutions evaluated so far. Requires enabling both `full_sol_history` and "
"`full_sol_history`. If `deduplicate` is set to True, the duplicated "
"solutions will be removed."
msgstr ""
"获取到目前为止评估的所有解的近似帕累托前沿解和适应度值。需要启用 `full_sol_history` 和 "
"`full_fitness_history`。如果将 `deduplicate` 设置为 True，则重复的解将被移除。"

#: ../../../src/evox/workflows/eval_monitor.py:200
msgid "Get the full history of fitness values."
msgstr "获取适应度值的完整历史记录。"

#: ../../../src/evox/workflows/eval_monitor.py:208
msgid "Get the full history of solutions."
msgstr "获取完整的解决方案历史。"

#: ../../../src/evox/workflows/eval_monitor.py:216
msgid ""
"Plot the fitness history. If the problem's Pareto front is provided, it will"
" be plotted as well."
msgstr "绘制适应度历史。如果提供了问题的 Pareto front，它也会被绘制。"

#: ../../../src/evox/workflows/eval_monitor.py:219
msgid "The Pareto front of the problem. Default to None."
msgstr "问题的帕累托前沿。默认值为 None。"

#: ../../../src/evox/workflows/eval_monitor.py:220
msgid ""
"The source of the data, either \"eval\" or \"pop\", default to \"eval\". "
"When \"eval\", the fitness from the problem evaluation side will be plotted,"
" representing what the problem sees. When \"pop\", the fitness from the "
"population inside the algorithm will be plotted, representing what the "
"algorithm sees."
msgstr ""
"数据来源，可以是 \"eval\" 或 \"pop\"，默认为 \"eval\"。当选择 \"eval\" "
"时，将绘制来自问题评估端的适应度，表示问题所观察到的内容。当选择 \"pop\" 时，将绘制算法内部种群的适应度，表示算法所观察到的内容。"

#: ../../../src/evox/workflows/eval_monitor.py:223
msgid "Additional arguments for the plot."
msgstr "为绘图提供的额外参数。"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:1
#, python-brace-format
msgid "{py:mod}`evox.workflows.std_workflow`"
msgstr "{py:mod}`evox.workflows.std_workflow`"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:18
#, python-brace-format
msgid "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"
msgstr "{py:obj}`StdWorkflow <evox.workflows.std_workflow.StdWorkflow>`"

#: ../../../src/evox/workflows/std_workflow.py:20
#: ../../../src/evox/workflows/std_workflow.py:33
msgid "The standard workflow."
msgstr "标准工作流。"

#: ../../source/apidocs/evox/evox.workflows.std_workflow.md:30
#, python-brace-format
msgid "Bases: {py:obj}`evox.core.Workflow`"
msgstr "Bases: {py:obj}`evox.core.Workflow`"

#: ../../../src/evox/workflows/std_workflow.py:39
msgid "Initialize the standard workflow with static arguments."
msgstr "使用静态参数初始化标准工作流。"

#: ../../../src/evox/workflows/std_workflow.py:41
msgid "The algorithm to be used in the workflow."
msgstr "在工作流中要使用的算法。"

#: ../../../src/evox/workflows/std_workflow.py:42
msgid "The problem to be used in the workflow."
msgstr "在工作流中要使用的问题。"

#: ../../../src/evox/workflows/std_workflow.py:43
msgid "The monitors to be used in the workflow. Defaults to None."
msgstr "在工作流中使用的监视器。默认值为 None。"

#: ../../../src/evox/workflows/std_workflow.py:44
msgid ""
"The optimization direction, can only be \"min\" or \"max\". Defaults to "
"\"min\". If \"max\", the fitness will be negated prior to fitness_transform "
"and monitor."
msgstr ""
"优化方向只能是“min”或“max”。默认为“min”。如果是“max”，适应度将在 `fitness_transform` 和 `monitor` "
"之前取反。"

#: ../../../src/evox/workflows/std_workflow.py:45
msgid ""
"The solution transformation function. MUST be compile-compatible "
"module/function. Defaults to None."
msgstr "解决方案转换函数。必须是可编译兼容的模块/函数。默认值为 None。"

#: ../../../src/evox/workflows/std_workflow.py:46
msgid ""
"The fitness transformation function. MUST be compile-compatible "
"module/function. Defaults to None."
msgstr "适应度转换函数。必须是可编译兼容的模块/函数。默认值为 None。"

#: ../../../src/evox/workflows/std_workflow.py:47
msgid "The device of the workflow. Defaults to None."
msgstr "工作流的设备。默认为 None。"

#: ../../../src/evox/workflows/std_workflow.py:48
msgid "Whether to enable distributed workflow. Defaults to False."
msgstr "是否启用分布式工作流。默认值为 False。"

#: ../../../src/evox/workflows/std_workflow.py:49
msgid "The group name used in the distributed workflow. Defaults to None."
msgstr "在分布式工作流中使用的组名。默认为 None。"

#: ../../../src/evox/workflows/std_workflow.py:52
msgid ""
"The `algorithm`, `problem`, `solution_transform`, and `fitness_transform` "
"will be IN-PLACE moved to the device specified by `device`."
msgstr ""
"`algorithm`、`problem`、`solution_transform` 和 `fitness_transform` 将会被原地移动到由 "
"`device` 指定的设备上。"

#: ../../../src/evox/workflows/std_workflow.py:56
msgid ""
"The `opt_direction` parameter determines the optimization direction. Since "
"EvoX algorithms are designed to minimize by default, setting "
"`opt_direction=\"max\"` will cause the fitness values to be negated before "
"being passed to `fitness_transform` and the monitor."
msgstr ""
"`opt_direction` 参数决定了优化的方向。由于 EvoX 算法默认设计为最小化，因此设置 `opt_direction=\"max\"` "
"会在将适应度值传递给 `fitness_transform` 和监视器之前将其取反。"

#: ../../../src/evox/workflows/std_workflow.py:75
msgid "Perform the last optimization step of the workflow."
msgstr "执行工作流的最后一步优化。"

#: ../../../src/evox/workflows/std_workflow.py:77
msgid ""
"Calls the `final_step` of the algorithm if overwritten; otherwise, its "
"`step` method will be invoked."
msgstr "调用算法的 `final_step` 方法（如果被重写）；否则，将调用其 `step` 方法。"

#: ../../../src/evox/workflows/std_workflow.py:83
msgid ""
"Perform a single optimization step using the algorithm and the problem."
msgstr "使用算法和问题执行单个优化步骤。"

#: ../../source/apidocs/index.rst:2
msgid "API Reference"
msgstr "API文档"

#: ../../source/apidocs/index.rst:4
msgid "This page contains auto-generated API reference documentation [#f1]_."
msgstr "此页面包含自动生成的API参考文档 [#f1]_。"

#: ../../source/apidocs/index.rst:11
msgid ""
"Created with `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-"
"autodoc2>`_"
msgstr ""
"使用 `sphinx-autodoc2 <https://github.com/chrisjsewell/sphinx-autodoc2>`_ 创建"

#: ../../source/examples/brax.ipynb:10002
msgid "Solving Brax Problems in EvoX"
msgstr "用EvoX解决Brax问题"

#: ../../source/examples/brax.ipynb:10004
msgid ""
"EvoX deeply dives into neuroevolution with Brax. Here we will show an "
"example of solving Brax problem in EvoX."
msgstr "EvoX 深入研究使用 Brax 的神经演化。这里我们将展示一个在 EvoX 中解决 Brax 问题的例子。"

#: ../../source/examples/brax.ipynb:40002
msgid "What is Brax"
msgstr "什么是Brax"

#: ../../source/examples/brax.ipynb:40004
msgid ""
"Brax is a fast and fully differentiable physics engine used for research and"
" development of robotics, human perception, materials science, reinforcement"
" learning, and other simulation-heavy applications."
msgstr "Brax 是一个快速且完全可微分的物理引擎，用于机器人学、人类感知、材料科学、强化学习和其他需要大量模拟的应用的研究和开发。"

#: ../../source/examples/brax.ipynb:40006
msgid "Here we will demonstrate a \"swimmer\" environment of Brax."
msgstr "在这我们将演示在Brax中使用“swimmer”环境。"

#: ../../source/examples/brax.ipynb:40008
msgid ""
"For more information, you can browse the [Github of "
"Brax](https://github.com/google/brax)."
msgstr "有关更多信息，您可以浏览 [Brax 的 Github](https://github.com/google/brax)。"

#: ../../source/examples/brax.ipynb:50002
msgid "Design a neural network class"
msgstr "设计一个神经网络类"

#: ../../source/examples/brax.ipynb:50004
msgid ""
"To start with, we need to decide which neural network we are about to "
"construct."
msgstr "要开始，我们需要决定要构建哪个神经网络。"

#: ../../source/examples/brax.ipynb:50006
msgid "Here we will give a simple Multilayer Perceptron (MLP) class."
msgstr "这里我们将给出一个简单的多层感知器（MLP）类。"

#: ../../source/examples/brax.ipynb:70002
msgid "Initiate a model"
msgstr "初始化模型"

#: ../../source/examples/brax.ipynb:70004
msgid "Through the ``SimpleMLP`` class, we can initiate a MLP model."
msgstr "通过``SimpleMLP``类，我们可以初始化一个MLP模型。"

#: ../../source/examples/brax.ipynb:90002
msgid "Initiate an adapter"
msgstr "启动适配器"

#: ../../source/examples/brax.ipynb:90004
msgid "An adapter can help us convert the data back-and-forth."
msgstr "一个转换器可以帮助我们将数据在不同形式间来回转换。"

#: ../../source/examples/brax.ipynb:110002
msgid "With an adapter, we can set out to do this Neuroevolution Task."
msgstr "使用适配器，我们可以开始进行这个神经演化任务。"

#: ../../source/examples/brax.ipynb:110004
msgid "Set up the running process"
msgstr "设置运行过程"

#: ../../source/examples/brax.ipynb:110006
msgid "Initiate an algorithm and a problem"
msgstr "初始化一个算法和一个问题"

#: ../../source/examples/brax.ipynb:110008
msgid ""
"We initiate a [PSO algorithm](#evox.algorithms.so.pso_variants.pso.PSO), and"
" the problem is a [Brax "
"problem](#evox.problems.neuroevolution.brax.BraxProblem) in \"swimmer\" "
"environment."
msgstr ""
"我们初始化一个 [PSO 算法](#evox.algorithms.so.pso_variants.pso.PSO)，并将问题设定为 "
"\"swimmer\" 环境中的一个 [Brax "
"问题](#evox.problems.neuroevolution.brax.BraxProblem)。"

#: ../../source/examples/brax.ipynb:130002
msgid ""
"In this case, we will be using 1000 steps for each episode, and the average "
"reward of 3 episodes will be returned as the fitness value."
msgstr "在这种情况下，我们将为每个 episode 使用 1000 步，并返回 3 个 episode 的平均奖励作为适应度值。"

#: ../../source/examples/brax.ipynb:130004
msgid "Set an monitor"
msgstr "设置一个monitor"

#: ../../source/examples/brax.ipynb:150002
msgid "Initiate an workflow"
msgstr "启动一个工作流"

#: ../../source/examples/brax.ipynb:170002
msgid "Run the workflow"
msgstr "运行工作流"

#: ../../source/examples/brax.ipynb:170004
msgid "Run the workflow and see the magic!"
msgstr "运行工作流并见证魔法！"

#: ../../source/examples/brax.ipynb:170007
msgid ""
"The following block will take around 20 minute to run. The time may vary "
"depending on your hardware."
msgstr "以下代码块大约需要运行20分钟。运行时间可能会因您的硬件而有所不同。"

#: ../../source/examples/brax.ipynb:220003
msgid ""
"Normally, you only need `HTML(problem.visualize(best_params))` to render. "
"The code above is a workaround to ensure the result is displayed correctly "
"on our website."
msgstr ""
"通常，您只需要使用 `HTML(problem.visualize(best_params))` "
"来渲染。上面的代码是一种解决方法，以确保结果在我们的网站上正确显示。"

#: ../../source/examples/brax.ipynb:220004
msgid ""
"The PSO algorithm is not specifically optimized for this type of task, so "
"performance limitations are expected. This example is for demonstration "
"purposes."
msgstr "PSO算法并未针对这种类型的任务进行特别优化，因此预期会有性能限制。此示例仅用于演示目的。"

#: ../../source/examples/brax.ipynb:220007
msgid "We hope you enjoy solving Brax problems with EvoX and have fun!"
msgstr "我们希望您在使用EvoX解决Brax问题时能够享受乐趣！"

#: ../../source/examples/custom_algo_prob.ipynb:10002
msgid "Custom Algorithm and Problem"
msgstr "自定义算法和问题"

#: ../../source/examples/custom_algo_prob.ipynb:10003
msgid ""
"In this notebook, we will show how to use the "
"[`Algorithm`](#evox.core.components.Algorithm) and "
"[`Problem`](#evox.core.components.Problem) to create a custom algorithm and "
"problem. Here we will give an example of **implementing a PSO algorithm that"
" solves the Sphere problem**."
msgstr ""
"在这个笔记本中，我们将展示如何使用[`Algorithm`](#evox.core.components.Algorithm)和[`Problem`](#evox.core.components.Problem)来创建一个自定义算法和问题。这里我们将给出一个**实现解决Sphere问题的PSO算法**的例子。"

#: ../../source/examples/custom_algo_prob.ipynb:30002
#: ../../source/guide/developer/custom-alg-pro.md:98
msgid "Algorithm example: PSO algorithm"
msgstr "算法示例：PSO 算法"

#: ../../source/examples/custom_algo_prob.ipynb:30004
msgid ""
"Particle Swarm Optimization (PSO) is a population-based metaheuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr "粒子群优化（PSO）是一种基于种群的元启发式算法，灵感来自鸟类和鱼类的社会行为。它广泛用于解决连续和离散优化问题。"

#: ../../source/examples/custom_algo_prob.ipynb:30006
#: ../../source/guide/developer/custom-alg-pro.md:102
msgid "**Here is an implementation example of PSO algorithm in EvoX:**"
msgstr "**以下是EvoX中PSO算法的实现示例：**"

#: ../../source/examples/custom_algo_prob.ipynb:50002
#: ../../source/guide/developer/custom-alg-pro.md:186
msgid "Problem example: Sphere problem"
msgstr "问题示例：Sphere 问题"

#: ../../source/examples/custom_algo_prob.ipynb:50004
#: ../../source/guide/developer/custom-alg-pro.md:188
msgid ""
"The Sphere problem is a simple, yet fundamental benchmark optimization "
"problem used to test optimization algorithms."
msgstr "Sphere问题是一个简单但基本的基准优化问题，用于测试优化算法。"

#: ../../source/examples/custom_algo_prob.ipynb:50006
#: ../../source/guide/developer/custom-alg-pro.md:190
msgid "The Sphere function is defined as:"
msgstr ""
"The Sphere function is defined as:\n"
"\n"
"球体函数定义为："

#: ../../source/examples/custom_algo_prob.ipynb:50008
#: ../../source/guide/developer/custom-alg-pro.md:192
#, python-brace-format
msgid ""
"\n"
"\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}\n"
msgstr "\\min f(x)= \\sum_{i=1}^{n} x_{i}^{2}"

#: ../../source/examples/custom_algo_prob.ipynb:50011
#: ../../source/guide/developer/custom-alg-pro.md:195
msgid "**Here is an implementation example of Sphere problem in EvoX:**"
msgstr "**以下是EvoX中Sphere问题的实现示例：**"

#: ../../source/examples/custom_algo_prob.ipynb:70002
msgid "Use the algorithm to solve the problem"
msgstr "使用该算法解决该问题"

#: ../../source/examples/custom_algo_prob.ipynb:70004
msgid "Initiate the algorithm, problem and monitor"
msgstr "初始化algorithm，problem，monitor对象。"

#: ../../source/examples/custom_algo_prob.ipynb:90002
msgid "Initiate the workflow and run it"
msgstr "启动工作流并运行它"

#: ../../source/examples/hpo.ipynb:10002
msgid "Efficient HPO with EvoX"
msgstr "高效超参数优化（HPO）使用 EvoX"

#: ../../source/examples/hpo.ipynb:10004
msgid ""
"In this chapter, we will explore how to use EvoX for hyperparameter "
"optimization (HPO)."
msgstr "在本章中，我们将探讨如何使用 EvoX 进行超参数优化 (HPO)。"

#: ../../source/examples/hpo.ipynb:10006
msgid ""
"HPO plays a crucial role in many machine learning tasks but is often "
"overlooked due to its high computational cost, which can sometimes take days"
" to process, as well as the challenges involved in deployment."
msgstr "HPO 在许多机器学习任务中起着至关重要的作用，但由于其高计算成本（有时需要几天的处理时间）以及部署过程中涉及的挑战，常常被忽视。"

#: ../../source/examples/hpo.ipynb:10008
msgid ""
"With EvoX, we can simplify HPO deployment using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) and achieve efficient computation "
"by leveraging the `vmap` method and GPU acceleration."
msgstr ""
"使用 EvoX，我们可以通过 [`HPOProblemWrapper`](#HPOProblemWrapper) 简化 HPO 部署，并通过利用 "
"`vmap` 方法和 GPU 加速实现高效计算。"

#: ../../source/examples/hpo.ipynb:20002
msgid "Transforming Workflow into Problem"
msgstr "将工作流转化为问题"

#: ../../source/examples/hpo.ipynb:20004
msgid "HPO structure"
msgstr "HPO 结构"

#: ../../source/examples/hpo.ipynb:20010
msgid ""
"The key to deploying HPO with EvoX is to transform the "
"[`workflows`](#evox.workflows) into [`problems`](#evox.problems) using the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). Once transformed, we can treat "
"the [`workflows`](#evox.workflows) as standard [`problems`](#evox.problems)."
" The input to the 'HPO problem' consists of the hyper-parameters, and the "
"output is the evaluation metrics."
msgstr ""
"将HPO与EvoX一起部署的关键是使用[`HPOProblemWrapper`](#HPOProblemWrapper)将[`workflows`](#evox.workflows)转换为[`problems`](#evox.problems)。一旦转换完成，我们可以将[`workflows`](#evox.workflows)视为标准的[`problems`](#evox.problems)。'HPO问题'的输入由超参数组成，输出是评估指标。"

#: ../../source/examples/hpo.ipynb:30002
msgid "The Key Component -- `HPOProblemWrapper`"
msgstr "关键组件 -- `HPOProblemWrapper`"

#: ../../source/examples/hpo.ipynb:30004
msgid ""
"To ensure the [`HPOProblemWrapper`](#HPOProblemWrapper) recognizes the "
"hyper-parameters, we need to wrap them using [`Parameter`](#Parameter). With"
" this straightforward step, the hyper-parameters will be automatically "
"identified."
msgstr ""
"为了确保 [`HPOProblemWrapper`](#HPOProblemWrapper) 识别超参数，我们需要使用 "
"[`Parameter`](#Parameter) 来包装它们。通过这个简单的步骤，超参数将被自动识别。"

#: ../../source/examples/hpo.ipynb:40002
msgid "Utilizing the `HPOFitnessMonitor`"
msgstr "利用 `HPOFitnessMonitor"

#: ../../source/examples/hpo.ipynb:40004
msgid ""
"We provide an [`HPOFitnessMonitor`](#HPOFitnessMonitor) that supports "
"calculating 'IGD' and 'HV' metrics for multi-objective problems, as well as "
"the minimum value for single-objective problems."
msgstr ""
"我们提供了一个[`HPOFitnessMonitor`](#HPOFitnessMonitor)，支持计算多目标问题的“IGD”和“HV”指标，以及单目标问题的最小值。"

#: ../../source/examples/hpo.ipynb:40006
msgid ""
"It is important to note that the [`HPOFitnessMonitor`](#HPOFitnessMonitor) "
"is a basic monitor designed for HPO problems. You can also create your own "
"customized monitor flexibly using the approach outlined in [Deploy HPO with "
"Custom Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""
"请注意，[`HPOFitnessMonitor`](#HPOFitnessMonitor) 是一个为 HPO "
"问题设计的基本监视器。您还可以使用[使用自定义算法部署 "
"HPO](#/guide/developer/custom_hpo_prob)中概述的方法灵活地创建自己的自定义监视器。"

#: ../../source/examples/hpo.ipynb:50002
#: ../../source/guide/developer/custom_hpo_prob.ipynb:40002
msgid "A simple example"
msgstr "一个简单的示例"

#: ../../source/examples/hpo.ipynb:50004
msgid ""
"Here, we'll demonstrate a simple example of using EvoX for HPO. "
"Specifically, we will use the [PSO](#PSO) algorithm to optimize the hyper-"
"parameters of the [PSO](#PSO) algorithm for solving the sphere problem."
msgstr ""
"在这里，我们将演示一个使用 EvoX 进行 HPO 的简单示例。具体来说，我们将使用 [PSO](#PSO) 算法来优化 [PSO](#PSO) "
"算法的超参数，以解决球体问题。"

#: ../../source/examples/hpo.ipynb:50006
msgid ""
"Please note that this chapter provides only a brief overview of HPO "
"deployment. For a more detailed guide, refer to [Deploy HPO with Custom "
"Algorithms](#/guide/developer/custom_hpo_prob)."
msgstr ""
"请注意，本章仅提供 HPO 部署的简要概述。有关更详细的指南，请参阅[使用自定义 Algorithms 部署 "
"HPO](#/guide/developer/custom_hpo_prob)。"

#: ../../source/examples/hpo.ipynb:50008
msgid "To start, let's import the necessary modules."
msgstr "要开始，让我们导入必要的模块。"

#: ../../source/examples/hpo.ipynb:70002
msgid "Next, we define a simple Sphere problem."
msgstr "接下来，我们定义一个简单的 Sphere 问题。"

#: ../../source/examples/hpo.ipynb:90002
msgid ""
"Next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to an HPO problem."
msgstr ""
"接下来，我们可以使用 [`StdWorkflow`](#StdWorkflow) 来包装 "
"[`problem`](#evox.problems)、[`algorithm`](#evox.algorithms) 和 "
"[`monitor`](#Monitor)。然后我们使用 [`HPOProblemWrapper`](#HPOProblemWrapper) 将 "
"[`StdWorkflow`](#StdWorkflow) 转换为一个 HPO 问题。"

#: ../../source/examples/hpo.ipynb:110002
msgid "The [`HPOProblemWrapper`](#HPOProblemWrapper) takes 4 arguments:"
msgstr "`HPOProblemWrapper` 接受 4 个参数："

#: ../../source/examples/hpo.ipynb:110003
msgid ""
"`iterations`: The number of iterations to be executed in the optimization "
"process."
msgstr "`iterations`：在优化过程中要执行的迭代次数。"

#: ../../source/examples/hpo.ipynb:110004
msgid ""
"`num_instances`: The number of instances to be executed in parallel in the "
"optimization process."
msgstr "`num_instances`: 在优化过程中的并行执行实例数量。"

#: ../../source/examples/hpo.ipynb:110005
msgid "`workflow`: The workflow to be used in the optimization process."
msgstr "`workflow`：在优化过程中使用的工作流。"

#: ../../source/examples/hpo.ipynb:110006
msgid ""
"`copy_init_state`: Whether to copy the initial state of the workflow for "
"each evaluation. Defaults to `True`. If your workflow contains operations "
"that IN-PLACE modify the tensor(s) in initial state, this should be set to "
"`True`. Otherwise, you can set it to `False` to save memory."
msgstr ""
"`copy_init_state`: 是否为每次评估复制工作流的初始状态。默认为 "
"`True`。如果你的工作流包含对初始状态中的张量进行原地修改的操作，则应将其设置为 `True`。否则，可以将其设置为 `False` 以节省内存。"

#: ../../source/examples/hpo.ipynb:110008
msgid ""
"We can verify whether the [`HPOProblemWrapper`](#HPOProblemWrapper) "
"correctly recognizes the hyper-parameters we define. Since no modifications "
"are made to the hyper-parameters across the 5 instances, they should remain "
"identical for all instances."
msgstr ""
"我们可以验证 [`HPOProblemWrapper`](#HPOProblemWrapper) "
"是否正确识别我们定义的超参数。由于在这5个实例中没有对超参数进行修改，它们在所有实例中应该保持一致。"

#: ../../source/examples/hpo.ipynb:130002
msgid ""
"We can also define a custom set of hyperparameter values. It is important to"
" ensure that the number of hyperparameter sets matches the number of "
"instances in the [`HPOProblemWrapper`](#HPOProblemWrapper). Additionally, "
"custom hyper-parameters must be provided as a dictionary whose values are "
"wrapped using the [`Parameter`](#Parameter)."
msgstr ""
"我们也可以定义一组自定义的超参数值。确保超参数集的数量与[`HPOProblemWrapper`](#HPOProblemWrapper)中的实例数量匹配是很重要的。此外，自定义超参数必须以字典形式提供，其值需要使用[`Parameter`](#Parameter)进行包装。"

#: ../../source/examples/hpo.ipynb:150002
msgid ""
"Now, we use the [PSO](#PSO) algorithm to optimize the hyperparameters of the"
" [PSO](#PSO) algorithm."
msgstr "现在，我们使用[PSO](#PSO)算法来优化[PSO](#PSO)算法的超参数。"

#: ../../source/examples/hpo.ipynb:150004
msgid ""
"It is important to ensure that the population size of the [PSO](#PSO) "
"matches the number of instances; otherwise, unexpected errors may occur."
msgstr "确保[PSO](#PSO)的种群大小与实例数量匹配非常重要，否则可能会发生意外错误。"

#: ../../source/examples/hpo.ipynb:150006
msgid ""
"Additionally, the solution needs to be transformed in the outer workflow, as"
" the [`HPOProblemWrapper`](#HPOProblemWrapper) requires the input to be in "
"the form of a dictionary."
msgstr ""
"此外，解决方案需要在外部工作流中进行转换，因为[`HPOProblemWrapper`](#HPOProblemWrapper)要求输入为字典形式。"

#: ../../source/examples/index.md:1
msgid "EvoX's examples"
msgstr "EvoX的样例"

#: ../../source/examples/moalg.ipynb:10002
msgid "Multi-Objective Algorithm"
msgstr "多目标算法"

#: ../../source/examples/moalg.ipynb:20002
msgid ""
"In this notebook, we will use the Reference Vector Guided Evolutionary "
"Algorithm (**RVEA**) to find the optimal solutions of the **DTLZ2** problem."
msgstr "在这个笔记本中，我们将使用参考向量引导演化算法（**RVEA**）来寻找 **DTLZ2** 问题的最优解。"

#: ../../source/examples/moalg.ipynb:40002
msgid "(Optional) Use GPU to run the code"
msgstr "（可选）使用GPU运行代码"

#: ../../source/examples/moalg.ipynb:40003
msgid ""
"We often prefer to run our code on a GPU for faster execution. However, if a"
" GPU is unavailable, running on a CPU is also acceptable."
msgstr "我们通常更喜欢在GPU上运行代码以加快执行速度。然而，如果没有GPU，使用CPU运行也是可以接受的。"

#: ../../source/examples/moalg.ipynb:60002
msgid "Running example: RVEA on DTLZ2 problem"
msgstr "运行示例：RVEA 在 DTLZ2 问题上"

#: ../../source/examples/moalg.ipynb:60003
msgid ""
"The following code is used to set up the "
"[`DTLZ2`](#evox.problems.numerical.dtlz) problem and the "
"[`RVEA`](#evox.algorithms.mo.rvea) algorithm. More information about the "
"problem and algorithm can be found in the corresponding section of the "
"documentation."
msgstr ""
"以下代码用于设置 [`DTLZ2`](#evox.problems.numerical.dtlz) 问题和 "
"[`RVEA`](#evox.algorithms.mo.rvea) 算法。关于该问题和算法的更多信息可以在文档的相应部分找到。"

#: ../../source/examples/moalg.ipynb:80002
msgid ""
"With this setup in place, we can now start to optimize. We set to let the "
"multi-objective algorithm optimize for 100 steps on this problem"
msgstr "在这个设置完成后，我们现在可以开始优化。我们设置让多目标算法在这个问题上优化100步。"

#: ../../source/examples/so-algorithm.ipynb:10002
msgid "Numerical Optimization"
msgstr "数值优化"

#: ../../source/examples/so-algorithm.ipynb:20002
msgid ""
"This notebook offers a step-by-step tutorial on utilizing EvoX to optimize "
"the Ackley function through the Particle Swarm Optimization (PSO) algorithm."
" Both the PSO algorithm and the Ackley optimization problem are integrated "
"as built-in components within the EvoX framework."
msgstr ""
"本笔记本提供了一个逐步教程，指导如何使用EvoX通过粒子群优化（PSO）算法来优化Ackley函数。PSO算法和Ackley优化问题都作为内置组件集成在EvoX框架中。"

#: ../../source/examples/so-algorithm.ipynb:20004
msgid ""
"First, we should import all necessary modules including `PSO` (algorithm), "
"`Ackley` (problem) and `StdWorkflow` & `EvalMonitor` (workflow)."
msgstr ""
"首先，我们应该导入所有必要的模块，包括 `PSO`（算法）、`Ackley`（问题）以及 `StdWorkflow` 和 "
"`EvalMonitor`（工作流）。"

#: ../../source/examples/so-algorithm.ipynb:40002
msgid ""
"Here, we instantiate the [`PSO`](#evox.algorithms.so.pso_variants.pso.PSO) "
"algorithm. We specify the following settings:"
msgstr ""
"在这里，我们实例化[`PSO`](#evox.algorithms.so.pso_variants.pso.PSO) 算法。我们指定了以下设置："

#: ../../source/examples/so-algorithm.ipynb:40004
msgid "`pop_size`: The size of the particle swarm (population)."
msgstr "`pop_size`: 粒子群（种群）的大小。"

#: ../../source/examples/so-algorithm.ipynb:40005
msgid ""
"`lb` and `ub`: The lower and upper bounds for each dimension in the search "
"space."
msgstr "`lb` 和 `ub`: 搜索空间中每个维度的下限和上限。"

#: ../../source/examples/so-algorithm.ipynb:40006
msgid "Other parameters are all default. Please refer to the detailed API."
msgstr "其他参数都是默认的。请参考详细的API。"

#: ../../source/examples/so-algorithm.ipynb:60002
msgid ""
"Next, we choose the [`Ackley`](#evox.problems.numerical.basic.Ackley) "
"function in EvoX' s numerical problem."
msgstr ""
"接下来，我们选择 EvoX 的数值问题中的 [`Ackley`](#evox.problems.numerical.basic.Ackley) 函数。"

#: ../../source/examples/so-algorithm.ipynb:80002
msgid ""
"We creat an [`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor) "
"instance to track necessary information during the optimization procedure."
msgstr ""
"我们创建一个[`EvalMonitor`](#evox.workflows.eval_monitor.EvalMonitor)实例，以跟踪优化过程中的必要信息。"

#: ../../source/examples/so-algorithm.ipynb:100002
msgid ""
"The [`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) class provides"
" a standardized process to integrate the algorithm, problem, and monitor."
msgstr ""
"[`StdWorkflow`](#evox.workflows.std_workflow.StdWorkflow) "
"类提供了一个标准化的过程来整合算法、问题和监控器。"

#: ../../source/examples/so-algorithm.ipynb:120002
msgid ""
"Calling `setup()` initializes the components so that the workflow is ready "
"to perform optimization steps."
msgstr "调用 `setup()` 初始化组件，使工作流准备好执行优化步骤。"

#: ../../source/examples/so-algorithm.ipynb:130002
msgid ""
"We run the optimization for a certain number of iterations (100 in this "
"example). In each iteration, the `step()` method updates the PSO algorithm, "
"evaluates new candidate solutions on the Ackley function, and tracks their "
"fitness via the monitor."
msgstr ""
"我们运行优化过程一定次数的迭代（在这个例子中是100次）。在每次迭代中，`step()` "
"方法更新PSO算法，在Ackley函数上评估新的候选解，并通过监视器跟踪它们的适应度。"

#: ../../source/examples/so-algorithm.ipynb:150002
msgid ""
"Finally, we retrieve the [`monitor`](#StdWorkflow.get_submodule) submodule "
"from the workflow to access the top solutions found so far "
"(`topk_solutions`) and their corresponding objective values "
"(`topk_fitness`). We then print the best result and the associated solution."
msgstr ""
"最后，我们从工作流中检索 [`monitor`](#StdWorkflow.get_submodule) 子模块，以访问迄今为止找到的最佳解决方案 "
"(`topk_solutions`) 及其对应的目标值 (`topk_fitness`)。然后，我们打印出最佳结果及其相关的解决方案。"

#: ../../source/examples/supervised-learning.ipynb:10002
msgid "Neuroevolution for machine learning"
msgstr "机器学习的神经演化"

#: ../../source/examples/supervised-learning.ipynb:20002
msgid ""
"EvoX provides solutions for supervised learning tasks based on "
"neuroevolution, with key modules including "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem)"
" and [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)."
" Taking the MNIST classification task as an example, this section "
"illustrates the neuroevolution process for supervised learning by adopting "
"the modules of EvoX."
msgstr ""
"EvoX 提供基于神经演化的监督学习任务解决方案，关键模块包括 "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem)"
" 和 [`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)。以 "
"MNIST 分类任务为例，本节通过采用 EvoX 模块说明了用于监督学习的神经演化过程。"

#: ../../source/examples/supervised-learning.ipynb:30002
msgid "Basic Setup"
msgstr "基本设置"

#: ../../source/examples/supervised-learning.ipynb:40002
msgid ""
"Basic component imports and device configuration serve as the essential "
"starting steps for the neuroevolution process."
msgstr "神经演化过程的基本组件导入和设备配置是至关重要的起始步骤。"

#: ../../source/examples/supervised-learning.ipynb:40004
msgid ""
"Here, to ensure the reproducibility of results, a random seed can be "
"optionally set."
msgstr "在这里，为了确保结果的可重复性，可以选择性地设置一个随机种子。"

#: ../../source/examples/supervised-learning.ipynb:60002
msgid ""
"In this step, a sample convolutional neural network (CNN) model is directly "
"defined upon the PyTorch framework and then loaded onto the device."
msgstr "在此步骤中，样本卷积神经网络（CNN）模型直接基于PyTorch框架定义，然后加载到设备上。"

#: ../../source/examples/supervised-learning.ipynb:80002
msgid ""
"Setting dataset implies the selection of the task. The data loader now needs"
" to be initialized based on PyTorch's built-in support. Here, the package "
"`torchvision` must be installed in advance depending on your PyTorch "
"version, if it is not already available."
msgstr ""
"设置数据集意味着选择任务。现在需要基于PyTorch的内置支持初始化数据加载器。在这里，根据您的PyTorch版本，必须预先安装`torchvision`包，如果尚未安装的话。"

#: ../../source/examples/supervised-learning.ipynb:80005
msgid ""
"In case the MNIST dataset is not already present in the `data_root` "
"directory, the `download=True` flag is set to ensure that the dataset will "
"be automatically downloaded. Therefore, the setup may take some time during "
"the first run."
msgstr ""
"如果 `data_root` 目录中尚未存在 MNIST 数据集，则设置 `download=True` "
"标志以确保数据集将被自动下载。因此，第一次运行时设置可能需要一些时间。"

#: ../../source/examples/supervised-learning.ipynb:100002
msgid ""
"To accelerate subsequent processes, all MNIST data are pre-loaded for faster"
" execution. Below, three datasets are pre-loaded for different stages "
"&ndash; gradient descent training, neuroevolution fine-tuning, and model "
"testing."
msgstr ""
"为了加速后续过程，所有MNIST数据都被预加载以实现更快的执行。下面，三个数据集被预加载用于不同阶段——梯度下降训练、神经演化微调和模型测试。"

#: ../../source/examples/supervised-learning.ipynb:100004
msgid ""
"It should be noted that this is an optional operation that trades space for "
"time. Its adoption depends on your GPU capacity, and it will always take "
"some time to prepare."
msgstr "需要注意的是，这是一个可选操作，用空间换取时间。其采用取决于您的GPU容量，并且总是需要一些时间来准备。"

#: ../../source/examples/supervised-learning.ipynb:120002
msgid ""
"Here, a `model_test` function is pre-defined to simplify the evaluation of "
"the model's prediction accuracy on the test dataset during subsequent "
"stages."
msgstr "在这里，预先定义了一个 `model_test` 函数，以简化在后续阶段对模型在测试数据集上预测准确性的评估。"

#: ../../source/examples/supervised-learning.ipynb:140002
msgid "Gradient Descent Training (Optional)"
msgstr "梯度下降训练（可选）"

#: ../../source/examples/supervised-learning.ipynb:150002
msgid ""
"The gradient descent based model training is performed first. In this "
"example, this training is adopted to initialize the model, preparing it for "
"subsequent neuroevolution processes."
msgstr "基于梯度下降的模型训练首先进行。在这个例子中，这种训练用于初始化模型，为后续的神经演化过程做准备。"

#: ../../source/examples/supervised-learning.ipynb:150004
msgid ""
"The model training process in PyTorch is compatible with neuroevolution in "
"EvoX, making it convenient to reuse the same model implementation for "
"further steps."
msgstr "在EvoX中，PyTorch的模型训练过程与神经演化兼容，使得在后续步骤中重用相同的模型实现变得方便。"

#: ../../source/examples/supervised-learning.ipynb:180002
msgid "Neuroevolution Fine-Tuning"
msgstr "神经演化微调"

#: ../../source/examples/supervised-learning.ipynb:190002
msgid ""
"Based on the pre-trained model from the previous gradient descent process, "
"neuroevolution is progressively applied to fine-tune the model."
msgstr "基于之前梯度下降过程中的预训练模型，神经演化逐步应用于微调模型。"

#: ../../source/examples/supervised-learning.ipynb:190004
msgid ""
"First, the "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"component is used to flatten the weights of the pre-trained model into a "
"vector, which serves as the initial center individual for the subsequent "
"neuroevolution process."
msgstr ""
"首先，[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) "
"组件用于将预训练模型的权重展平为一个向量，该向量作为后续神经演化过程的初始中心个体。"

#: ../../source/examples/supervised-learning.ipynb:210002
msgid ""
"In case of algorithms specifically designed for neuroevolution, which can "
"directly accept a dictionary of batched parameters as input, the usage of "
"[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector) can "
"be unnecessary."
msgstr ""
"对于专门为神经演化设计的算法，它们可以直接接受批处理参数的字典作为输入，使用[`ParamsAndVector`](#evox.utils.parameters_and_vector.ParamsAndVector)可能是不必要的。"

#: ../../source/examples/supervised-learning.ipynb:220002
msgid ""
"Additionally, a sample criterion is defined. Here, both the loss and "
"accuracy of the individual model are selected and weighted to serve as the "
"fitness function in the neuroevolution process. This step is customizable to"
" suit the optimization direction."
msgstr "此外，定义了一个示例标准。在这里，个体模型的损失和准确性都被选择并加权，以作为神经演化过程中的适应度函数。此步骤可以自定义以适应优化方向。"

#: ../../source/examples/supervised-learning.ipynb:240002
msgid ""
"At the same time, similar to the gradient descent training and model testing"
" processes, the neuroevolution fine-tuning process is also encapsulated into"
" a function for convenient use in subsequent stages."
msgstr "同时，类似于梯度下降训练和模型测试过程，神经演化微调过程也被封装成一个函数，以便在后续阶段方便使用。"

#: ../../source/examples/supervised-learning.ipynb:260002
msgid "Population-Based Neuroevolution Test"
msgstr "种群基础的神经演化测试"

#: ../../source/examples/supervised-learning.ipynb:270002
msgid ""
"In this example, the population-based algorithm for neuroevolution is tested"
" first, using Particle Swarm Optimization "
"([PSO](#evox.algorithms.so.pso_variants.pso.PSO)) as a representation. The "
"configuration for neuroevolution is similar to that of other optimization "
"tasks &ndash; we need to define the problem, algorithm, monitor, and "
"workflow, along with their respective `setup()` functions to complete the "
"initialization."
msgstr ""
"在此示例中，基于种群的神经演化算法首先进行测试，使用粒子群优化（[PSO](#evox.algorithms.so.pso_variants.pso.PSO)）作为表示。神经演化的配置与其他优化任务类似——我们需要定义问题、算法、监视器和工作流，并结合它们各自的"
" `setup()` 函数来完成初始化。"

#: ../../source/examples/supervised-learning.ipynb:270004
msgid ""
"A key point to note here is that the population size (`POP_SIZE` in this "
"case) needs to be initialized in **both the problem and the algorithm** to "
"avoid potential errors."
msgstr "需要注意的一个关键点是，种群大小（在这种情况下为`POP_SIZE`）需要在**问题和算法**中都进行初始化，以避免潜在的错误。"

#: ../../source/examples/supervised-learning.ipynb:310002
msgid "Single-Individual Neuroveolution Test"
msgstr "单个个体神经演化测试"

#: ../../source/examples/supervised-learning.ipynb:320002
msgid ""
"Next, the single-individual algorithm based neuroevolution is tested. "
"Similar to the population-based case, we need to define the problem, "
"algorithm, monitor, and workflow, and call their respective `setup()` "
"functions during initialization. In this case, a random search strategy is "
"selected as the algorithm."
msgstr ""
"接下来，测试基于单个个体算法的神经演化。与基于种群的情况类似，我们需要定义问题、算法、监控器和工作流，并在初始化时调用它们各自的 `setup()` "
"函数。在这种情况下，选择随机搜索策略作为算法。"

#: ../../source/examples/supervised-learning.ipynb:320004
msgid ""
"A key point to note here is that "
"[`SupervisedLearningProblem`](#evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem)"
" should be set with `pop_size=None`, and [`EvalMonitor`](#EvalMonitor) "
"should have `topk=1`, as only a single individual is being searched. A "
"careful hyper-parameter setup helps avoid unnecessary issues."
msgstr ""
"需要注意的一个关键点是，[`SupervisedLearningProblem`](#evox.problems.neuroevolution.supervised_learning.SupervisedLearningProblem)"
" 应该设置为 `pop_size=None`，并且 [`EvalMonitor`](#EvalMonitor) 应设置为 "
"`topk=1`，因为这里仅搜索一个个体。谨慎的超参数设置有助于避免不必要的问题。"

#: ../../source/guide/developer/custom-alg-pro.md:1
msgid "Custom algorithms and problems in EvoX"
msgstr "EvoX中的自定义算法和问题"

#: ../../source/guide/developer/custom-alg-pro.md:3
msgid ""
"In this chapter, we will introduce how to implement your own algorithms and "
"problems in EvoX."
msgstr "在本章节中，我们将介绍如何在EvoX中实现您自己的算法和问题。"

#: ../../source/guide/developer/custom-alg-pro.md:5
msgid "Layout of the algorithms and problems"
msgstr "算法和问题的布局"

#: ../../source/guide/developer/custom-alg-pro.md:7
msgid ""
"In most traditional EC libraries, algorithms usually call the objective "
"function internally, which gives the following layout:"
msgstr "在大多数传统的进化计算（EC）库中，算法通常在内部调用目标函数，其布局如下："

#: ../../source/guide/developer/custom-alg-pro.md:15
msgid "**But in EvoX, we have a flat layout:**"
msgstr "但在 EvoX 中，我们使用了扁平化布局："

#: ../../source/guide/developer/custom-alg-pro.md:21
msgid ""
"This layout makes both algorithms and problems more universal: an algorithm "
"can optimize different problems, while a problem can also be suitable for "
"many algorithms."
msgstr "这种布局使得算法和问题更加通用：一个算法可以优化不同的问题，而一个问题也可以适用于许多算法。"

#: ../../source/guide/developer/custom-alg-pro.md:25
msgid "Algorithm class"
msgstr "Algorithm 类"

#: ../../source/guide/developer/custom-alg-pro.md:27
msgid ""
"The [`Algorithm`](#evox.core.components.Algorithm) class is inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"[`Algorithm`](#evox.core.components.Algorithm) 类继承自 "
"[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/custom-alg-pro.md:29
msgid ""
"**In total,** **there are 5 methods (2 methods are optional) that we need to"
" implement:**"
msgstr "总共有5个方法（其中2个方法是可选的）需要我们实现："

#: ../../source/guide/developer/custom-alg-pro.md
#: ../../source/guide/developer/custom-alg-pro.md:37
#: ../../source/guide/developer/modulebase.md:23
msgid "Method"
msgstr "方法"

#: ../../source/guide/developer/custom-alg-pro.md
#: ../../source/guide/developer/custom-alg-pro.md:37
#: ../../source/guide/developer/modulebase.md:23
msgid "Signature"
msgstr "签名"

#: ../../source/guide/developer/custom-alg-pro.md
#: ../../source/guide/developer/custom-alg-pro.md:37
#: ../../source/guide/developer/modulebase.md:23
msgid "Usage"
msgstr "使用情况"

#: ../../source/guide/developer/custom-alg-pro.md
#: ../../source/guide/developer/custom-alg-pro.md:37
#: ../../source/guide/developer/modulebase.md:23
msgid "`__init__`"
msgstr "`__init__`"

#: ../../source/guide/developer/custom-alg-pro.md
#: ../../source/guide/developer/custom-alg-pro.md:37
#: ../../source/guide/developer/modulebase.md:23
msgid "`(self, ...)`"
msgstr "`(self, ...)`"

#: ../../source/guide/developer/custom-alg-pro.md
msgid ""
"Initialize the algorithm instance, for example, the population size (keeps "
"constant during iteration), hyper-parameters (can only be set by HPO problem"
" wrapper or initialized here), and / or mutable tensors (can be modified on "
"the fly)."
msgstr ""
"初始化算法实例，例如，种群大小（在迭代过程中保持不变）、超参数（只能通过HPO问题包装器设置或在此初始化）、和/或可变张量（可以动态修改）。"

#: ../../source/guide/developer/custom-alg-pro.md
msgid "`step`"
msgstr "步骤"

#: ../../source/guide/developer/custom-alg-pro.md
msgid "`(self)`"
msgstr "`(self)"

#: ../../source/guide/developer/custom-alg-pro.md
msgid "Perform a normal optimization iteration step of the algorithm."
msgstr "执行算法的正常优化迭代步骤。"

#: ../../source/guide/developer/custom-alg-pro.md
msgid "`init_step` (optional)"
msgstr "`init_step`（可选）"

#: ../../source/guide/developer/custom-alg-pro.md
msgid ""
"Perform the first step of the optimization of the algorithm. If this method "
"were not overwritten, the `step` method would be invoked instead."
msgstr "执行算法优化的第一步。如果此方法未被覆盖，将调用 `step` 方法。"

#: ../../source/guide/developer/custom-alg-pro.md:38
msgid ""
"The static initialization can still be written in the `__init__` while the "
"mutable submodule(s) initialization cannot. Therefore, multiple calls of "
"`setup` for repeated initializations are possible if the overwritten `setup`"
" method invokes the `setup()` of "
"[`ModuleBase`](#evox.core.module.ModuleBase) first."
msgstr ""
"静态初始化仍然可以在`__init__`中编写，而可变子模块的初始化则不能。因此，如果重写的`setup`方法首先调用[`ModuleBase`](#evox.core.module.ModuleBase)的`setup()`，则可以多次调用`setup`进行重复初始化。"

#: ../../source/guide/developer/custom-alg-pro.md:40
msgid ""
"If such `setup` method in [`ModuleBase`](#evox.core.module.ModuleBase) is "
"not suitable for your algorithm, you can override the `setup` method when "
"you create your own algorithm class."
msgstr ""
"如果在[`ModuleBase`](#evox.core.module.ModuleBase)中的这种`setup`方法不适合你的算法，你可以在创建自己的算法类时重写`setup`方法。"

#: ../../source/guide/developer/custom-alg-pro.md:44
msgid "Problem class"
msgstr "问题类"

#: ../../source/guide/developer/custom-alg-pro.md:46
msgid ""
"The [`Problem`](#evox.core.components.Problem) class is also inherited from "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"[`Problem`](#evox.core.components.Problem) 类也继承自 "
"[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/custom-alg-pro.md:48
msgid ""
"However, the Problem class is quite simple. **Beside the `__init__` method, "
"the only necessary method is the `evaluate` method.**"
msgstr "但是，Problem 类非常简单。**除了 `__init__` 方法，唯一必须的方法是 `evaluate` 方法。**"

#: ../../source/guide/developer/custom-alg-pro.md:37
msgid "Initialize the settings of the problem."
msgstr "为问题初始化设置。"

#: ../../source/guide/developer/custom-alg-pro.md:37
msgid "`evaluate`"
msgstr "评估"

#: ../../source/guide/developer/custom-alg-pro.md:37
msgid "`(self, pop: torch.Tensor) -> torch.Tensor`"
msgstr "`(self, pop: torch.Tensor) -> torch.Tensor"

#: ../../source/guide/developer/custom-alg-pro.md:37
msgid "Evaluate the fitness of the given population."
msgstr "评估给定种群的适应度。"

#: ../../source/guide/developer/custom-alg-pro.md:55
msgid ""
"However, the type of `pop` argument in `evaluate` can be changed to other "
"JIT-compatible types in the overwritten method."
msgstr "然而，在重写的方法中，`evaluate` 中 `pop` 参数的类型可以更改为其他与 JIT 兼容的类型。"

#: ../../source/guide/developer/custom-alg-pro.md:58
#: ../../source/guide/developer/document.md:25
msgid "Example"
msgstr "样例"

#: ../../source/guide/developer/custom-alg-pro.md:60
msgid ""
"Here we give an example of **implementing a PSO algorithm that solves the "
"Sphere problem**."
msgstr "这里我们给出一个**实现一个解决Sphere问题的PSO算法的例子**。"

#: ../../source/guide/developer/custom-alg-pro.md:62
msgid "Pseudo-code of the example"
msgstr "示例的伪代码"

#: ../../source/guide/developer/custom-alg-pro.md:64
msgid "Here is a pseudo-code:"
msgstr "以下是一段伪代码："

#: ../../source/guide/developer/custom-alg-pro.md:80
msgid ""
"And here is what each part of the algorithm and the problem corresponds to "
"in EvoX."
msgstr "以下是算法和问题中每个部分在EvoX中的对应关系。"

#: ../../source/guide/developer/custom-alg-pro.md:100
msgid ""
"Particle Swarm Optimization (PSO) is a population-based meta-heuristic "
"algorithm inspired by the social behavior of birds and fish. It is widely "
"used for solving continuous and discrete optimization problems."
msgstr "粒子群优化（PSO）是一种基于种群的元启发式算法，灵感来自鸟类和鱼类的社会行为。它被广泛用于解决连续和离散优化问题。"

#: ../../source/guide/developer/custom-alg-pro.md:210
msgid "Now, you can initiate a workflow and run it."
msgstr "现在，您可以启动一个工作流并运行它。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10002
msgid "Deploy HPO with Custom Algorithms"
msgstr "部署具有自定义算法的HPO"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:10004
msgid ""
"In this chapter, we will focus on deploying HPO with custom algorithms, "
"emphasizing the details rather than the overall workflow. A brief "
"introduction to HPO deployment is provided in the "
"[tutorial](#/tutorial/tutorial_part7), and prior reading is highly "
"recommended."
msgstr ""
"在本章中，我们将重点讲解如何使用自定义算法部署 HPO，强调细节而非整体工作流。[教程](#/tutorial/tutorial_part7)中提供了 "
"HPO 部署的简要介绍，非常建议先行阅读。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20002
msgid "Making Algorithms Parallelizable"
msgstr "使算法可并行化"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20004
msgid ""
"Since we need to transform the inner algorithm into the problem, it's "
"crucial that the inner algorithm is parallelizable. Therefore, some "
"modifications to the algorithm may be necessary."
msgstr "由于我们需要将内部算法转化为问题，确保内部算法是可并行化的至关重要。因此，可能需要对算法进行一些修改。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20006
msgid ""
"The algorithm should have no methods with in-place operations on the "
"attributes of the algorithm itself."
msgstr "算法不应有对其自身属性进行就地操作的方法。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:20020
msgid "The code logic does not rely on python control flow."
msgstr "代码逻辑不依赖于 python 控制流。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30002
msgid "Utilizing the HPOMonitor"
msgstr "利用 HPOMonitor"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30004
msgid ""
"In the HPO task, we should use the [`HPOMonitor`](#HPOMonitor) to track the "
"metrics of each inner algorithm. The [`HPOMonitor`](#HPOMonitor) adds only "
"one method, `tell_fitness`, compared to the standard [`monitor`](#Monitor). "
"This addition is designed to offer greater flexibility in evaluating "
"metrics, as HPO tasks often involve multi-dimensional and complex metrics."
msgstr ""
"在HPO任务中，我们应该使用[`HPOMonitor`](#HPOMonitor)来跟踪每个内部算法的指标。与标准的[`monitor`](#Monitor)相比，[`HPOMonitor`](#HPOMonitor)仅增加了一个方法，`tell_fitness`。此添加旨在提供更大的灵活性来评估指标，因为HPO任务通常涉及多维和复杂的指标。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30006
msgid ""
"Users only need to create a subclass of [`HPOMonitor`](#HPOMonitor) and "
"override the `tell_fitness` method to define custom evaluation metrics."
msgstr "用户只需创建一个[`HPOMonitor`](#HPOMonitor)的子类，并重写`tell_fitness`方法以定义自定义评估指标。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:30008
msgid ""
"We also provide a simple [`HPOFitnessMonitor`](#HPOFitnessMonitor), which "
"supports calculating the 'IGD' and 'HV' metrics for multi-objective "
"problems, and the minimum value for single-objective problems."
msgstr ""
"我们还提供了一个简单的[`HPOFitnessMonitor`](#HPOFitnessMonitor)，支持计算多目标问题的“IGD”和“HV”指标，以及单目标问题的最小值。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40004
msgid ""
"Here, we'll demonstrate a simple example of how to use HPO with EvoX. We "
"will use the [`PSO`](#PSO) algorithm to search for the optimal hyper-"
"parameters of a basic algorithm to solve the sphere problem."
msgstr ""
"在这里，我们将演示如何使用 EvoX 进行 HPO 的简单示例。我们将使用 [`PSO`](#PSO) 算法来搜索基本算法的最佳超参数，以解决球体问题。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:40006
msgid "First, let's import the necessary modules."
msgstr "首先，让我们导入必要的模块。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:60002
msgid ""
"Next, we define an simple sphere problem. Note that this has no difference "
"from the common [`problems`](#evox.problems)."
msgstr "接下来，我们定义一个简单的球体问题。请注意，这与常见的[`problems`](#evox.problems)没有区别。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:80002
msgid ""
"Next, we define the algorithm, we use the "
"[`torch.cond`](#https://pytorch.org/docs/stable/generated/torch.cond.html) "
"function and make sure it is parallelizable. Specifically, we modify in-"
"place operations and adjust the Python control flow."
msgstr ""
"接下来，我们定义算法，我们使用 "
"[`torch.cond`](#https://pytorch.org/docs/stable/generated/torch.cond.html) "
"函数并确保它是可并行化的。具体来说，我们修改原地操作并调整 Python 控制流。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:100002
msgid ""
"To handle the Python control flow, we use "
"[`torch.cond`](https://pytorch.org/docs/stable/generated/torch.cond.html), "
"next, we can use the [`StdWorkflow`](#StdWorkflow) to wrap the "
"[`problem`](#evox.problems), [`algorithm`](#evox.algorithms) and "
"[`monitor`](#Monitor). Then we use the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) to transform the "
"[`StdWorkflow`](#StdWorkflow) to HPO problem."
msgstr ""
"为了处理 Python 控制流，我们使用 "
"[`torch.cond`](https://pytorch.org/docs/stable/generated/torch.cond.html)。接下来，我们可以使用"
" [`StdWorkflow`](#StdWorkflow) 来包装 "
"[`problem`](#evox.problems)、[`algorithm`](#evox.algorithms) 和 "
"[`monitor`](#Monitor)。然后我们使用 [`HPOProblemWrapper`](#HPOProblemWrapper) 将 "
"[`StdWorkflow`](#StdWorkflow) 转换为 HPO 问题。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:120002
msgid ""
"We can test whether the [`HPOProblemWrapper`](#HPOProblemWrapper) correctly "
"recognizes the hyper-parameters we defined. Since we have made no "
"modifications to the hyper-parameters for the 7 instances, they should be "
"identical across all instances."
msgstr ""
"我们可以测试 [`HPOProblemWrapper`](#HPOProblemWrapper) "
"是否正确识别了我们定义的超参数。由于我们没有对7个实例的超参数进行修改，它们在所有实例中应该是相同的。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:140002
msgid ""
"We can also specify our own set of hyperparameter values. Note that the "
"number of hyperparameter sets must match the number of instances in the "
"[`HPOProblemWrapper`](#HPOProblemWrapper). The custom hyper-parameters "
"should be provided as a dictionary whose values are wrapped in the "
"[`Parameter`](#Parameter)."
msgstr ""
"我们也可以指定自己的一组超参数值。请注意，超参数集的数量必须与[`HPOProblemWrapper`](#HPOProblemWrapper)中的实例数量相匹配。自定义超参数应作为字典提供，其值被包装在[`Parameter`](#Parameter)中。"

#: ../../source/guide/developer/custom_hpo_prob.ipynb:160002
msgid ""
"Now, we use the [`PSO`](#PSO) algorithm to optimize the hyper-parameters of "
"`ExampleAlgorithm`. Note that the population size of the [`PSO`](#PSO) must "
"match the number of instances; otherwise, unexpected errors may occur. In "
"this case, we need to transform the solution in the outer workflow, as the "
"[`HPOProblemWrapper`](#HPOProblemWrapper) requires a dictionary as input."
msgstr ""
"现在，我们使用[`PSO`](#PSO)算法来优化`ExampleAlgorithm`的超参数。请注意，[`PSO`](#PSO)的种群大小必须与实例数量匹配，否则可能会发生意外错误。在这种情况下，我们需要在外部工作流中转换解决方案，因为[`HPOProblemWrapper`](#HPOProblemWrapper)需要一个字典作为输入。"

#: ../../source/guide/developer/document.md:1
msgid "Document Writing Guide"
msgstr "文档编写指南"

#: ../../source/guide/developer/document.md:3
msgid ""
"This guide outlines best practices for writing and maintaining documentation"
" across the codebase and supplementary files."
msgstr "本指南概述了在代码库及补充文件中书写和维护文档的最佳实践。"

#: ../../source/guide/developer/document.md:7
msgid "In-Code Documentation (Docstrings)"
msgstr "In-Code Documentation (Docstrings)"

#: ../../source/guide/developer/document.md:9
msgid ""
"Docstrings are essential for understanding the purpose, usage, and behavior "
"of your code. Please adhere to the following conventions:"
msgstr "文档字符串对于理解代码的目的、用法和行为至关重要。请遵守以下约定："

#: ../../source/guide/developer/document.md:11
msgid "General Rules"
msgstr "一般规则"

#: ../../source/guide/developer/document.md:13
msgid ""
"Document **all public classes, methods, and functions** using docstrings."
msgstr "文档 **所有公共类、方法和函数** 使用 docstrings。"

#: ../../source/guide/developer/document.md:14
msgid "Use **Sphinx-style** docstrings."
msgstr "使用 **Sphinx-style** 文档字符串。"

#: ../../source/guide/developer/document.md:15
msgid ""
"**Do not** include parameter types in the docstring—they are expected to be "
"declared in the function signature using type hints."
msgstr "不要在docstring中包含参数类型——它们应使用类型提示在函数签名中声明。"

#: ../../source/guide/developer/document.md:17
msgid "Format and Directives"
msgstr "Format and Directives"

#: ../../source/guide/developer/document.md:19
msgid "Use the following directives to describe different elements:"
msgstr "使用以下指令来描述不同元素："

#: ../../source/guide/developer/document.md:21
msgid "`:param <name>:` — Describe a parameter."
msgstr "`:param <name>:` — 描述一个参数。"

#: ../../source/guide/developer/document.md:22
msgid "`:return:` — Describe the return value."
msgstr ":return: — 描述返回值。"

#: ../../source/guide/developer/document.md:23
msgid "`:raises <exception>:` — Describe exceptions the function might raise."
msgstr "`:raises <exception>:` — 描述函数可能引发的异常。"

#: ../../source/guide/developer/document.md:44
msgid "External Documentation (`docs/` Directory)"
msgstr "外部文档 (`docs/` 目录)"

#: ../../source/guide/developer/document.md:46
msgid ""
"All project-level documentation is located in the `docs/` directory. These "
"documents support both users and developers by providing guides, examples, "
"and references."
msgstr "所有项目级文档都位于 `docs/` 目录中。这些文档通过提供指南、示例和参考资料，为用户和开发者提供支持。"

#: ../../source/guide/developer/document.md:48
msgid "Format"
msgstr "格式"

#: ../../source/guide/developer/document.md:50
msgid ""
"Use **Markdown (`.md`)** or **Jupyter Notebooks (`.ipynb`)** for "
"documentation."
msgstr " **Markdown (`.md`)** 或 **Jupyter Notebooks (`.ipynb`)** 进行文档编写。"

#: ../../source/guide/developer/document.md:51
msgid "Markdown is preferred for narrative content and static documentation."
msgstr "Markdown 更适合用于叙述性内容和静态文档。"

#: ../../source/guide/developer/document.md:52
msgid ""
"Use Jupyter Notebooks for executable, interactive content (e.g., tutorials "
"or demos)."
msgstr "使用 Jupyter Notebooks 创建可执行的交互式内容（例如教程或演示）。"

#: ../../source/guide/developer/document.md:54
msgid "Jupyter Notebook Guidelines"
msgstr "Jupyter Notebook 指南"

#: ../../source/guide/developer/document.md:56
msgid "Ensure all notebooks are **fully executable**."
msgstr "确保所有笔记本都**完全可执行**。"

#: ../../source/guide/developer/document.md:57
msgid "Always **run all cells** and **save the output** before committing."
msgstr "始终**运行所有单元格**并**保存输出**再提交。"

#: ../../source/guide/developer/document.md:58
msgid ""
"Our CI/CD environment does **not support GPU execution**, so notebooks must "
"be pre-executed locally."
msgstr "我们的CI/CD环境**不支持GPU执行**，因此笔记本文件必须在本地预先执行。"

#: ../../source/guide/developer/document.md:60
msgid "Markdown & Notebook Directives"
msgstr "Markdown & Notebook Directives"

#: ../../source/guide/developer/document.md:62
msgid "Use the following patterns for rich formatting:"
msgstr "使用以下模式进行丰富格式化:"

#: ../../source/guide/developer/document.md:64
msgid ""
"`[name](#ref)` — Internal cross-reference, e.g., "
"`[ModuleBase](#evox.core.module.ModuleBase)` or `[ModuleBase](#ModuleBase)`"
msgstr ""
"`[name](#ref)` — 内部交叉引用，例如 `[ModuleBase](#evox.core.module.ModuleBase)` 或 "
"`[ModuleBase](#ModuleBase)`"

#: ../../source/guide/developer/document.md:65
msgid ""
"`![Alt Text](path)` — Embed images, e.g., `![Module "
"base](/_static/modulebase.png)`"
msgstr "`![替代文本](path)` — 嵌入图片，例如，`![Module base](/_static/modulebase.png)`"

#: ../../source/guide/developer/document.md:69
msgid "Translation"
msgstr "翻译"

#: ../../source/guide/developer/document.md:71
msgid ""
"The documentation supports multilingual content. Follow the steps below to "
"update or generate translations."
msgstr "文档支持多语言内容。按照以下步骤更新或生成翻译。"

#: ../../source/guide/developer/document.md:73
msgid "Updating Translations (e.g., for `zh_CN`)"
msgstr "更新翻译（例如，针对 `zh_CN`）"

#: ../../source/guide/developer/environment.md:1
msgid "Develop environment"
msgstr "开发环境"

#: ../../source/guide/developer/environment.md:3
msgid "Clone the repository and install it in editable mode (recommended)"
msgstr "克隆仓库并以可编辑模式安装（推荐）"

#: ../../source/guide/developer/environment.md:11
msgid "Nix"
msgstr "Nix"

#: ../../source/guide/developer/environment.md:13
msgid "Enable the Nix environment by running the following command:"
msgstr "启用 Nix 环境，请运行以下命令："

#: ../../source/guide/developer/environment.md:17
msgid ""
"This will create a shell with all the necessary dependencies and a `.venv` "
"directory with the Python environment."
msgstr "这将创建一个包含所有必要依赖项的 shell 和一个带有 Python 环境的 `.venv` 目录。"

#: ../../source/guide/developer/environment.md:19
msgid "Style guide"
msgstr "样式指南"

#: ../../source/guide/developer/environment.md:21
msgid "EvoX's has the following style guide:"
msgstr "EvoX 的风格指南如下:"

#: ../../source/guide/developer/environment.md:22
msgid ""
"Make sure to use [ruff](https://docs.astral.sh/ruff/) to lint your code."
msgstr "确保使用 [ruff](https://docs.astral.sh/ruff/) 来检查你的代码。"

#: ../../source/guide/developer/environment.md:23
msgid "Make sure there are no trailing whitespaces."
msgstr "请确保没有尾随空格。"

#: ../../source/guide/developer/environment.md:25
msgid "Pre-commit"
msgstr "预提交"

#: ../../source/guide/developer/environment.md:27
msgid ""
"We recommend using [pre-commit](https://pre-commit.com/) to enforce the "
"style guide. After installing pre-commit, run the following command to "
"install the hooks in your local repository:"
msgstr ""
"我们建议使用 [pre-commit](https://pre-commit.com/) 来强制执行样式指南。安装 pre-commit "
"后，运行以下命令在本地仓库中安装钩子："

#: ../../source/guide/developer/environment.md:33
msgid "Run Unit Test"
msgstr "运行单元测试"

#: ../../source/guide/developer/environment.md:35
msgid ""
"prepare the test environment by installing the required packages (e.g., "
"`torch`) in your Python environment"
msgstr "在您的 Python 环境中安装所需的包（例如，`torch`）以准备测试环境。"

#: ../../source/guide/developer/environment.md:36
msgid "run unittest:"
msgstr "请运行单元测试："

#: ../../source/guide/developer/index.md:1
msgid "Developer Guide"
msgstr "开发者指引"

#: ../../source/guide/developer/modulebase.md:1
msgid "Working with Module in EvoX"
msgstr "在 EvoX 中使用模块"

#: ../../source/guide/developer/modulebase.md:3
msgid ""
"A **module** is a fundamental concept in programming that refers to a self-"
"contained unit of code designed to perform a specific task or a set of "
"related tasks."
msgstr "一个**模块**是编程中的一个基本概念，指的是一个自包含的代码单元，旨在执行特定任务或一组相关任务。"

#: ../../source/guide/developer/modulebase.md:5
msgid ""
"This notebook will introduce the basic module in EvoX: "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr "此笔记本将介绍 EvoX 中的基本模块：[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/modulebase.md:7
msgid "Introduction to Module"
msgstr "模块介绍"

#: ../../source/guide/developer/modulebase.md:9
msgid ""
"In the [tutorial](#/tutorial/index), we have mentioned the basic running "
"process in EvoX:"
msgstr "在[教程](#/tutorial/index)中，我们提到了EvoX中的基本运行流程："

#: ../../source/guide/developer/modulebase.md:13
msgid "This process requires four basic class in EvoX:"
msgstr "在EvoX中，此过程需要四个基本类："

#: ../../source/guide/developer/modulebase.md:15
msgid "[`Algorithm`](#evox.core.components.Algorithm)"
msgstr "[`Algorithm`](#evox.core.components.Algorithm)"

#: ../../source/guide/developer/modulebase.md:16
msgid "[`Problem`](#evox.core.components.Problem)"
msgstr "[`Problem`](#evox.core.components.Problem)"

#: ../../source/guide/developer/modulebase.md:17
msgid "[`Monitor`](#evox.core.components.Monitor)"
msgstr "[`Monitor`](#evox.core.components.Monitor)"

#: ../../source/guide/developer/modulebase.md:18
msgid "[`Workflow`](#evox.core.components.Workflow)"
msgstr "[`Workflow`](#evox.core.components.Workflow)"

#: ../../source/guide/developer/modulebase.md:21
msgid ""
"It is necessary to provide a unified module for them. In EvoX, the four "
"classes are all inherited from the base module — "
"[`ModuleBase`](#evox.core.module.ModuleBase)."
msgstr ""
"有必要为它们提供一个统一的模块。在EvoX中，这四个类都继承自基础模块——[`ModuleBase`](#evox.core.module.ModuleBase)。"

#: ../../source/guide/developer/modulebase.md:23
msgid "Module base"
msgstr "模块 base"

#: ../../source/guide/developer/modulebase.md:28
msgid "ModuleBase class"
msgstr "ModuleBase 类"

#: ../../source/guide/developer/modulebase.md:30
msgid ""
"The [`ModuleBase`](#evox.core.module.ModuleBase) class is inherited from "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)."
msgstr ""
"[`ModuleBase`](#evox.core.module.ModuleBase) 类继承自 "
"[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#)。"

#: ../../source/guide/developer/modulebase.md:32
msgid ""
"There are many methods in this class, and some important methods are here:"
msgstr "在这个类中有许多方法，这里是一些重要的方法："

#: ../../source/guide/developer/modulebase.md:23
msgid "Initialize the module."
msgstr "初始化模块。"

#: ../../source/guide/developer/modulebase.md:23
msgid "`load_state_dict`"
msgstr "`load_state_dict"

#: ../../source/guide/developer/modulebase.md:23
msgid ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)`"
msgstr ""
"`(self, state_dict: Mapping[str, torch.Tensor], copy: bool = False, ...)"

#: ../../source/guide/developer/modulebase.md:23
msgid ""
"Copy parameters and buffers from `state_dict` into this module and its "
"descendants. It overwrites "
"[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)."
msgstr ""
"将`state_dict`中的参数和缓冲区复制到此模块及其子模块中。它会覆盖[`torch.nn.Module.load_state_dict`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.load_state_dict)。"

#: ../../source/guide/developer/modulebase.md:23
msgid "`add_mutable`"
msgstr "`add_mutable"

#: ../../source/guide/developer/modulebase.md:23
msgid ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None`"
msgstr ""
"`(self, name: str, value: Union[torch.Tensor | nn.Module, "
"Sequence[torch.Tensor | nn.Module], Dict[str, torch.Tensor | nn.Module]]) ->"
" None"

#: ../../source/guide/developer/modulebase.md:23
msgid ""
"Define a mutable value in this module that can be accessed via `self.[name]`"
" and modified in-place."
msgstr "定义一个可变值，并将其在 `self.[name]` 中暴露出来，可以通过 `self.[name] = [值]` 来修改。"

#: ../../source/guide/developer/modulebase.md:40
msgid "Role of Module"
msgstr "模块的作用"

#: ../../source/guide/developer/modulebase.md:42
msgid ""
"In EvoX, the [`ModuleBase`](#evox.core.module.ModuleBase) could help to:"
msgstr "在 EvoX 中，[`ModuleBase`](#evox.core.module.ModuleBase) 可以帮助："

#: ../../source/guide/developer/modulebase.md:44
msgid "**Contain mutable values**"
msgstr "**包含可变值**"

#: ../../source/guide/developer/modulebase.md:46
msgid ""
"​\tThis module is an object-oriented one that can contain mutable values."
msgstr "该模块是一个面向对象的模块，可以包含可变值。"

#: ../../source/guide/developer/modulebase.md:48
msgid "**Support functional programming**"
msgstr "**支持函数式编程**"

#: ../../source/guide/developer/modulebase.md:50
msgid ""
"​\tFunctional programming model is supported via `self.state_dict()` and "
"`self.load_state_dict(...)`."
msgstr "支持函数式编程模型通过 `self.state_dict()` 和 `self.load_state_dict(...)"

#: ../../source/guide/developer/modulebase.md:52
msgid "**Standardize the initialization**:"
msgstr "**标准化初始化**:"

#: ../../source/guide/developer/modulebase.md:54
msgid ""
"​\tBasically, predefined submodule(s) which will be ADDED to this module and"
" accessed later in member method(s) should be treated as \"non-static "
"members\", while any other member(s) should be treated as \"static "
"members\"."
msgstr "基本上，预定义的子模块将被添加到此模块中，并在成员方法中访问，应该被视为“非静态成员”，而其他任何成员都应该被视为“静态成员”。"

#: ../../source/guide/developer/modulebase.md:56
msgid ""
"​\tThe module initialization for non-static members are recommended to be "
"written in the overwritten method of `setup` (or any other member method) "
"rather than `__init__`."
msgstr "建议将非静态成员的模块初始化写在重写的 `setup` 方法（或任何其他成员方法）中，而不是 `__init__` 中。"

#: ../../source/guide/developer/modulebase.md:58
msgid "Usage of Module"
msgstr "模块使用"

#: ../../source/guide/developer/modulebase.md:60
msgid ""
"Specifically, there are some rules for using "
"[`ModuleBase`](#evox.core.module.ModuleBase) in EvoX:"
msgstr "具体来说，在EvoX中使用[`ModuleBase`](#evox.core.module.ModuleBase)有一些规则："

#: ../../source/guide/developer/modulebase.md:62
msgid "Static methods"
msgstr "静态方法"

#: ../../source/guide/developer/modulebase.md:64
msgid "Static methods to be JIT shall be defined like:"
msgstr "要将静态方法定义为JIT，请这样定义："

#: ../../source/guide/developer/modulebase.md:73
msgid "Non-static Methods"
msgstr "非静态方法"

#: ../../source/guide/developer/modulebase.md:75
msgid ""
"If a method with python dynamic control flows like `if` were to be used with"
" `vmap`, please use "
"[`torch.cond`](https://pytorch.org/docs/main/generated/torch.cond.html#torch.cond)"
" to explicitly define the control flow."
msgstr ""
"如果在使用 `vmap` 时需要使用带有 Python 动态控制流（例如 `if`）的方法，请使用 "
"[`torch.cond`](https://pytorch.org/docs/main/generated/torch.cond.html#torch.cond)"
" 明确定义控制流。"

#: ../../source/guide/experimental/distributed_workflow.md:1
msgid "Multi-GPU and Distributed Workflow"
msgstr "多GPU和分布式工作流"

#: ../../source/guide/experimental/distributed_workflow.md:3
msgid ""
"EvoX has experimental support for distributed workflows, allowing you to run"
" any normal evolutionary algorithms across multiple GPUs or even multiple "
"machines. This can significantly speed up the optimization process, "
"especially for time-consuming problems."
msgstr ""
"EvoX 对分布式工作流提供了实验性支持，允许您在多个 GPU 甚至多个机器上运行任何常规的演化算法。这可以显著加速优化过程，尤其是对于耗时的问题。"

#: ../../source/guide/experimental/distributed_workflow.md:5
msgid "How to use"
msgstr "如何使用"

#: ../../source/guide/experimental/distributed_workflow.md:7
msgid "To use the distributed workflow, you need to set up a few things:"
msgstr "要使用分布式工作流，你需要设置以下内容："

#: ../../source/guide/experimental/distributed_workflow.md:8
msgid ""
"Make sure you have manually fix the seed of the random number generator."
msgstr "请确保您已手动固定随机数生成器的种子。"

#: ../../source/guide/experimental/distributed_workflow.md:17
msgid ""
"Make sure to set the seed for all random number generators **before** any "
"torch or numpy operations. This ensures that the random number generator is "
"in a known state before any operations are performed."
msgstr ""
"确保在执行任何 torch 或 numpy 操作**之前**为所有随机数生成器设置种子。这可以确保在执行任何操作之前，随机数生成器处于一个已知状态。"

#: ../../source/guide/experimental/distributed_workflow.md:19
msgid ""
"Use the `torch.distributed` or `torchrun` command to launch your script. For"
" example:"
msgstr "使用 `torch.distributed` 或 `torchrun` 命令来启动您的脚本。例如："

#: ../../source/guide/experimental/distributed_workflow.md:28
msgid ""
"`torchrun` is the recommended way to launch distributed torch programs. For "
"more information, see the [PyTorch "
"documentation](https://pytorch.org/docs/stable/elastic/run.html)."
msgstr ""
"`torchrun` 是推荐用来启动分布式 torch 程序的方式。更多信息请参阅 [PyTorch "
"文档](https://pytorch.org/docs/stable/elastic/run.html)。"

#: ../../source/guide/experimental/index.md:1
msgid "Experimental Features"
msgstr "实验性功能"

#: ../../source/guide/install/index.md:1
msgid "Installation Guide"
msgstr "安装教程"

#: ../../source/guide/install/python.md:1
msgid "Python Installation Guide"
msgstr "Python安装教程"

#: ../../source/guide/install/python.md:3
msgid ""
"This guide is for those who are new to the Python programming language and "
"want to install it on their system. It will help you set up the Python "
"environment needed to run EvoX."
msgstr "本指南适用于对Python编程语言不熟悉并希望在其系统上安装它的用户。它将帮助您设置运行EvoX所需的Python环境。"

#: ../../source/guide/install/python.md:7
msgid ""
"EvoX is written in Python, so you will need to have Python installed on your"
" system. EvoX support Python 3.10 and above, and we recommend using the "
"**latest version** of Python."
msgstr ""
"EvoX 是用 Python 编写的，因此您需要在系统上安装 Python。EvoX 支持 Python 3.10 及以上版本，我们推荐使用 "
"**最新版本** 的 Python。"

#: ../../source/guide/install/python.md:11
msgid "Install Python interpreter"
msgstr "安装 Python 解释器"

#: ../../source/guide/install/python.md:13
msgid "Windows Version"
msgstr "Windows 版本"

#: ../../source/guide/install/python.md:15
msgid ""
"Go to [Download Python](https://www.python.org/downloads/) and download the "
"latest version of Python."
msgstr "访问[Download Python](https://www.python.org/downloads/) 来下载最新版的Python。"

#: ../../source/guide/install/python.md:18
msgid ""
"Make sure to check the box that says \"Add Python to PATH\" during the "
"installation process."
msgstr "请确保在安装的过程中勾选\"Add Python to PATH\"这个选项。"

#: ../../source/guide/install/python.md:21
msgid "Linux Version"
msgstr "Linux 版本"

#: ../../source/guide/install/python.md:23
msgid ""
"Different Linux distributions have different ways to install Python. It "
"depends on the package manager of your distribution. Here are some examples:"
msgstr "不同的Linux发行版有不同的安装Python的方式。这取决于发行版所用的包管理器。这里有些例子："

#: ../../source/guide/install/python.md:26
msgid "Debian/Ubuntu: `apt`"
msgstr "Debian/Ubuntu: `apt"

#: ../../source/guide/install/python.md:27
msgid "Archlinux: `pacman`"
msgstr "Archlinux: `pacman"

#: ../../source/guide/install/python.md:28
msgid "Fedora: `dnf`"
msgstr "Fedora: `dnf"

#: ../../source/guide/install/python.md:30
msgid "Install through `uv`"
msgstr "通过 `uv` 安装"

#: ../../source/guide/install/python.md:32
msgid ""
"`uv` is an extremely fast Python package and project manager, is working on "
"Windows, Linux and MacOS. We recommend using `uv` to install Python "
"interpreter as well as managing Python environments. The detailed "
"installation guide can be found in the [uv installation "
"guide](https://docs.astral.sh/uv/getting-started/installation/#installation-"
"methods)."
msgstr ""
"`uv` 是一个极快的 Python 包和项目管理工具，可以在 Windows、Linux 和 MacOS 上运行。我们推荐使用 `uv` 来安装 "
"Python 解释器以及管理 Python 环境。详细的安装指南可以参考 [uv "
"安装指南](https://docs.astral.sh/uv/getting-started/installation/#installation-"
"methods)。"

#: ../../source/guide/install/python.md:36
#, python-brace-format
msgid ""
"::::{tab-set} :::{tab-item} Windows Use `irm` to download the script and "
"execute it with `iex`:"
msgstr ""
"::::{tab-set}  \n"
":::{tab-item} Windows  \n"
"使用 `irm` 下载脚本并使用 `iex` 执行：  "

#: ../../source/guide/install/python.md:44
msgid ""
"Changing the [execution policy](https://learn.microsoft.com/en-"
"us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.4#powershell-"
"execution-policies) allows running a script from the internet."
msgstr ""
"更改 [execution policy](https://learn.microsoft.com/en-"
"us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.4#powershell-"
"execution-policies) 允许运行来自互联网的脚本。"

#: ../../source/guide/install/python.md:46
#: ../../source/guide/install/python.md:67
msgid "Request a specific version by including it in the URL:"
msgstr "通过在 URL 中包含特定版本来请求："

#: ../../source/guide/install/python.md:52
#: ../../source/guide/install/python.md:72
msgid ":::"
msgstr "请提供需要翻译的文本，我会根据您的要求进行翻译。"

#: ../../source/guide/install/python.md:54
#, python-brace-format
msgid ""
":::{tab-item} Linux and MacOS Use `curl` to download the script and execute "
"it with `sh`:"
msgstr ""
"::: {tab-item} Linux 和 MacOS  \n"
"使用 `curl` 下载脚本并通过 `sh` 执行：  "

#: ../../source/guide/install/python.md:61
msgid "If your system doesn't have `curl`, you can use `wget`:"
msgstr "如果您的系统没有 `curl`，您可以使用 `wget`："

#: ../../source/guide/install/python.md:74
msgid "::::"
msgstr "请复制文本并提供给我，我将按照您的要求进行翻译。"

#: ../../source/guide/install/python.md:76
msgid "Managing Python Environments"
msgstr "管理Python环境"

#: ../../source/guide/install/python.md:78
msgid "Pip and Venv"
msgstr "Pip and Venv"

#: ../../source/guide/install/python.md:80
msgid ""
"`pip` is the package manager for Python. `venv` is the built-in tool for "
"creating virtual environments in Python. A virtual environment is a self-"
"contained directory that contains a Python installation for a particular "
"version of Python, plus several additional packages. This is useful for "
"managing dependencies for different projects separately."
msgstr ""
"`pip` 是 Python 的包管理工具。`venv` 是 Python 中用于创建虚拟环境的内置工具。虚拟环境是一个独立的目录，包含某个版本的 "
"Python 安装，以及几个额外的包。这对于分别管理不同项目的依赖非常有用。"

#: ../../source/guide/install/python.md:84
msgid ""
"To create a virtual environment, run the following command in your terminal:"
msgstr "要创建一个虚拟环境，请在终端中运行以下命令："

#: ../../source/guide/install/python.md:89
msgid ""
"This will create a new directory called `<env_path>` that contains a copy of"
" the Python interpreter and the standard library. To activate the virtual "
"environment, run the following command:"
msgstr "这将创建一个名为 `<env_path>` 的新目录，其中包含 Python 解释器和标准库的副本。要激活虚拟环境，请运行以下命令："

#: ../../source/guide/install/python.md:97
msgid ""
"This will change your shell prompt to indicate that you are now working "
"inside the virtual environment. To deactivate the virtual environment, run "
"the following command:"
msgstr "这将更改您的 shell 提示，以表明您现在正在虚拟环境中工作。要停用虚拟环境，请运行以下命令："

#: ../../source/guide/install/python.md:103
msgid ""
"This will return you to your system's default Python interpreter with all "
"its installed libraries."
msgstr "这将使您返回到系统的默认Python解释器，其中包含所有已安装的库。"

#: ../../source/guide/install/python.md:105
msgid ""
"While the virtual environment is activated, you can use `pip` to install "
"packages into the virtual environment. For example, to install the latest "
"version of `numpy`, run the following command:"
msgstr "在虚拟环境被激活时，可以使用 `pip` 将软件包安装到虚拟环境中。例如，要安装最新版本的 `numpy`，运行以下命令："

#: ../../source/guide/install/python.md:111
msgid ""
"This will install `numpy` into the virtual environment, and it will not "
"affect the system-wide Python installation. To install a specific version of"
" `numpy`, run the following command:"
msgstr "这将把 `numpy` 安装到虚拟环境中，并且不会影响系统范围的 Python 安装。要安装特定版本的 `numpy`，运行以下命令："

#: ../../source/guide/install/python.md:117
msgid ""
"This will install version `1.23.4` of `numpy` into the virtual environment. "
"To list all the packages installed in the virtual environment, run the "
"following command:"
msgstr "这将把 `numpy` 的版本 `1.23.4` 安装到虚拟环境中。要列出虚拟环境中安装的所有软件包，请运行以下命令："

#: ../../source/guide/install/python.md:123
msgid ""
"This will show you a list of all the packages installed in the virtual "
"environment, along with their versions. To uninstall a package, run the "
"following command:"
msgstr "这将显示虚拟环境中安装的所有软件包及其版本的列表。要卸载某个软件包，请运行以下命令："

#: ../../source/guide/install/python.md:129
msgid ""
"This will uninstall `numpy` from the virtual environment. To upgrade a "
"package, run the following command:"
msgstr "这将从虚拟环境中卸载 `numpy`。要升级一个软件包，请运行以下命令："

#: ../../source/guide/install/python.md:135
msgid ""
"This will upgrade `numpy` to the latest version in the virtual environment."
msgstr "这将把虚拟环境中的 `numpy` 升级到最新版本。"

#: ../../source/guide/install/python.md:137
msgid "uv"
msgstr "uv"

#: ../../source/guide/install/python.md:139
msgid ""
"`uv` can not only manage Python versions, but also manage Python "
"environments. To create a new Python environment, run the following command:"
msgstr "`uv` 不仅可以管理 Python 版本，还可以管理 Python 环境。要创建一个新的 Python 环境，请运行以下命令："

#: ../../source/guide/install/python.md:145
msgid ""
"This will create a new directory called `.venv` that contains a copy of the "
"Python interpreter and the standard library. To activate the virtual "
"environment, run the following command:"
msgstr "这将创建一个名为 `.venv` 的新目录，其中包含 Python 解释器和标准库的副本。要激活虚拟环境，请运行以下命令："

#: ../../source/guide/install/python.md:154
msgid ""
"After activating the virtual environment, you can use `uv pip` to install "
"packages into the virtual environment. For example, to install the latest "
"version of `numpy`, run the following command:"
msgstr "激活虚拟环境后，可以使用 `uv pip` 将软件包安装到虚拟环境中。例如，要安装最新版本的 `numpy`，运行以下命令："

#: ../../source/guide/install/torch_and_evox.md:1
msgid "EvoX Installation Guide"
msgstr "EvoX安装教程"

#: ../../source/guide/install/torch_and_evox.md:3
msgid "Install EvoX"
msgstr "安装EvoX"

#: ../../source/guide/install/torch_and_evox.md:5
msgid "EvoX is available at PyPI and can be installed via:"
msgstr "EvoX 可通过 PyPI 获取，并可通过以下方式安装："

#: ../../source/guide/install/torch_and_evox.md:16
msgid ""
"You can also assign extra options during the installation, currently "
"available extras are `vis`, `neuroevolution`, `test`, `docs`, `default`. For"
" example, to install EvoX with all features, run the following command:"
msgstr ""
"您还可以在安装期间指定额外选项，目前可用的额外选项包括 "
"`vis`、`neuroevolution`、`test`、`docs`、`default`。例如，要安装具有全部功能的 EvoX，请运行以下命令:"

#: ../../source/guide/install/torch_and_evox.md:22
msgid "Install PyTorch with accelerator support"
msgstr "安装支持加速器的 PyTorch"

#: ../../source/guide/install/torch_and_evox.md:24
msgid ""
"`evox` relies on `torch` to provide hardware acceleration. The overall "
"architecture of these Python packages looks like this:"
msgstr "`evox` 依赖于 `torch` 提供硬件加速。这些 Python 包的整体架构如下所示："

#: ../../source/guide/install/torch_and_evox.md:42
msgid ""
"To summarize, whether `evox` has CPU support or Nvidia GPU support (CUDA) or"
" AMD GPU support (ROCm) depends on the installed PyTorch version. Please "
"refer to the PyTorch official website for more installation help: "
"[`torch`](https://pytorch.org/)"
msgstr ""
"总之，`evox` 是否支持 CPU、Nvidia GPU (CUDA) 或 AMD GPU (ROCm) 取决于安装的 PyTorch 版本。请参考 "
"PyTorch 官方网站以获取更多安装帮助：[`torch`](https://pytorch.org/)"

#: ../../source/guide/install/torch_and_evox.md:45
msgid "Nvidia GPU support on Windows"
msgstr "Nvidia GPU 支持在 Windows 上"

#: ../../source/guide/install/torch_and_evox.md:47
msgid ""
"EvoX support GPU acceleration through PyTorch. There are two ways to use "
"PyTorch with GPU acceleration on Windows:"
msgstr "EvoX通过PyTorch支持GPU加速。在Windows上使用PyTorch进行GPU加速有两种方法："

#: ../../source/guide/install/torch_and_evox.md:50
msgid ""
"Using WSL 2 (Windows Subsystem for Linux) and install PyTorch on the Linux "
"side."
msgstr "使用 WSL 2（Windows Subsystem for Linux）并在 Linux 端安装 PyTorch。"

#: ../../source/guide/install/torch_and_evox.md:51
msgid "Directly install PyTorch on Windows."
msgstr "直接在 Windows 上安装 PyTorch。"

#: ../../source/guide/install/torch_and_evox.md:53
msgid ""
"For option 2, we provide a [one-click script](/_static/win-install.bat) for "
"fast deployment on fresh installed windows 10/11 64bit with Nvidia GPUs. The"
" script will not use WSL 2 and will install the native Pytorch version on "
"Windows. It will automatically install related applications like VSCode, Git"
" and MiniForge3."
msgstr ""
"对于选项2，我们提供了一个[一键脚本](/_static/win-install.bat)，用于在全新安装的 Windows 10/11 64 "
"位系统（带 Nvidia GPUs）上快速部署。该脚本不会使用 WSL 2，而是会在 Windows 上安装本地版本的 "
"Pytorch。它还会自动安装相关应用程序，如 VSCode、Git 和 MiniForge3。"

#: ../../source/guide/install/torch_and_evox.md:55
msgid ""
"Ensure the [Nvidia "
"driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) is properly "
"installed first. Otherwise the script will fall back to cpu mode."
msgstr ""
"确保先正确安装 [Nvidia driver](https://www.nvidia.com/Download/index.aspx?lang=en-"
"us)。否则脚本将回退到 cpu 模式。"

#: ../../source/guide/install/torch_and_evox.md:56
msgid ""
"When running the script, ensure a stable network (accessible to `github.com`"
" etc.)."
msgstr "运行脚本时，确保网络稳定（可访问 `github.com` 等）。"

#: ../../source/guide/install/torch_and_evox.md:57
msgid ""
"If the script is failed due to network failure, close and reopen it to "
"continue the installation."
msgstr "如果脚本因网络故障而失败，请关闭并重新打开以继续安装。"

#: ../../source/guide/install/torch_and_evox.md:59
msgid "Manual installation on Windows"
msgstr "Windows上的手动安装"

#: ../../source/guide/install/torch_and_evox.md:61
msgid ""
"If you prefer to install PyTorch directly on Windows manually, you can "
"follow the steps below:"
msgstr "如果您希望在 Windows 上手动安装 PyTorch，可以按照以下步骤操作："

#: ../../source/guide/install/torch_and_evox.md:62
msgid "Install Nvidia driver as mentioned above."
msgstr "按照上述所提到的方式安装 Nvidia 驱动。"

#: ../../source/guide/install/torch_and_evox.md:63
msgid ""
"Install Python 3.10 or above from "
"[python.org](https://www.python.org/downloads/)."
msgstr "从[python.org](https://www.python.org/downloads/)安装 Python 3.10 或更高版本。"

#: ../../source/guide/install/torch_and_evox.md:64
msgid "Install PyTorch."
msgstr "安装 PyTorch。"

#: ../../source/guide/install/torch_and_evox.md:65
msgid ""
"(Optional) Install [`triton-windows`](https://github.com/woct0rdho/triton-"
"windows) for `torch.compile` support on Windows."
msgstr ""
"（可选）在 Windows 上安装 [`triton-windows`](https://github.com/woct0rdho/triton-"
"windows) 以支持 `torch.compile`。"

#: ../../source/guide/install/torch_and_evox.md:66
msgid "Install EvoX."
msgstr "安装 EvoX。"

#: ../../source/guide/install/torch_and_evox.md:68
msgid "Windows WSL 2"
msgstr "Windows WSL 2"

#: ../../source/guide/install/torch_and_evox.md:70
msgid ""
"Download the [latest NVIDIA Windows GPU "
"Driver](https://www.nvidia.com/Download/index.aspx?lang=en-us) and install "
"it. Then your WSL 2 will support Nvidia GPUs in its Linux environments."
msgstr ""
"下载并安装[最新的 NVIDIA Windows GPU "
"驱动程序](https://www.nvidia.com/Download/index.aspx?lang=en-us)。然后，您的 WSL 2 将在其"
" Linux 环境中支持 Nvidia GPU。"

#: ../../source/guide/install/torch_and_evox.md:73
msgid ""
"Do **NOT** install any NVIDIA GPU Linux driver within WSL 2. Install the "
"driver on the Windows side."
msgstr "请**不要**在WSL 2中安装任何NVIDIA GPU Linux驱动。在Windows端安装驱动。"

#: ../../source/guide/install/torch_and_evox.md:77
msgid ""
"NVIDIA has a detailed [CUDA on WSL User "
"Guide](https://docs.nvidia.com/cuda/wsl-user-guide/index.html)"
msgstr ""
"NVIDIA官方有一个详细的教程 [CUDA on WSL User Guide](https://docs.nvidia.com/cuda/wsl-"
"user-guide/index.html)"

#: ../../source/guide/install/torch_and_evox.md:80
msgid "AMD GPU (ROCm) support"
msgstr "AMD GPU (ROCm) 支持"

#: ../../source/guide/install/torch_and_evox.md:82
msgid ""
"We recommend using a Docker container from "
"[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)."
msgstr ""
"我们建议使用来自[`rocm/pytorch`](https://hub.docker.com/r/rocm/pytorch)的Docker容器。"

#: ../../source/guide/install/torch_and_evox.md:88
msgid "Verify the installation"
msgstr "验证安装"

#: ../../source/guide/install/torch_and_evox.md:90
msgid "Open a Python terminal, and run the following:"
msgstr "打开 Python 终端，并运行以下命令："

#: ../../source/index.md:3
msgid "Getting Started"
msgstr "入门"

#: ../../source/index.md:14 ../../source/miscellaneous/index.md:1
msgid "Miscellaneous"
msgstr "杂项"

#: ../../source/index.md:14
msgid "Additional Resources"
msgstr "补充资源"

#: ../../source/index.md:1
msgid "Welcome to EvoX's documentation!"
msgstr "欢迎来到EvoX的文档！"

#: ../../source/index.md:24
msgid ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh-cn/latest/)"
msgstr ""
"[[English Version]](https://evox.readthedocs.io/en/latest/)   "
"[[中文版本]](https://evox.readthedocs.io/zh-cn/latest/)"

#: ../../source/index.md:26
msgid ""
"EvoX is a distributed GPU-accelerated framework for scalable evolutionary "
"computation."
msgstr "EvoX是一个分布式GPU加速的演化计算框架。"

#: ../../source/index.md:28
msgid "Key Features"
msgstr "关键特征"

#: ../../source/index.md:30
msgid "🚀 **Fast Performance**:"
msgstr "🚀 **超高性能**："

#: ../../source/index.md:31
msgid ""
"Experience **GPU-Accelerated** optimization, achieving speeds over 100x "
"faster than traditional methods."
msgstr "体验**GPU 加速**的优化，速度比传统方法快百倍以上。"

#: ../../source/index.md:32
msgid ""
"Leverage the power of Distributed Workflows for even more rapid "
"optimization."
msgstr "利用分布式工作流的强大功能，实现更快速的优化。"

#: ../../source/index.md:34
msgid "🌐 **Versatile Optimization Suite**:"
msgstr "🌐 **多功能优化套件**:"

#: ../../source/index.md:35
msgid ""
"Cater to all your needs with both [Single-objective and Multi-"
"objective](#algorithms) optimization capabilities."
msgstr "满足您所有需求，包括[单目标和多目标](#algorithms)优化。"

#: ../../source/index.md:36
msgid ""
"Dive into a comprehensive library of [Benchmark Problems](#problems), "
"ensuring robust testing and evaluation."
msgstr "深入了解全面的[基准测试问题库](#problems)，确保进行稳健的测试和评估。"

#: ../../source/index.md:37
msgid ""
"Explore the frontier of AI with extensive tools for "
"[Neuroevolution](#neuroevolution) tasks."
msgstr "探索人工智能前沿领域，利用丰富的工具进行[神经演化](#neuroevolution)任务。"

#: ../../source/index.md:39
msgid "🛠️ **Designed for Simplicity**:"
msgstr "🛠️ **简易性设计**:"

#: ../../source/index.md:40
msgid ""
"Embrace the elegance of **Functional Programming**, simplifying complex "
"algorithmic compositions."
msgstr "拥抱优雅的**函数式编程**，化繁为简，轻松构建复杂算法。"

#: ../../source/index.md:41
msgid ""
"Benefit from **Hierarchical State Management**, ensuring modular and clean "
"programming."
msgstr "得益于**层次化状态管理**，体验模块化和清爽的编程体验。"

#: ../../source/index.md:50
#, fuzzy
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> Tutorials"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-people\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path d=\"M3.5 "
"8a5.5 5.5 0 1 1 8.596 4.547 9.005 9.005 0 0 1 5.9 8.18.751.751 0 0 1-1.5.045"
" 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.499-.044 9.005 9.005 0 0 1 "
"5.9-8.181A5.496 5.496 0 0 1 3.5 8ZM9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.29 "
"4c-.148 0-.292.01-.434.03a.75.75 0 1 1-.212-1.484 4.53 4.53 0 0 1 3.38 8.097"
" 6.69 6.69 0 0 1 3.956 6.107.75.75 0 0 1-1.5 0 5.193 5.193 0 0 "
"0-3.696-4.972l-.534-.16v-1.676l.41-.209A3.03 3.03 0 0 0 17.29 "
"8Z\"></path></svg> Tutorials"

#: ../../source/index.md:56
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> Installation "
"Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-desktop-download\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M11.25 9.331V.75a.75.75 0 0 1 1.5 0v8.58l1.949-2.11A.75.75 0 1 1 15.8 "
"8.237l-3.25 3.52a.75.75 0 0 1-1.102 0l-3.25-3.52A.75.75 0 1 1 9.3 7.22l1.949"
" 2.111Z\"></path><path d=\"M2.5 3.75v11.5c0 .138.112.25.25.25h18.5a.25.25 0 "
"0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25h-5.5a.75.75 0 0 1 0-1.5h5.5c.966 0 "
"1.75.784 1.75 1.75v11.5A1.75 1.75 0 0 1 21.25 17h-6.204c.171 1.375.805 2.652"
" 1.769 3.757A.752.752 0 0 1 16.25 22h-8.5a.75.75 0 0 1-.566-1.243c.965-1.105"
" 1.599-2.382 1.77-3.757H2.75A1.75 1.75 0 0 1 1 15.25V3.75C1 2.784 1.784 2 "
"2.75 2h5.5a.75.75 0 0 1 0 1.5h-5.5a.25.25 0 0 0-.25.25ZM10.463 17c-.126 "
"1.266-.564 2.445-1.223 "
"3.5h5.52c-.66-1.055-1.098-2.234-1.223-3.5Z\"></path></svg> 安装教程"

#: ../../source/index.md:62
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> Developer Guide"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-mortar-board\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M12.292 2.06v-.001l11.25 4.75a.749.749 0 0 1 0 1.382L19 10.108V15a.75.75"
" 0 0 1-.11.391h-.001a2.84 2.84 0 0 "
"1-.392.482c-.249.256-.625.58-1.163.896-1.08.638-2.776 1.23-5.334 1.23-.673 "
"0-1.286-.041-1.846-.113a.75.75 0 0 1 .192-1.487c.492.063 1.042.1 1.654.1 "
"2.317 0 3.746-.533 "
"4.572-1.021.31-.178.596-.397.849-.65l.079-.085V10.74l-5.208 2.2a.75.75 0 0 "
"1-.584 0L5.75 10.424v3.17c.502.129.96.391 1.327.758.579.578.923 1.41.923 "
"2.428v4.5a.761.761 0 0 1-.345.634 2.157 2.157 0 0 1-.21.117 3.923 3.923 0 0 "
"1-.52.213A6.121 6.121 0 0 1 5 22.532a6.092 6.092 0 0 1-1.925-.288 4.065 "
"4.065 0 0 1-.52-.213 1.816 1.816 0 0 1-.22-.124.757.757 0 0 "
"1-.335-.624v-4.5c0-1.02.344-1.85.923-2.43a2.904 2.904 0 0 1 "
"1.327-.757V9.793L.458 8.19a.75.75 0 0 1 0-1.38l11.25-4.75a.75.75 0 0 1 .584 "
"0ZM12 11.436 21.322 7.5 12 3.564 2.678 7.5ZM5 15c-.377 "
"0-.745.141-1.017.413-.265.265-.483.7-.483 1.368v4.022c.299.105.797.228 "
"1.5.228s1.201-.123 1.5-.228V16.78c0-.669-.218-1.103-.483-1.368A1.433 1.433 0"
" 0 0 5 15Z\"></path></svg> 开发者教程"

#: ../../source/index.md:72
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Algorithms"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 算法"

#: ../../source/index.md:78
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Problems"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 问题"

#: ../../source/index.md:85
msgid ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> "
"Metrics"
msgstr ""
"<svg version=\"1.1\" width=\"1.5em\" height=\"1.5em\" class=\"sd-octicon sd-"
"octicon-list-unordered\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><path "
"d=\"M8.75 5.5h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 "
"6h11.5a.75.75 0 0 1 0 1.5H8.75a.75.75 0 0 1 0-1.5Zm0 6h11.5a.75.75 0 0 1 0 "
"1.5H8.75a.75.75 0 0 1 0-1.5ZM5 12a1 1 0 1 1-2 0 1 1 0 0 1 2 0ZM4 7a1 1 0 1 1"
" 0-2 1 1 0 0 1 0 2Zm0 12a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"></path></svg> 指标"

#: ../../source/miscellaneous/linux_distribution.md:1
msgid "Linux Distribution and GPU Driver"
msgstr "Linux发行版与GPU驱动"

#: ../../source/miscellaneous/linux_distribution.md:3
msgid "Choosing a Linux Distribution"
msgstr "选择一个Linux发行版"

#: ../../source/miscellaneous/linux_distribution.md:5
msgid ""
"Many people assume that an \"old and stable\" Linux distribution is the best"
" choice for a server. However, this isn't always true—especially for GPU "
"servers."
msgstr "许多人认为“成熟且稳定”的Linux发行版是服务器的最佳选择。然而，这并不总是正确的——尤其是对于GPU服务器。"

#: ../../source/miscellaneous/linux_distribution.md:7
msgid ""
"The stability of a GPU server often depends on the kernel version and the "
"GPU driver. Because GPU hardware evolves rapidly, newer kernels and drivers "
"tend to be more refined, stable, and compatible with recent GPUs. They "
"usually include more bug fixes and better support for the latest hardware. "
"Additional, the jit compilation and optimizations in the latest kernels and "
"drivers are significantly better than in older versions."
msgstr ""
"GPU 服务器的稳定性通常取决于内核版本和 GPU 驱动程序。由于 GPU "
"硬件演化迅速，较新的内核和驱动程序往往更完善、更稳定，并能更好地兼容最近的 "
"GPU。它们通常包含更多的错误修复，并对最新硬件提供更好的支持。此外，最新内核和驱动程序中的 jit 编译和优化相比旧版本也显著提高。"

#: ../../source/miscellaneous/linux_distribution.md:9
msgid ""
"For example, while Ubuntu 20.04 is considered a \"stable\" release, it's now"
" quite dated for GPU workloads. Even the NVIDIA RTX 3090, which isn’t a "
"particularly new GPU, was released in 2020. This means the default drivers "
"provided by Ubuntu 20.04 may not fully support the 3090, potentially leading"
" to compatibility issues."
msgstr ""
"例如，虽然 Ubuntu 20.04 被认为是一个“稳定”的版本，但对于 GPU 来说，它现在已经相当过时了。即使是一款不是特别新的 NVIDIA RTX "
"3090，也是在 2020 年发布的。这意味着 Ubuntu 20.04 提供的默认驱动可能无法完全支持 "
"3090，从而可能导致兼容性问题。"

#: ../../source/miscellaneous/linux_distribution.md:11
msgid ""
"In most cases, choosing a newer Linux distribution (such as Ubuntu 25.04 "
"offers better support than 22.04)."
msgstr "在大多数情况下，选择较新的 Linux 发行版（例如 Ubuntu 25.04 比 22.04 提供更好的支持）。"

#: ../../source/miscellaneous/linux_distribution.md:13
msgid ""
"Another important factor to consider is how well a Linux distribution "
"supports non-open-source (proprietary) software. Some distributions, such as"
" Fedora, prioritize open-source software and may not include proprietary "
"drivers by default—for example, NVIDIA drivers. This can require additional "
"steps to install and configure GPU drivers. Other distributions, like Arch "
"Linux, Debian, Ubuntu, and NixOS, tend to be more flexible and make it "
"easier to install proprietary drivers when needed."
msgstr ""
"另一个需要考虑的重要因素是某个Linux发行版对非开源（专有）软件的支持程度。一些发行版（如Fedora）优先考虑开源软件，默认情况下可能不包含专有驱动，例如NVIDIA驱动。这可能需要额外步骤来安装和配置GPU驱动。其他发行版，如Arch"
" Linux、Debian、Ubuntu和NixOS，通常更加灵活，在需要安装专有驱动时会更加容易。"

#: ../../source/miscellaneous/linux_distribution.md:15
msgid "Installing the GPU Driver"
msgstr "安装 GPU 驱动"

#: ../../source/miscellaneous/linux_distribution.md:17
msgid ""
"It is generally recommended to install the GPU driver provided by your Linux"
" distribution. These drivers are typically well-tested and integrated with "
"the kernel."
msgstr "通常建议安装由您的 Linux 发行版提供的 GPU 驱动程序。这些驱动程序通常经过充分测试并且会兼容您的内核。"

#: ../../source/miscellaneous/linux_distribution.md:20
msgid ""
"Unless you are highly experienced with GPU drivers and the Linux kernel, you"
" should avoid installing drivers directly from the NVIDIA website, as they "
"may lead to compatibility issues or require additional configuration."
msgstr ""
"除非您对 GPU 驱动程序和 Linux 内核非常熟悉，否则应避免直接从 NVIDIA 网站安装驱动程序，因为这可能会导致兼容性问题或需要额外的配置。"

#: ../../source/miscellaneous/other_gpus.md:1
msgid "Use Non-NVIDIA GPUs"
msgstr "使用非NVIDIA GPU"

#: ../../source/miscellaneous/other_gpus.md:3
msgid ""
"This guide explains how to use AMD GPUs and Apple Silicon GPUs with PyTorch "
"in the context of EvoX."
msgstr "本指南解释如何在EvoX中使用PyTorch与AMD GPUs和Apple Silicon GPUs。"

#: ../../source/miscellaneous/other_gpus.md:5
msgid ""
"While NVIDIA GPUs are a reliable choice and generally offer strong "
"performance, newer models are optimized for deep learning workloads and "
"large language models. Many of their advanced features, such as support for "
"low-precision data types, are currently underutilized in EvoX. In some "
"cases, non-NVIDIA GPUs can provide better performance and lower cost for "
"evolutionary tasks."
msgstr ""
"尽管 NVIDIA GPU "
"是一个可靠的选择，通常提供较强的性能，但其较新的型号主要针对深度学习工作负载和大型语言模型进行了优化。它们的许多高级特性，如对低精度数据类型的支持，目前在"
" EvoX 中尚未被充分利用。在某些情况下，非 NVIDIA GPU 在演化任务中可能提供更好的性能和更低的成本。"

#: ../../source/miscellaneous/other_gpus.md:7
msgid "AMD GPU Support"
msgstr "AMD GPU 支持"

#: ../../source/miscellaneous/other_gpus.md:9
msgid ""
"AMD GPU support in PyTorch is provided via ROCm. AMD devices are recognized "
"as `cuda` devices (just like NVIDIA GPUs). To use an AMD GPU:"
msgstr ""
"PyTorch 中对 AMD GPU 的支持通过 ROCm 提供。AMD 设备被识别为 `cuda` 设备（与 NVIDIA GPU 一样）。要使用 "
"AMD GPU："

#: ../../source/miscellaneous/other_gpus.md:11
msgid "Install the ROCm-compatible version of PyTorch."
msgstr "安装兼容ROCm的PyTorch版本。"

#: ../../source/miscellaneous/other_gpus.md:12
msgid "Use the standard device setup, e.g., `device = torch.device(\"cuda\")`."
msgstr "使用标准设备设置，例如：`device = torch.device(\"cuda\")`。"

#: ../../source/miscellaneous/other_gpus.md:14
msgid "No additional changes are needed beyond using the ROCm build."
msgstr "无需额外更改，只需使用ROCm构建即可。"

#: ../../source/miscellaneous/other_gpus.md:16
msgid "Apple Silicon GPU Support"
msgstr "Apple Silicon GPU 支持"

#: ../../source/miscellaneous/other_gpus.md:18
msgid ""
"If you own an Apple Silicon Mac, you can leverage the built-in GPU to "
"accelerate your EvoX workloads. Apple Silicon GPUs are supported via the "
"Metal Performance Shaders (MPS) backend and are accessible using the `mps` "
"device in PyTorch."
msgstr ""
"如果您使用的是 Apple Silicon Mac，您可以利用内置 GPU 加速您的 EvoX 工作流。Apple Silicon GPU 通过 "
"Metal Performance Shaders (MPS) 后端支持，并且可以通过 PyTorch 中的 `mps` 设备访问。"

#: ../../source/miscellaneous/other_gpus.md:21
msgid "To use an Apple Silicon GPU:"
msgstr "要使用Apple Silicon GPU:"

#: ../../source/miscellaneous/other_gpus.md:23
msgid "Ensure you have the MPS-compatible version of PyTorch installed."
msgstr "确保已安装支持 MPS 的 PyTorch 版本。"

#: ../../source/miscellaneous/other_gpus.md:24
msgid ""
"Move your tensors and models to the `mps` device, e.g., `device = "
"torch.device(\"mps\")`."
msgstr "将您的张量和模型移动到 `mps` 设备，例如 `device = torch.device(\"mps\")`。"

#: ../../source/miscellaneous/other_gpus.md:27
msgid ""
"The `mps` device does **not** support compilation (e.g., `#evox.compile`)."
msgstr "`mps` 设备**不**支持编译（例如，`#evox.compile`）。"

#: ../../source/miscellaneous/selecting_gpu.md:1
msgid "Selecting GPU / CPU"
msgstr "选择 GPU / CPU"

#: ../../source/miscellaneous/selecting_gpu.md:3
msgid ""
"To run your program on a specific GPU, you can use the "
"`CUDA_VISIBLE_DEVICES` environment variable. For example, to run your "
"program on the second GPU, you can use:"
msgstr ""
"要在特定的 GPU 上运行程序，您可以使用 `CUDA_VISIBLE_DEVICES` 环境变量。例如，要在第二个 GPU 上运行程序，您可以使用："

#: ../../source/miscellaneous/selecting_gpu.md:9
msgid "To run your program on multiple GPUs, you can use:"
msgstr "要在多个GPU上跑你的程序，你可以用："

#: ../../source/miscellaneous/selecting_gpu.md:15
msgid "To disable GPU usage (use CPU), you can use:"
msgstr "如果要禁用GPU（即使用CPU），你可以用："

#: ../../source/miscellaneous/transfer-from-matlab.md:1
msgid "Transformation from MATLAB to PyTorch and EvoX"
msgstr "从MATLAB到PyTorch和EvoX的转换"

#: ../../source/miscellaneous/transfer-from-matlab.md:3
msgid ""
"This document aims to guide MATLAB users in transitioning to PyTorch and "
"EvoX for evolutionary computation. We will highlight the core differences "
"between MATLAB and PyTorch in terms of syntax, data structures, and "
"workflow. We will then illustrate these differences using a Particle Swarm "
"Optimization (PSO) example in both MATLAB and PyTorch."
msgstr ""
"本文档旨在指导MATLAB用户过渡到PyTorch和EvoX进行演化计算。我们将重点介绍MATLAB和PyTorch在语法、数据结构和工作流方面的核心差异。然后，我们将通过在MATLAB和PyTorch中使用粒子群优化（PSO）示例来说明这些差异。"

#: ../../source/miscellaneous/transfer-from-matlab.md:5
msgid "Syntax Differences"
msgstr "语法差异"

#: ../../source/miscellaneous/transfer-from-matlab.md:7
msgid "Array Creation and Indexing"
msgstr "数组创建和索引"

#: ../../source/miscellaneous/transfer-from-matlab.md:9
#: ../../source/miscellaneous/transfer-from-matlab.md:23
#: ../../source/miscellaneous/transfer-from-matlab.md:43
#: ../../source/miscellaneous/transfer-from-matlab.md:57
#: ../../source/miscellaneous/transfer-from-matlab.md:69
#: ../../source/miscellaneous/transfer-from-matlab.md:81
#: ../../source/miscellaneous/transfer-from-matlab.md:91
msgid "MATLAB"
msgstr "MATLAB"

#: ../../source/miscellaneous/transfer-from-matlab.md:11
msgid "Uses 1-based indexing."
msgstr "使用从1开始的索引。"

#: ../../source/miscellaneous/transfer-from-matlab.md:12
msgid ""
"Vectors and matrices are declared using square brackets and semicolons "
"(e.g., `[1 2 3; 4 5 6]`). Random initialization with `rand()` returns values"
" in the interval $[0, 1)$."
msgstr ""
"向量和矩阵使用方括号和分号声明（例如，`[1 2 3; 4 5 6]`）。使用 `rand()` 进行随机初始化时，返回的值在区间 $[0, 1)$ "
"内。"

#: ../../source/miscellaneous/transfer-from-matlab.md:13
msgid ""
"Slicing is performed using the `(start:end)` syntax and utilizes 1-based "
"indexing."
msgstr "切片使用 `(start:end)` 语法进行，并使用从1开始的索引。"

#: ../../source/miscellaneous/transfer-from-matlab.md:15
#: ../../source/miscellaneous/transfer-from-matlab.md:32
#: ../../source/miscellaneous/transfer-from-matlab.md:49
#: ../../source/miscellaneous/transfer-from-matlab.md:62
#: ../../source/miscellaneous/transfer-from-matlab.md:74
msgid "PyTorch"
msgstr "PyTorch"

#: ../../source/miscellaneous/transfer-from-matlab.md:17
msgid "Uses 0-based indexing."
msgstr "使用从0开始的索引。"

#: ../../source/miscellaneous/transfer-from-matlab.md:18
msgid ""
"Arrays (tensors) are typically created using constructors like "
"`torch.rand()`, `torch.zeros()`, or Python lists converted to tensors with "
"`torch.tensor()`."
msgstr ""
"数组（张量）通常使用构造函数创建，例如 `torch.rand()`、`torch.zeros()`，或将 Python 列表转换为张量的 "
"`torch.tensor()"

#: ../../source/miscellaneous/transfer-from-matlab.md:19
msgid "Slicing is done using `[start:end]` with 0-based indices."
msgstr "切片使用 `[start:end]`，索引从0开始。"

#: ../../source/miscellaneous/transfer-from-matlab.md:21
msgid "Matrix Computation"
msgstr "矩阵计算"

#: ../../source/miscellaneous/transfer-from-matlab.md:25
msgid "Performs linear algebraic matrix multiplication by `*`."
msgstr "通过 `*` 执行线性代数矩阵乘法。"

#: ../../source/miscellaneous/transfer-from-matlab.md:26
msgid ""
"Uses `.*` to multiply corresponding elements of matrices of the same size."
msgstr "使用 `.*` 来逐元素相乘相同大小的矩阵。"

#: ../../source/miscellaneous/transfer-from-matlab.md:27
msgid "`/` represents the matrix right division."
msgstr "`/` 表示矩阵右除法。"

#: ../../source/miscellaneous/transfer-from-matlab.md:28
msgid "`.^` represents the element-wise power."
msgstr "`.^` 表示元素级幂。"

#: ../../source/miscellaneous/transfer-from-matlab.md:29
msgid ""
"Trailing and leading dimension(s) of tensors with length 1 is/are "
"**ignored**."
msgstr "张量中长度为1的尾部和头部维度将被**忽略**。"

#: ../../source/miscellaneous/transfer-from-matlab.md:30
msgid ""
"Automatically find broadcastable dimensions for element-wise operations and "
"perform **implicit** dimension extension."
msgstr "自动查找元素级操作的可广播维度，并执行**隐式**维度扩展。"

#: ../../source/miscellaneous/transfer-from-matlab.md:34
msgid ""
"Performs linear algebraic matrix multiplication by `@` or `torch.matmul()`."
msgstr "执行线性代数矩阵乘法通过 `@` 或 `torch.matmul()"

#: ../../source/miscellaneous/transfer-from-matlab.md:35
msgid ""
"Directly uses `*` to multiply corresponding elements of tensors of the same "
"shape or broadcastable shapes."
msgstr "直接使用 `*` 来乘以相同形状或可广播形状的张量的对应元素。"

#: ../../source/miscellaneous/transfer-from-matlab.md:36
msgid "`/` represents the element-wise division."
msgstr "`/` 表示逐元素除法。"

#: ../../source/miscellaneous/transfer-from-matlab.md:37
msgid "`**` represents the element-wise power."
msgstr "`**` 表示元素级幂。"

#: ../../source/miscellaneous/transfer-from-matlab.md:38
msgid ""
"Dimension(s) of tensors with length 1 is/are **preserved** and treated as "
"**broadcast dimension**."
msgstr "张量长度为1的维度被**保留**并视为**广播维度**。"

#: ../../source/miscellaneous/transfer-from-matlab.md:39
msgid ""
"**Prevent** most implicit dimension extension, broadcast dimension(s) are "
"usually required."
msgstr "**防止**大多数隐式维度扩展，通常需要广播维度。"

#: ../../source/miscellaneous/transfer-from-matlab.md:41
msgid "Functions and Definitions"
msgstr "函数和定义"

#: ../../source/miscellaneous/transfer-from-matlab.md:45
msgid "A function is defined by the `function` keyword."
msgstr "一个函数由 `function` 关键字定义。"

#: ../../source/miscellaneous/transfer-from-matlab.md:46
msgid ""
"A file can contain multiple functions, but typically the primary function "
"shares the file name."
msgstr "一个文件可以包含多个函数，但通常主要函数与文件名相同。"

#: ../../source/miscellaneous/transfer-from-matlab.md:47
msgid ""
"Anonymous functions (e.g., `@(x) sum(x.^2)`) are used for short inline "
"calculations."
msgstr "匿名函数（例如，`@(x) sum(x.^2)`）用于简短的内联计算。"

#: ../../source/miscellaneous/transfer-from-matlab.md:51
msgid ""
"Functions are defined using the def keyword, typically within a single `.py`"
" file or module."
msgstr "函数使用 `def` 关键字定义，通常在一个 `.py` 文件或模块中。"

#: ../../source/miscellaneous/transfer-from-matlab.md:52
msgid ""
"Classes are used to encapsulate data and methods in an object-oriented "
"manner."
msgstr "类用于以面向对象的方式封装数据和方法。"

#: ../../source/miscellaneous/transfer-from-matlab.md:53
msgid ""
"Lambdas serve as short anonymous functions (`lambda x: x.sum()`), but multi-"
"line lambdas are not allowed."
msgstr "Lambdas 作为简短的匿名函数使用（`lambda x: x.sum()`），但不允许使用多行 lambdas。"

#: ../../source/miscellaneous/transfer-from-matlab.md:55
msgid "Control Flow"
msgstr "控制流"

#: ../../source/miscellaneous/transfer-from-matlab.md:59
msgid "Uses for `i = 1:N` ... `end` loops with 1-based indexing."
msgstr "`i = 1:N` 循环使用1为基准的索引。"

#: ../../source/miscellaneous/transfer-from-matlab.md:60
msgid "Conditional statements like `if`, `elseif`, and `else`."
msgstr "条件语句如 `if`、`elseif` 和 `else"

#: ../../source/miscellaneous/transfer-from-matlab.md:64
msgid "Uses `for i in range(N):` with 0-based indexing."
msgstr "使用 `for i in range(N):`，采用从0开始的索引。"

#: ../../source/miscellaneous/transfer-from-matlab.md:65
msgid ""
"Indentation is significant for scoping in loops and conditionals (no `end` "
"keyword)."
msgstr "缩进在循环和条件语句中对于确定作用域是重要的（没有 `end` 关键字）。"

#: ../../source/miscellaneous/transfer-from-matlab.md:67
msgid "Printing and Comments"
msgstr "打印与注释"

#: ../../source/miscellaneous/transfer-from-matlab.md:71
msgid "Uses `fprintf()` functions for formatted output."
msgstr "使用 `fprintf()` 函数进行格式化输出。"

#: ../../source/miscellaneous/transfer-from-matlab.md:72
msgid "Uses `%` for single-line comments."
msgstr "使用 `%` 进行单行注释。"

#: ../../source/miscellaneous/transfer-from-matlab.md:76
msgid "Uses `print` with f-strings for formatted output."
msgstr "使用 `print` 和 f-strings 进行格式化输出。"

#: ../../source/miscellaneous/transfer-from-matlab.md:77
msgid "Uses `#` for single-line comments."
msgstr "使用 `#` 进行单行注释。"

#: ../../source/miscellaneous/transfer-from-matlab.md:79
msgid "Multi-line Coding"
msgstr "多行代码"

#: ../../source/miscellaneous/transfer-from-matlab.md:83
msgid ""
"Uses `...` at the trailing of a line to indicate that the next line shall be"
" treated as the same line as."
msgstr "使用 `...` 在行尾表示下一行应视为与当前行相同的一行。"

#: ../../source/miscellaneous/transfer-from-matlab.md:84
msgid "Python"
msgstr "Python"

#: ../../source/miscellaneous/transfer-from-matlab.md:86
msgid ""
"Uses `\\` at the trailing of a line to indicate that the next line shall be "
"treated as the same line as."
msgstr "使用 `\\` 在行尾表示下一行应被视为与当前行相同的一行。"

#: ../../source/miscellaneous/transfer-from-matlab.md:87
msgid ""
"If multiple lines are inside parentheses, no specific trailing symbol is "
"required."
msgstr "如果多行内容在括号内，则不需要特定的结尾符号。"

#: ../../source/miscellaneous/transfer-from-matlab.md:89
msgid "How to Write Evolutionary Computation Algorithm via EvoX?"
msgstr "如何通过EvoX编写演化计算算法？"

#: ../../source/miscellaneous/transfer-from-matlab.md:93
msgid "A MATLAB code example for PSO algorithm is as follows:"
msgstr "以下是PSO算法的MATLAB代码示例："

#: ../../source/miscellaneous/transfer-from-matlab.md:154
msgid ""
"In MATLAB, function `init_pso()` initializes the algorithm, and a separate "
"function `step_pso()` performs an iteration step and the main function "
"`example_pso()` orchestrates the loop."
msgstr ""
"在 MATLAB 中，函数 `init_pso()` 初始化算法，单独的函数 `step_pso()` 执行一个迭代步骤，主要函数 "
"`example_pso()` 组织循环。"

#: ../../source/miscellaneous/transfer-from-matlab.md:156
msgid "EvoX"
msgstr "EvoX"

#: ../../source/miscellaneous/transfer-from-matlab.md:157
msgid "In EvoX, you can construct the PSO algorithm in following way:"
msgstr "在EvoX中，你可以通过以下方式构建PSO算法："

#: ../../source/miscellaneous/transfer-from-matlab.md:159
msgid ""
"First, it is recommended to import necessary modules and functions from EvoX"
" and PyTorch."
msgstr "首先，建议从 EvoX 和 PyTorch 导入必要的模块和函数。"

#: ../../source/miscellaneous/transfer-from-matlab.md:169
msgid ""
"Then, you can transform the MATLAB code to the python code correspondingly "
"according to the \"Syntax Differences\" section."
msgstr "然后，您可以根据“语法差异”部分将MATLAB代码相应地转换为Python代码。"

#: ../../source/miscellaneous/transfer-from-matlab.md:238
msgid ""
"It is worth noting that we use `[]` with `;` and `,` in MATLAB to "
"concatenate matrices and vectors along specific dimension; however, in EvoX,"
" the `torch.cat` must be invoked with argument `dim` to indicate the "
"concatenation dimension. Moreover, in PyTorch, tensors to be concatenated "
"must have the same number of dimensions; therefore, additional "
"`XXX.unsqueeze(0)` is applied to add a new dimension of length 1 before the "
"first dimension."
msgstr ""
"值得注意的是，我们在MATLAB中使用`[]`与`;`和`,`来沿特定维度连接矩阵和向量；然而，在EvoX中，必须调用`torch.cat`并使用参数`dim`来指示连接的维度。此外，在PyTorch中，要连接的张量必须具有相同的维数；因此，额外的`XXX.unsqueeze(0)`被应用于在第一个维度之前添加一个长度为1的新维度。"

#: ../../source/miscellaneous/transfer-from-matlab.md:242
msgid ""
"In EvoX, the PSO logic is encapsulated within a class that inherits from "
"`Algorithm`. This object-oriented design simplifies state management and "
"iteration, and introduces following advantages:"
msgstr ""
"在 EvoX 中，PSO 逻辑被封装在一个继承自 `Algorithm` 的类中。这种面向对象的设计简化了状态管理和迭代，并引入了以下优点："

#: ../../source/miscellaneous/transfer-from-matlab.md:243
msgid ""
"Inherited `evaluate()` method   You can simply call "
"`self.evaluate(self.population)` to compute fitness values, rather than "
"manually passing your objective function each iteration."
msgstr ""
"继承的 `evaluate()` 方法 你可以简单地调用 `self.evaluate(self.population)` "
"来计算适应度值，而不是在每次迭代中手动传递你的目标函数。"

#: ../../source/miscellaneous/transfer-from-matlab.md:245
msgid ""
"Built-In Workflow Integration   When you register your PSO class with a "
"workflow `StdWorkflow`, it handles iterative calls to "
"[`step()`](#StdWorkflow.step) on your behalf."
msgstr ""
"内置工作流集成\n"
"\n"
"当您将您的 PSO 类注册到工作流 `StdWorkflow` 时，它会代表您处理对 [`step()`](#StdWorkflow.step) 的迭代调用。"

#: ../../source/miscellaneous/transfer-from-matlab.md:248
msgid ""
"By extending `Algorithm`, `__init__()` sets up all major PSO components "
"(population, velocity, local/global best, etc.) in a standard Python class "
"constructor."
msgstr ""
"通过扩展 `Algorithm`，`__init__()` 在标准的 Python 类构造函数中设置所有主要的 PSO "
"组件（种群、速度、局部/全局最优等）。"

#: ../../source/tutorial/index.md:1
msgid "EvoX Tutorial"
msgstr "EvoX 教程"

#: ../../source/tutorial/tutorial_part1.md:1
msgid "1. Introduction"
msgstr "1. Introduction"

#: ../../source/tutorial/tutorial_part1.md:3
msgid "What is EvoX?"
msgstr "什么是 EvoX?"

#: ../../source/tutorial/tutorial_part1.md:5
msgid ""
"EvoX is an open-source evolutionary computation library, mainly used to "
"solve various complex optimization problems. Evolutionary computation is a "
"category of algorithms that simulate natural evolution to search for optimal"
" solutions, including Genetic Algorithms (GA), Evolution Strategies (ES), "
"Particle Swarm Optimization (PSO), etc."
msgstr ""
"EvoX is an open-source evolutionary computation library, mainly used to "
"solve various complex optimization problems. Evolutionary computation is a "
"category of algorithms that simulate natural evolution to search for optimal"
" solutions, including Genetic Algorithms (GA), Evolution Strategies (ES), "
"Particle Swarm Optimization (PSO), etc."

#: ../../source/tutorial/tutorial_part1.md:7
msgid ""
"Traditional evolutionary frameworks are often limited by computational "
"resources and programming models, making them inefficient for large-scale "
"problems. EvoX overcomes these challenges by combining **GPU acceleration** "
"and **distributed computing**, offering an efficient and scalable solution "
"that allows users to find better solutions faster in complex search spaces."
msgstr ""
"传统的演化框架通常受到计算资源和编程模型的限制，使其在处理大规模问题时效率低下。EvoX 通过结合 **GPU 加速** 和 "
"**分布式计算**，克服了这些挑战，提供了一种高效且可扩展的解决方案，使用户能够在复杂的搜索空间中更快地找到更优的解决方案。"

#: ../../source/tutorial/tutorial_part1.md:9
msgid "Key Features of EvoX"
msgstr "EvoX 的关键特性"

#: ../../source/tutorial/tutorial_part1.md:11
msgid ""
"**Modular Architecture**: EvoX breaks down the optimization process into "
"independent modules: Algorithm, Problem, Monitor, and Workflow. Users don’t "
"need to worry about low-level parallel implementations—EvoX automatically "
"leverages hardware to boost performance."
msgstr ""
"**模块化架构**: EvoX 将优化过程分解为独立的模块：Algorithm、Problem、Monitor 和 "
"Workflow。用户无需担心底层的并行实现——EvoX 会自动利用硬件来提升性能。"

#: ../../source/tutorial/tutorial_part1.md:12
msgid ""
"**Distributed Execution**: EvoX supports multi-GPU and even multi-node "
"distributed execution. The same code can run on a single machine or scale up"
" to a GPU cluster with little to no additional parallel programming effort. "
"This means your optimization tasks can easily scale from a laptop to a "
"server cluster environment."
msgstr ""
"**分布式执行**: EvoX 支持多 GPU 甚至多节点的分布式执行。相同的代码可以在单台机器上运行，也可以扩展到 GPU "
"集群，并且几乎无需额外的并行编程工作。这意味着您的优化任务可以轻松从笔记本电脑扩展到服务器集群环境。"

#: ../../source/tutorial/tutorial_part1.md:13
msgid ""
"**Functional Programming Interface**: EvoX provides a functional programming"
" interface that aligns closely with mathematical models. Core algorithms are"
" implemented as pure functions without side effects, simplifying "
"parallelization and debugging. Users only need to implement the required "
"functions as defined by the framework, without manually managing complex "
"algorithm states."
msgstr ""
"**函数式编程接口**: EvoX "
"提供一个函数式编程接口，与数学模型紧密对应。核心算法被实现为无副作用的纯函数，简化了并行化和调试。用户只需按照框架定义实现所需的函数，而无需手动管理复杂的算法状态。"

#: ../../source/tutorial/tutorial_part1.md:14
msgid ""
"**Visualization and Monitoring**: EvoX includes rich visualization tools and"
" monitoring modules to track the evolutionary process in real time. It uses "
"a dedicated `.exv` data format for efficient streaming and logging of "
"optimization data and provides user-friendly visualization modules to plot "
"convergence curves and more. These tools give users an intuitive "
"understanding of algorithm performance and convergence status."
msgstr ""
"**可视化和监控**: EvoX 包含丰富的可视化工具和监控模块，用于实时跟踪演化过程。它使用专门的 `.exv` "
"数据格式来高效地流式传输和记录优化数据，并提供用户友好的可视化模块用于绘制收敛曲线等图表。这些工具可以让用户直观地了解算法的性能和收敛状态。"

#: ../../source/tutorial/tutorial_part1.md:15
msgid ""
"**Extensive Algorithm and Problem Libraries**: EvoX includes over 50 single-"
" and multi-objective evolutionary algorithms and over 100 benchmark "
"optimization problems. Whether it’s classical function optimization, complex"
" engineering challenges, or machine learning tasks like hyperparameter "
"optimization (HPO) and neuroevolution, EvoX provides ready-to-use algorithms"
" and problem interfaces out of the box."
msgstr ""
"**广泛的算法和问题库**：EvoX 包含超过 50 个单目标和多目标的演化算法，以及超过 100 "
"个基准优化问题。无论是经典的函数优化、复杂的工程挑战，还是诸如超参数优化 (HPO) 和神经演化等机器学习任务，EvoX "
"都提供了开箱即用的算法和问题接口。"

#: ../../source/tutorial/tutorial_part1.md:17
msgid "Use Cases"
msgstr "用例"

#: ../../source/tutorial/tutorial_part1.md:19
msgid ""
"Thanks to the above features, EvoX is especially suitable for the following "
"scenarios:"
msgstr "由于上述特性，EvoX特别适合以下场景："

#: ../../source/tutorial/tutorial_part1.md:21
msgid ""
"**Large-Scale Parameter Optimization**: For high-dimensional problems with "
"large search spaces, EvoX’s GPU-based parallel computing and efficient "
"algorithms can significantly reduce solving time. Examples include "
"optimizing neural network weights or designing complex system "
"parameters—EvoX can accelerate the process."
msgstr ""
"**大规模参数优化**：对于具有大规模搜索空间的高维问题，EvoX 的基于 GPU "
"的并行计算和高效算法可以显著减少求解时间。例如，优化神经网络权重或设计复杂系统参数——EvoX 可以加速这一过程。"

#: ../../source/tutorial/tutorial_part1.md:22
msgid ""
"**Multi-Objective Optimization**: When you need to optimize multiple (often "
"conflicting) objectives simultaneously—such as balancing cost and "
"performance in engineering design—EvoX includes a variety of multi-objective"
" evolutionary algorithms (like NSGA-II, RVEA, etc.) to search for the "
"Pareto-optimal set."
msgstr ""
"**多目标优化**：当您需要同时优化多个（通常是互相冲突的）目标时——例如在工程设计中平衡成本和性能——EvoX 包括多种多目标演化算法（如 NSGA-"
"II、RVEA 等）来搜索帕累托最优集。"

#: ../../source/tutorial/tutorial_part1.md:23
msgid ""
"**Hyperparameter Optimization (HPO)**: Searching for the best hyperparameter"
" combinations for machine learning models can be time-consuming. EvoX allows"
" the use of evolutionary strategies to efficiently search for hyperparameter"
" configurations, often finding better solutions faster than grid search or "
"random search."
msgstr ""
"**超参数优化 (HPO)**: 为机器学习模型寻找最佳的超参数组合可能会非常耗时。EvoX "
"允许使用演化策略高效搜索超参数配置，通常比网格搜索或随机搜索更快找到更好的解决方案。"

#: ../../source/tutorial/tutorial_part1.md:24
msgid ""
"**Reinforcement Learning and Neuroevolution**: EvoX natively supports "
"reinforcement learning environments (like OpenAI Gym and Google Brax) and "
"deep learning datasets (such as CIFAR-10). This allows users to train "
"control policies or neural network architectures using evolutionary "
"algorithms (i.e., neuroevolution)—for example, using genetic algorithms to "
"optimize RL policy parameters."
msgstr ""
"**强化学习与神经演化**：EvoX 原生支持强化学习环境（如 OpenAI Gym 和 Google Brax）以及深度学习数据集（例如 "
"CIFAR-10）。这使用户能够使用演化算法（即神经演化）训练控制策略或神经网络架构——例如，使用遗传算法优化强化学习策略参数。"

#: ../../source/tutorial/tutorial_part1.md:25
msgid ""
"**Academic Research and Engineering Applications**: For researchers in "
"evolutionary algorithms, EvoX offers a highly flexible platform to implement"
" and test new methods. For engineering optimization tasks (like tuning "
"industrial process parameters or adjusting control systems), EvoX provides a"
" high-performance solver that can obtain near-optimal solutions within a "
"reasonable time frame."
msgstr ""
"**学术研究和工程应用**: 对于研究演化算法的研究人员，EvoX "
"提供了一个高度灵活的平台来实现和测试新的方法。对于工程优化任务（例如调优工业过程参数或调整控制系统），EvoX "
"提供了一个高性能的求解器，可以在合理的时间内获得近乎最优的解决方案。"

#: ../../source/tutorial/tutorial_part1.md:27
msgid ""
"In summary, EvoX is suitable for any optimization task that **requires "
"exploring a large solution space quickly**, as long as the task can be "
"massively parallelized on a GPU. Whether you’re an AI researcher or an "
"engineering developer facing complex optimization problems, EvoX is a "
"powerful tool to improve your solving efficiency."
msgstr ""
"总之，EvoX 适用于任何**需要快速探索大规模解空间**的优化任务，只要该任务能够在 GPU 上进行大规模并行化。无论您是 AI "
"研究人员还是面临复杂优化问题的工程开发人员，EvoX 都是提高解决效率的强大工具。"

#: ../../source/tutorial/tutorial_part1.md:30
msgid ""
"EvoX can run on many GPU devices, including NVIDIA GPUs and AMD GPUs, or "
"even the GPU in your Mac."
msgstr "EvoX 可以运行在多种 GPU 设备上，包括 NVIDIA GPU 和 AMD GPU，甚至是你 Mac 中的 GPU。"

#: ../../source/tutorial/tutorial_part2.md:1
msgid "2. Installation and Environment Setup"
msgstr "2. 安装和环境设置"

#: ../../source/tutorial/tutorial_part2.md:3
msgid ""
"Before using EvoX, you need to properly install the software and its "
"dependencies. This chapter covers installation steps for both Windows and "
"Linux, as well as how to prepare and configure the required dependencies. "
"Make sure you meet the basic system requirements before installation: "
"**Python 3.10+**, sufficient disk space, and optionally a supported GPU with"
" the appropriate driver."
msgstr ""
"在使用 EvoX 之前，您需要正确安装软件及其依赖项。本章包含在 Windows 和 Linux "
"上的安装步骤，以及如何准备和配置所需的依赖项。在安装之前，请确保您满足基本系统要求：**Python "
"3.10+**、充足的磁盘空间，以及可选的具有相应驱动程序的受支持 GPU。"

#: ../../source/tutorial/tutorial_part2.md:5
msgid "Dependencies and Preparations"
msgstr "依赖项和准备工作"

#: ../../source/tutorial/tutorial_part2.md:7
msgid ""
"**Python Environment**: EvoX is built on Python, so ensure Python 3.10 or "
"higher is installed. It’s recommended to use a virtual environment (such as "
"`venv`) to avoid dependency conflicts."
msgstr ""
"**Python 环境**：EvoX 基于 Python 构建，因此请确保已安装 Python 3.10 或更高版本。建议使用虚拟环境（例如 "
"`venv`）来避免依赖冲突。"

#: ../../source/tutorial/tutorial_part2.md:9
msgid ""
"**PyTorch**: EvoX uses PyTorch for tensor operations and hardware "
"acceleration. Therefore, **PyTorch must be installed before installing "
"EvoX**. Choose the version based on your hardware: install the CUDA version "
"if you have an NVIDIA GPU, the ROCm version for AMD GPUs, or the CPU version"
" if no GPU is available. Refer to the [official PyTorch "
"guide](https://pytorch.org) for the appropriate command, for example:"
msgstr ""
"**PyTorch**: EvoX 使用 PyTorch 进行张量操作和硬件加速。因此，**在安装 EvoX 之前必须先安装 "
"PyTorch**。根据您的硬件选择版本：如果您有 NVIDIA GPU，请安装 CUDA 版；如果是 AMD GPU，请安装 ROCm 版；如果没有 "
"GPU，可安装 CPU 版。请参考 [官方 PyTorch 指南](https://pytorch.org) 获取适合的命令，例如："

#: ../../source/tutorial/tutorial_part2.md:22
msgid ""
"It’s recommended to update `pip` to the latest version and ensure a stable "
"internet connection before installation (packages will be downloaded from "
"PyPI). Once the environment is ready, you can install EvoX."
msgstr "建议在安装前将 `pip` 更新到最新版本，并确保稳定的互联网连接（安装包将从 PyPI 下载）。当环境准备好后，您可以安装 EvoX。"

#: ../../source/tutorial/tutorial_part2.md:24
msgid "Installation on Windows"
msgstr "在 Windows 上安装"

#: ../../source/tutorial/tutorial_part2.md:26
msgid ""
"Windows users can choose **automatic script installation** or **manual "
"installation**. The official one-click installer provides an easy way to set"
" up EvoX and its dependencies in a clean environment, but manual "
"installation allows more control."
msgstr ""
"Windows 用户可以选择 **自动脚本安装** 或 **手动安装**。官方的一键安装程序提供了一种在干净环境中设置 EvoX "
"及其依赖项的简便方法，但手动安装可以提供更多控制。"

#: ../../source/tutorial/tutorial_part2.md:28
#, fuzzy
msgid ""
"**Option 1: Using the One-Click Installation Script (win-install.bat)** EvoX"
" provides a [quick installation script](/_static/win-install.bat) for "
"Windows 10/11 (64-bit). The script installs Miniforge3 (a lightweight "
"Conda), Python, PyTorch (with CUDA), EvoX, and useful tools like VSCode and "
"Git. To use:"
msgstr ""
"**Option 1: Using the One-Click Installation Script (win-install.bat)** EvoX"
" provides a [quick installation script](/_static/win-install.bat) for "
"Windows 10/11 (64-bit). The script installs Miniforge3 (a lightweight "
"Conda), Python, PyTorch (with CUDA), EvoX, and useful tools like VSCode and "
"Git. To use:"

#: ../../source/tutorial/tutorial_part2.md:31
msgid ""
"Download `win-install.bat` from the EvoX docs or GitHub. Make sure you have "
"a [NVIDIA driver](https://www.nvidia.com/en-us/drivers/) installed and a "
"stable internet connection."
msgstr ""
"从 EvoX 文档或 GitHub 下载 `win-install.bat`。确保已安装 [NVIDIA "
"driver](https://www.nvidia.com/en-us/drivers/) 并拥有稳定的互联网连接。"

#: ../../source/tutorial/tutorial_part2.md:32
msgid ""
"Run the script. It doesn’t require admin privileges, but may request "
"permission during execution—allow it. The script will install and configure "
"everything automatically."
msgstr "运行脚本。它不需要管理员权限，但可能在执行过程中请求权限——请允许。脚本将自动安装和配置所有内容。"

#: ../../source/tutorial/tutorial_part2.md:33
msgid ""
"Wait for completion. Upon success, you’ll see a message and possibly VSCode "
"opening. EvoX and its dependencies will be installed."
msgstr "等待完成。成功后，您将看到一条消息，可能会打开VSCode。EvoX及其依赖项将被安装。"

#: ../../source/tutorial/tutorial_part2.md:35
msgid ""
"**Note**: If the script fails due to network issues, close it and rerun. It "
"supports resume on failure."
msgstr "**注意**: 如果脚本因为网络问题失败，关闭后重新运行。它支持在失败时继续运行。"

#: ../../source/tutorial/tutorial_part2.md:37
msgid "**Option 2: Manual Installation** To manually install EvoX:"
msgstr "**选项 2：手动安装** 要手动安装 EvoX:"

#: ../../source/tutorial/tutorial_part2.md:40
msgid ""
"**Install GPU Driver**: Install the latest NVIDIA driver from the [official "
"website](https://www.nvidia.cn/Download/index.aspx). If no dedicated GPU, "
"skip this step."
msgstr ""
"**安装 GPU 驱动**：从[官方网站](https://www.nvidia.cn/Download/index.aspx)安装最新的 NVIDIA"
" 驱动。如果没有专用 GPU，请跳过此步骤。"

#: ../../source/tutorial/tutorial_part2.md:42
msgid ""
"**Install Python**: Download [Python 3.10+ for "
"Windows](https://www.python.org/downloads/windows/) and enable “Add Python "
"to PATH” during installation."
msgstr ""
"**安装 Python**: 下载 [Python 3.10+ for "
"Windows](https://www.python.org/downloads/windows/) 并在安装过程中启用“Add Python to "
"PATH”。"

#: ../../source/tutorial/tutorial_part2.md:44
msgid ""
"**Install PyTorch**: Open CMD or PowerShell and install PyTorch based on "
"your hardware:"
msgstr "**安装 PyTorch**：打开 CMD 或 PowerShell，根据您的硬件安装 PyTorch:"

#: ../../source/tutorial/tutorial_part2.md:50
msgid ""
"**(Optional) Install Triton Compiler**: PyTorch on Windows lacks Triton "
"support. If you want to use `torch.compile` (available in PyTorch 2.0), "
"install the third-party [triton-"
"windows](https://github.com/woct0rdho/triton-windows). Optional but useful "
"for performance optimization."
msgstr ""
"**（可选）安装 Triton Compiler**：Windows 上的 PyTorch 不支持 Triton。如果你想使用 "
"`torch.compile`（在 PyTorch 2.0 中可用），可以安装第三方 [triton-"
"windows](https://github.com/woct0rdho/triton-windows)。可选安装，但对于性能优化很有帮助。"

#: ../../source/tutorial/tutorial_part2.md:52
#: ../../source/tutorial/tutorial_part2.md:98
msgid "**Install EvoX**:"
msgstr "**安装 EvoX**"

#: ../../source/tutorial/tutorial_part2.md:64
msgid ""
"Some packages may require additional system dependencies. If this is the "
"case, the installer will prompt you with a message like the following:"
msgstr ""
"Some packages may require additional system dependencies. If this is the "
"case, the installer will prompt you with a message like the following:"

#: ../../source/tutorial/tutorial_part2.md:70
msgid ""
"When you encounter such messages, follow the provided instructions to "
"install the necessary dependencies before proceeding."
msgstr ""
"When you encounter such messages, follow the provided instructions to "
"install the necessary dependencies before proceeding."

#: ../../source/tutorial/tutorial_part2.md:74
msgid "Installation on Linux"
msgstr "在 Linux 上安装"

#: ../../source/tutorial/tutorial_part2.md:76
msgid ""
"Installing EvoX on Linux (e.g., Ubuntu) is straightforward and mostly "
"handled via `pip`."
msgstr "在 Linux（例如 Ubuntu）上安装 EvoX 非常简单，大部分通过 `pip` 处理。"

#: ../../source/tutorial/tutorial_part2.md:78
msgid ""
"**Install System Dependencies**: Make sure basic development tools and "
"Python 3.10+ are installed. You can use a package manager (apt, yum) or "
"Anaconda."
msgstr "**安装系统依赖**：确保已安装基本开发工具和 Python 3.10+。您可以使用包管理器（如 apt、yum）或 Anaconda。"

#: ../../source/tutorial/tutorial_part2.md:80
msgid ""
"**Install GPU Driver** (if using GPU): Use the appropriate package manager "
"(e.g., `apt`) to install NVIDIA drivers. Verify installation with `nvidia-"
"smi`. Skip if using CPU."
msgstr ""
"**安装 GPU 驱动**（如果使用 GPU）：使用合适的包管理器（例如 `apt`）安装 NVIDIA 驱动。使用 `nvidia-smi` "
"验证安装。如果使用 CPU，可跳过此步骤。"

#: ../../source/tutorial/tutorial_part2.md:83
msgid ""
"On WSL, **do not** install NVIDIA drivers inside the Linux subsystem—install"
" them on the Windows side."
msgstr "在 WSL 上，**不要**在 Linux 子系统内安装 NVIDIA 驱动——请在 Windows 上安装它们。"

#: ../../source/tutorial/tutorial_part2.md:87
msgid ""
"It's very likely that you only need to install the driver, but do NOT need "
"to install CUDA or other dependencies. Those libraries are already included "
"in the PyTorch installation via pip."
msgstr "很可能你只需要安装驱动程序，而不需要安装CUDA或其他依赖项。这些库已经通过pip包含在PyTorch安装中。"

#: ../../source/tutorial/tutorial_part2.md:92
msgid ""
"The required driver version depends on your hardware. If you have a recent "
"NVIDIA GPU, using the latest driver version is often the best choice. To "
"ensure better compatibility and access to the latest drivers, it's generally"
" a good idea to use a newer Linux distribution (e.g., Ubuntu 25.04 instead "
"of 22.04)."
msgstr ""
"The required driver version depends on your hardware. If you have a recent "
"NVIDIA GPU, using the latest driver version is often the best choice. To "
"ensure better compatibility and access to the latest drivers, it's generally"
" a good idea to use a newer Linux distribution (e.g., Ubuntu 25.04 instead "
"of 22.04)."

#: ../../source/tutorial/tutorial_part2.md:96
msgid ""
"**Install PyTorch**: As on Windows, install based on hardware. Refer to the "
"[PyTorch official guide](https://pytorch.org)."
msgstr ""
"**安装 PyTorch**：与在 Windows 上一样，基于硬件进行安装。参考 [PyTorch "
"官方指南](https://pytorch.org)。"

#: ../../source/tutorial/tutorial_part2.md:104
msgid "Or with extras:"
msgstr "或者包含额外内容："

#: ../../source/tutorial/tutorial_part2.md:110
msgid ""
"This installs visualization modules and neuroevolution dependencies (like "
"Brax). You can also choose individual extras like `vis` or `neuroevolution`."
msgstr ""
"此操作会安装可视化模块和神经演化依赖项（例如 Brax）。您也可以选择单独的附加组件，例如 `vis` 或 `neuroevolution`。"

#: ../../source/tutorial/tutorial_part2.md:112
msgid "Container Installation (Docker, Podman)"
msgstr "容器安装 (Docker, Podman)"

#: ../../source/tutorial/tutorial_part2.md:114
msgid ""
"For AMD GPU users or those seeking environment isolation, Docker is "
"recommended. For example, using the official PyTorch Docker image with ROCm:"
msgstr ""
"对于使用 AMD GPU 的用户或需要环境隔离的用户，推荐使用 Docker。例如，使用官方 PyTorch Docker 镜像与 ROCm:"

#: ../../source/tutorial/tutorial_part2.md:120
msgid "Inside the container, install EvoX as usual using `pip`."
msgstr "在容器内，使用 `pip` 像往常一样安装 EvoX。"

#: ../../source/tutorial/tutorial_part2.md:122
msgid "Verifying EvoX Installation"
msgstr "验证 EvoX 安装"

#: ../../source/tutorial/tutorial_part2.md:124
msgid "To verify that EvoX is properly installed:"
msgstr "要验证 EvoX 是否已正确安装："

#: ../../source/tutorial/tutorial_part2.md:126
msgid "**Basic Check**: In terminal or Python shell, run:"
msgstr "**基本检查**：在终端或 Python shell 中运行："

#: ../../source/tutorial/tutorial_part2.md:134
msgid ""
"This prints PyTorch and system configuration info. If EvoX is imported "
"without errors, the installation was successful. You can also check the "
"version:"
msgstr "这将打印PyTorch和系统配置信息。如果EvoX导入没有报错，则说明安装成功。你也可以检查版本："

#: ../../source/tutorial/tutorial_part2.md:141
msgid ""
"**Optional Settings**: You may tune performance-related settings, such as:"
msgstr "**可选设置**: 您可以调整与性能相关的设置，例如:"

#: ../../source/tutorial/tutorial_part2.md:143
msgid ""
"Setting environment variables like `OMP_NUM_THREADS` to control CPU thread "
"count"
msgstr "设置环境变量如 `OMP_NUM_THREADS` 来控制 CPU 线程数量"

#: ../../source/tutorial/tutorial_part2.md:144
msgid "Increasing Docker shared memory with `--shm-size`"
msgstr "增加 Docker 共享内存大小使用 `--shm-size`"

#: ../../source/tutorial/tutorial_part2.md:145
msgid ""
"Ensuring your IDE (Jupyter, PyCharm, etc.) uses the correct Python "
"environment"
msgstr "确保您的IDE（如Jupyter、PyCharm等）使用正确的Python环境"

#: ../../source/tutorial/tutorial_part2.md:147
msgid ""
"Once the setup is complete, you're ready to start optimizing with EvoX."
msgstr "一旦设置完成，您就可以使用 EvoX 开始优化了。"

#: ../../source/tutorial/tutorial_part3.md:1
msgid "3. Basic Operations"
msgstr "3. 基本操作"

#: ../../source/tutorial/tutorial_part3.md:3
msgid ""
"In this chapter, we will guide you through running your first EvoX "
"optimization task, including how to **start EvoX** and **initialize the "
"optimization process**, how to **configure an EvoX project** (selecting "
"algorithms and problems and assembling them), and the commonly used **basic "
"commands** (or methods) to control the optimization process. Through a "
"simple example, you will learn the basic usage of EvoX."
msgstr ""
"在本章节中，我们将指导您运行您的第一个 EvoX 优化任务，包括如何**启动 EvoX**和**初始化优化过程**，如何**配置 EvoX "
"项目**（选择算法和问题并组合它们），以及常用的**基本命令**（或方法）来控制优化过程。通过一个简单的示例，您将学习 EvoX 的基本使用方法。"

#: ../../source/tutorial/tutorial_part3.md:5
msgid "Starting and Initializing"
msgstr "Starting and Initializing"

#: ../../source/tutorial/tutorial_part3.md:7
msgid ""
"After verifying the installation, you can start writing optimization scripts"
" using EvoX. You can import EvoX in any Python environment (such as "
"terminal, Jupyter Notebook, IDE, etc.)."
msgstr ""
"在验证安装后，您可以开始使用 EvoX 编写优化脚本。您可以在任何 Python 环境中（如终端、Jupyter Notebook、IDE 等）导入 "
"EvoX。"

#: ../../source/tutorial/tutorial_part3.md:9
msgid ""
"First, let’s import EvoX and its related modules, and initialize a simple "
"optimization task. For example, we will use the Particle Swarm Optimization "
"(PSO) algorithm to optimize the classic Ackley function. The Ackley function"
" is a common benchmark function with a known global optimum at "
"\\((0,0,\\dots,0)\\), making it suitable for demonstration. Here is a "
"minimal EvoX example code that demonstrates how to start and run the "
"optimization:"
msgstr ""
"首先，让我们导入 EvoX 及其相关模块，并初始化一个简单的优化任务。例如，我们将使用 Particle Swarm Optimization (PSO) 算法来优化经典的 Ackley 函数。Ackley 函数是一个常见的基准函数，其已知全局最优值位于 \\((0,0,\\dots,0)\\)，因此非常适合用于演示。以下是一个最简洁的 EvoX 示例代码，展示如何开始并运行优化任务：\n"
"\n"
"```python\n"
"# Python code segment remains unchanged\n"
"```"

#: ../../source/tutorial/tutorial_part3.md:42
msgid "The above code includes the following steps:"
msgstr "以上代码包含以下步骤："

#: ../../source/tutorial/tutorial_part3.md:43
msgid ""
"First, we set the parameters for the PSO algorithm: population size of 50 "
"and a search space in 2D ranging from [-32, 32]."
msgstr "首先，我们为PSO算法设置参数：种群大小为50，搜索空间为二维，范围从[-32, 32]。"

#: ../../source/tutorial/tutorial_part3.md:44
msgid ""
"Then, we define the Ackley problem (the Ackley function is defined as 2D by "
"default)."
msgstr "然后，我们定义 Ackley 问题（Ackley 函数默认定义为二维）。"

#: ../../source/tutorial/tutorial_part3.md:45
msgid ""
"We create a standard workflow `StdWorkflow` that **assembles** the algorithm"
" and problem, and pass in a monitor `EvalMonitor` to record the optimization"
" process data."
msgstr ""
"我们创建一个标准工作流 `StdWorkflow`，**组装**算法和问题，并传入一个监视器 `EvalMonitor` 来记录优化过程数据。"

#: ../../source/tutorial/tutorial_part3.md:46
msgid ""
"Next, we complete the initialization process using `workflow.init_step()`, "
"which automatically initializes the population, random seed, and other "
"internal states."
msgstr "接下来，我们使用 `workflow.init_step()` 完成初始化过程，该函数会自动初始化种群、随机种子以及其他内部状态。"

#: ../../source/tutorial/tutorial_part3.md:47
msgid ""
"Then, we run a loop to continuously execute 100 iterations using "
"`workflow.step()`. Each time `step()` is called, the algorithm generates new"
" solutions and evaluates their fitness, continuously approaching the optimal"
" solution."
msgstr ""
"然后，我们运行一个循环，使用 `workflow.step()` 连续执行 100 次迭代。每次调用 `step()` "
"时，算法会生成新的解并评估它们的适应度，不断接近最优解。"

#: ../../source/tutorial/tutorial_part3.md:48
msgid ""
"Finally, we use the method `get_min_fitness()` provided by the monitor to "
"obtain the best fitness value during the iteration process and print it out."
msgstr "最后，我们使用监视器提供的 `get_min_fitness()` 方法来获取迭代过程中最佳的适应度值并将其打印出来。"

#: ../../source/tutorial/tutorial_part3.md:50
msgid ""
"When you run this script, you will see the output of the optimization "
"iterations, for example:"
msgstr "当你运行此脚本时，你将看到优化迭代的输出，例如："

#: ../../source/tutorial/tutorial_part3.md:56
msgid ""
"Since we did not explicitly print the intermediate results in the loop, the "
"intermediate results will not be displayed. However, you can judge whether "
"the algorithm has converged based on the final fitness value. For example, "
"the optimal value of the Ackley function is 0, and if the output is close to"
" 0, it indicates that PSO has found a solution close to the global optimum. "
"You can also call `print(monitor.history)` to view the historical data "
"recorded by the monitor or use `monitor.plot()` to plot convergence curves "
"(requires visualization support like Plotly)."
msgstr ""
"由于我们没有在循环中显式打印中间结果，中间结果不会显示出来。然而，你可以根据最终适应度值判断算法是否收敛。例如，Ackley函数的最优值是0，如果输出值接近0，这表明PSO找到的解决方案接近全局最优。你也可以调用"
" `print(monitor.history)` 查看由monitor记录的历史数据，或者使用 `monitor.plot()` "
"绘制收敛曲线（需要类似Plotly的可视化支持）。"

#: ../../source/tutorial/tutorial_part3.md:59
msgid ""
"`StdWorkflow` is a **standard optimization process** encapsulation provided "
"by EvoX. It internally implements the \"initialization-iteration update\" "
"logic found in traditional evolutionary algorithms and encapsulates the "
"interaction between the algorithm and the problem. For most simple "
"applications, using `StdWorkflow` directly will suffice. The `EvalMonitor` "
"is a monitor that implements methods like `get_best_fitness()` and `plot()` "
"to collect and display performance metrics during the optimization process. "
"Beginners can temporarily understand it as a record book that records the "
"best results of each iteration for later analysis."
msgstr ""
"`StdWorkflow` 是由 EvoX 提供的**标准优化过程**封装。它内部实现了传统演化算法中常见的“初始化-"
"迭代更新”的逻辑，并封装了算法与问题之间的交互。对于大多数简单应用，直接使用 `StdWorkflow` 即可满足需求。`EvalMonitor` "
"是一个监视器，提供了像 `get_best_fitness()` 和 `plot()` "
"这样的方法，用于收集并展示优化过程中性能指标。初学者可以暂时将其理解为一本记录簿，用来记录每次迭代的最佳结果，便于后期分析。"

#: ../../source/tutorial/tutorial_part3.md:62
msgid ""
"In the example above, we've created a basic configuration for an EvoX "
"project, including selecting an algorithm, defining the problem, and "
"assembling the workflow. Generally, configuring an EvoX project involves the"
" following steps:"
msgstr ""
"在上面的示例中，我们为一个EvoX项目创建了一个基本配置，包括选择一个算法、定义问题以及组装工作流。通常，配置一个EvoX项目包括以下步骤："

#: ../../source/tutorial/tutorial_part3.md:64
msgid ""
"**Select/Define an Optimization Problem**: Clarify what optimization problem"
" you're trying to solve. For example, if you're optimizing a mathematical "
"function, EvoX provides many **built-in problems** under the `evox.problems`"
" module (e.g., classic functions like Sphere, Rastrigin, Ackley) that you "
"can use directly. If your problem isn't covered by the built-ins, you can "
"define your own (covered in a later chapter). When configuring a problem, "
"you usually need to know the **dimension of the decision variables** and "
"their **value range**."
msgstr ""
"**Select/Define an Optimization Problem**: Clarify what optimization problem"
" you're trying to solve. For example, if you're optimizing a mathematical "
"function, EvoX provides many **built-in problems** under the `evox.problems`"
" module (e.g., classic functions like Sphere, Rastrigin, Ackley) that you "
"can use directly. If your problem isn't covered by the built-ins, you can "
"define your own (covered in a later chapter). When configuring a problem, "
"you usually need to know the **dimension of the decision variables** and "
"their **value range**."

#: ../../source/tutorial/tutorial_part3.md:66
msgid ""
"**Select/Configure an Optimization Algorithm**: Choose an appropriate "
"evolutionary algorithm based on the problem type. EvoX provides a rich set "
"of algorithms under `evox.algorithms`, including single-objective algorithms"
" (like PSO, GA, CMA-ES) and multi-objective algorithms (like NSGA-II, RVEA)."
" After choosing the algorithm, you’ll generally need to set algorithm "
"parameters, such as population size (`pop_size`) and algorithm-specific "
"parameters (like crossover probability and mutation probability in GA). Most"
" algorithms require the **variable range** (lower bound `lb` and upper bound"
" `ub`) and problem dimension to initialize the population. If you're using a"
" multi-objective algorithm, you'll also need to specify the number of "
"objectives (`n_objs`). EvoX's algorithms often provide default values for "
"common hyperparameters, but beginners should consider tuning these "
"parameters based on the task for better performance."
msgstr ""
"**Select/Configure an Optimization Algorithm**: Choose an appropriate "
"evolutionary algorithm based on the problem type. EvoX provides a rich set "
"of algorithms under `evox.algorithms`, including single-objective algorithms"
" (like PSO, GA, CMA-ES) and multi-objective algorithms (like NSGA-II, RVEA)."
" After choosing the algorithm, you’ll generally need to set algorithm "
"parameters, such as population size (`pop_size`) and algorithm-specific "
"parameters (like crossover probability and mutation probability in GA). Most"
" algorithms require the **variable range** (lower bound `lb` and upper bound"
" `ub`) and problem dimension to initialize the population. If you're using a"
" multi-objective algorithm, you'll also need to specify the number of "
"objectives (`n_objs`). EvoX's algorithms often provide default values for "
"common hyperparameters, but beginners should consider tuning these "
"parameters based on the task for better performance."

#: ../../source/tutorial/tutorial_part3.md:68
msgid ""
"**Assemble the Workflow**: With the algorithm and problem instance ready, "
"you need to \"assemble\" them into a workflow, which represents the full "
"optimization process control. In EvoX, `StdWorkflow` is typically used to "
"combine the algorithm and the problem. If you want to monitor optimization "
"progress, you can add a monitor (like `EvalMonitor`) to the workflow. A "
"monitor isn't required, but it can be very helpful during debugging and "
"analysis. Assembling the workflow usually takes one line of code, like: "
"`workflow = StdWorkflow(algo, prob, monitor)`."
msgstr ""
"**Assemble the Workflow**: With the algorithm and problem instance ready, "
"you need to \"assemble\" them into a workflow, which represents the full "
"optimization process control. In EvoX, `StdWorkflow` is typically used to "
"combine the algorithm and the problem. If you want to monitor optimization "
"progress, you can add a monitor (like `EvalMonitor`) to the workflow. A "
"monitor isn't required, but it can be very helpful during debugging and "
"analysis. Assembling the workflow usually takes one line of code, like: "
"`workflow = StdWorkflow(algo, prob, monitor)`."

#: ../../source/tutorial/tutorial_part3.md:70
msgid ""
"**Initialize**: Call the workflow’s initialization method to begin "
"optimization. The latest version of EvoX provides a convenient "
"`StdWorkflow.init_step()` method that completes the initialization process "
"in one call."
msgstr ""
"**Initialize**: Call the workflow’s initialization method to begin "
"optimization. The latest version of EvoX provides a convenient "
"`StdWorkflow.init_step()` method that completes the initialization process "
"in one call."

#: ../../source/tutorial/tutorial_part3.md:72
msgid ""
"**Run Iterations**: Use a loop to repeatedly call `workflow.step()` to drive"
" the evolutionary process forward. Each call performs one iteration, "
"including steps like “generate new solutions -> evaluate -> select” inside "
"the algorithm. During iterations, you can use a monitor to observe real-time"
" results, like printing the current best fitness every few generations. "
"Termination criteria can be set based on your needs — common ones include a "
"fixed number of generations (e.g., run for 100 generations), or stopping "
"when monitored metrics converge (e.g., no significant improvement over "
"several generations)."
msgstr ""
"**Run Iterations**: Use a loop to repeatedly call `workflow.step()` to drive"
" the evolutionary process forward. Each call performs one iteration, "
"including steps like “generate new solutions -> evaluate -> select” inside "
"the algorithm. During iterations, you can use a monitor to observe real-time"
" results, like printing the current best fitness every few generations. "
"Termination criteria can be set based on your needs — common ones include a "
"fixed number of generations (e.g., run for 100 generations), or stopping "
"when monitored metrics converge (e.g., no significant improvement over "
"several generations)."

#: ../../source/tutorial/tutorial_part3.md:74
msgid ""
"**Obtain Results**: After iterations end, you need to extract the final "
"results from the algorithm — such as the best solution and its objective "
"value. In EvoX, these are typically obtained via the monitor. For example, "
"`EvalMonitor.get_best_fitness()` returns the best fitness value. To get the "
"best solution vector, one way is to have the problem object store the best "
"candidate during evaluation, or use the monitor’s interface. In EvoX’s "
"standard implementation, `EvalMonitor` records the best individual and "
"fitness each generation, accessible through its properties. Assuming "
"`monitor.history` stores the history, you can retrieve the best individual "
"from the last generation. Of course, you can also skip `EvalMonitor` and "
"directly query the algorithm object after the loop — this depends on the "
"algorithm implementation. If your custom algorithm implements `get_best()` "
"or stores the best individual in its state, you can extract it directly. "
"However, since EvoX emphasizes pure functions and modularity, results are "
"usually accessed via monitoring modules."
msgstr ""
"**Obtain Results**: After iterations end, you need to extract the final "
"results from the algorithm — such as the best solution and its objective "
"value. In EvoX, these are typically obtained via the monitor. For example, "
"`EvalMonitor.get_best_fitness()` returns the best fitness value. To get the "
"best solution vector, one way is to have the problem object store the best "
"candidate during evaluation, or use the monitor’s interface. In EvoX’s "
"standard implementation, `EvalMonitor` records the best individual and "
"fitness each generation, accessible through its properties. Assuming "
"`monitor.history` stores the history, you can retrieve the best individual "
"from the last generation. Of course, you can also skip `EvalMonitor` and "
"directly query the algorithm object after the loop — this depends on the "
"algorithm implementation. If your custom algorithm implements `get_best()` "
"or stores the best individual in its state, you can extract it directly. "
"However, since EvoX emphasizes pure functions and modularity, results are "
"usually accessed via monitoring modules."

#: ../../source/tutorial/tutorial_part3.md:76
msgid ""
"By following these steps, you can clearly structure your optimization task "
"code. For beginners, it's important to understand how the **algorithm-"
"problem-workflow** trio works together: the algorithm handles generating and"
" improving solutions, the problem evaluates their quality, and the workflow "
"connects them into an iterative loop."
msgstr ""
"By following these steps, you can clearly structure your optimization task "
"code. For beginners, it's important to understand how the **algorithm-"
"problem-workflow** trio works together: the algorithm handles generating and"
" improving solutions, the problem evaluates their quality, and the workflow "
"connects them into an iterative loop."

#: ../../source/tutorial/tutorial_part3.md:78
msgid ""
"Next, we’ll introduce some basic commands and function calls available in "
"EvoX to help deepen your understanding of the optimization process."
msgstr ""
"Next, we’ll introduce some basic commands and function calls available in "
"EvoX to help deepen your understanding of the optimization process."

#: ../../source/tutorial/tutorial_part3.md:80
msgid "Basic Command Overview"
msgstr "Basic Command Overview"

#: ../../source/tutorial/tutorial_part3.md:82
msgid ""
"When using EvoX, there are some **commonly used methods and functions** that"
" act as “commands” you’ll want to be familiar with:"
msgstr ""
"When using EvoX, there are some **commonly used methods and functions** that"
" act as “commands” you’ll want to be familiar with:"

#: ../../source/tutorial/tutorial_part3.md:84
msgid "Workflow-Related Methods"
msgstr "Workflow-Related Methods"

#: ../../source/tutorial/tutorial_part3.md:86
msgid ""
"**`StdWorkflow.init_step()`**: Initialization. This is a quick-start command"
" for launching the optimization process, often used at the beginning of a "
"script. It calls the initialization logic for both the algorithm and "
"problem, generates the initial population, and evaluates fitness. After "
"this, the workflow contains the initial state and is ready for iteration."
msgstr ""
"**`StdWorkflow.init_step()`**: Initialization. This is a quick-start command"
" for launching the optimization process, often used at the beginning of a "
"script. It calls the initialization logic for both the algorithm and "
"problem, generates the initial population, and evaluates fitness. After "
"this, the workflow contains the initial state and is ready for iteration."

#: ../../source/tutorial/tutorial_part3.md:88
msgid ""
"**`StdWorkflow.step()`**: Advance one step in the optimization. Each call "
"makes the algorithm generate new candidate solutions based on the current "
"population state, evaluate them, and select the next generation. Users "
"typically call this multiple times inside a loop. The `step()` function "
"usually returns nothing (the internal state is updated within the workflow),"
" though older versions may return a new state. For beginners, you can simply"
" call it without worrying about the return value."
msgstr ""
"**`StdWorkflow.step()`**: Advance one step in the optimization. Each call "
"makes the algorithm generate new candidate solutions based on the current "
"population state, evaluate them, and select the next generation. Users "
"typically call this multiple times inside a loop. The `step()` function "
"usually returns nothing (the internal state is updated within the workflow),"
" though older versions may return a new state. For beginners, you can simply"
" call it without worrying about the return value."

#: ../../source/tutorial/tutorial_part3.md:90
#, fuzzy
msgid "Monitor-Related Methods"
msgstr "Monitor-Related Methods"

#: ../../source/tutorial/tutorial_part3.md:92
msgid "Using `EvalMonitor` as an example, the common methods include:"
msgstr "Using `EvalMonitor` as an example, the common methods include:"

#: ../../source/tutorial/tutorial_part3.md:94
msgid ""
"`EvalMonitor.get_best_fitness()`: Returns the lowest recorded fitness (for "
"minimization problems) or highest fitness (for maximization problems; the "
"monitor usually distinguishes this). Useful for knowing the current best "
"result."
msgstr ""
"`EvalMonitor.get_best_fitness()`: Returns the lowest recorded fitness (for "
"minimization problems) or highest fitness (for maximization problems; the "
"monitor usually distinguishes this). Useful for knowing the current best "
"result."

#: ../../source/tutorial/tutorial_part3.md:95
msgid ""
"`EvalMonitor.get_history()` or `monitor.history`: Retrieves the full "
"history, such as the best value from each generation. Useful for analyzing "
"convergence trends."
msgstr ""
"`EvalMonitor.get_history()` or `monitor.history`: Retrieves the full "
"history, such as the best value from each generation. Useful for analyzing "
"convergence trends."

#: ../../source/tutorial/tutorial_part3.md:96
msgid ""
"`EvalMonitor.plot()`: Plots convergence or performance curves; requires a "
"graphical environment or Notebook. The monitor usually uses Plotly to render"
" graphs, helping you visually assess algorithm performance. Internally, the "
"monitor records the number of evaluations and their results each generation "
"— you typically don't need to intervene, just extract the data when needed."
msgstr ""
"`EvalMonitor.plot()`: Plots convergence or performance curves; requires a "
"graphical environment or Notebook. The monitor usually uses Plotly to render"
" graphs, helping you visually assess algorithm performance. Internally, the "
"monitor records the number of evaluations and their results each generation "
"— you typically don't need to intervene, just extract the data when needed."

#: ../../source/tutorial/tutorial_part3.md:99
#, fuzzy
msgid "Algorithm-Related Methods"
msgstr "Algorithm-Related Methods"

#: ../../source/tutorial/tutorial_part3.md:101
msgid ""
"`Algorithm.__init__()` method: Initialization method of an algorithm. "
"Variables are usually wrapped using `evox.core.Mutable()` and "
"hyperparameters with `evox.core.Parameter()`."
msgstr ""
"`Algorithm.__init__()` method: Initialization method of an algorithm. "
"Variables are usually wrapped using `evox.core.Mutable()` and "
"hyperparameters with `evox.core.Parameter()`."

#: ../../source/tutorial/tutorial_part3.md:103
msgid ""
"`Algorithm.step()` method: In specific scenarios or when using custom "
"algorithms/problems, you might directly call the algorithm’s `step()` "
"method, which typically encapsulates the entire iteration logic of the "
"algorithm."
msgstr ""
"`Algorithm.step()` method: In specific scenarios or when using custom "
"algorithms/problems, you might directly call the algorithm’s `step()` "
"method, which typically encapsulates the entire iteration logic of the "
"algorithm."

#: ../../source/tutorial/tutorial_part3.md:105
msgid ""
"`Algorithm.init_step()` method: The `init_step()` method includes the "
"algorithm’s first iteration. If not overridden, it simply calls the `step()`"
" method. For typical cases, the first iteration is no different from others,"
" so many algorithms may not need a custom `init_step()`. But for algorithms "
"involving hyperparameter tuning, you may need to update hyperparameters or "
"related variables here."
msgstr ""
"`Algorithm.init_step()` method: The `init_step()` method includes the "
"algorithm’s first iteration. If not overridden, it simply calls the `step()`"
" method. For typical cases, the first iteration is no different from others,"
" so many algorithms may not need a custom `init_step()`. But for algorithms "
"involving hyperparameter tuning, you may need to update hyperparameters or "
"related variables here."

#: ../../source/tutorial/tutorial_part3.md:107
msgid "Device and Parallel Control"
msgstr "Device and Parallel Control"

#: ../../source/tutorial/tutorial_part3.md:109
msgid ""
"`.to(device)` method: If you need to switch computation devices in your "
"program, use PyTorch’s `.to(device)` method to move tensors (`torch.Tensor`)"
" to GPU/CPU (some PyTorch methods like `torch.randn` also need the device "
"specified). Generally, if you set the device using "
"`torch.set_default_device()` to `cuda:0` (assuming your system supports it "
"and EvoX and dependencies are installed correctly — verify with "
"`torch.cuda.is_available()`), most EvoX high-performance parallel "
"computations will run on GPU automatically. When writing custom algorithms, "
"problems, or monitors, if you create new tensors or use device-sensitive "
"PyTorch methods, it’s recommended to explicitly specify the `device` as "
"`cuda:0` or use `torch.get_default_device()` to avoid performance drops from"
" computations spread across different devices."
msgstr ""
"`.to(device)` method: If you need to switch computation devices in your "
"program, use PyTorch’s `.to(device)` method to move tensors (`torch.Tensor`)"
" to GPU/CPU (some PyTorch methods like `torch.randn` also need the device "
"specified). Generally, if you set the device using "
"`torch.set_default_device()` to `cuda:0` (assuming your system supports it "
"and EvoX and dependencies are installed correctly — verify with "
"`torch.cuda.is_available()`), most EvoX high-performance parallel "
"computations will run on GPU automatically. When writing custom algorithms, "
"problems, or monitors, if you create new tensors or use device-sensitive "
"PyTorch methods, it’s recommended to explicitly specify the `device` as "
"`cuda:0` or use `torch.get_default_device()` to avoid performance drops from"
" computations spread across different devices."

#: ../../source/tutorial/tutorial_part3.md:111
msgid ""
"For beginners, the above methods are sufficient for handling typical "
"optimization tasks. In short: **Initialize problem/algorithm – set up "
"monitor – assemble workflow – run and retrieve results** is the most common "
"EvoX workflow. Mastering these allows you to tackle basic optimization tasks"
" using EvoX."
msgstr ""
"For beginners, the above methods are sufficient for handling typical "
"optimization tasks. In short: **Initialize problem/algorithm – set up "
"monitor – assemble workflow – run and retrieve results** is the most common "
"EvoX workflow. Mastering these allows you to tackle basic optimization tasks"
" using EvoX."

#: ../../source/tutorial/tutorial_part3.md:113
msgid ""
"Before moving on to the next chapter, try modifying the example: switch from"
" PSO to another algorithm, replace the Ackley function with another test "
"function, or use the monitor to extract more information — this will help "
"you appreciate the flexibility of configuring EvoX projects."
msgstr ""
"Before moving on to the next chapter, try modifying the example: switch from"
" PSO to another algorithm, replace the Ackley function with another test "
"function, or use the monitor to extract more information — this will help "
"you appreciate the flexibility of configuring EvoX projects."

#: ../../source/tutorial/tutorial_part4.md:1
#, fuzzy
msgid "4. Advanced Features"
msgstr "4. Advanced Features"

#: ../../source/tutorial/tutorial_part4.md:3
msgid ""
"EvoX offers many **advanced features** to meet more complex needs. After "
"getting familiar with the basics, this chapter introduces how to customize "
"the framework configuration, manage optional plugin modules, and optimize "
"performance—enabling you to extend and tune EvoX when necessary."
msgstr ""
"EvoX offers many **advanced features** to meet more complex needs. After "
"getting familiar with the basics, this chapter introduces how to customize "
"the framework configuration, manage optional plugin modules, and optimize "
"performance—enabling you to extend and tune EvoX when necessary."

#: ../../source/tutorial/tutorial_part4.md:5
#, fuzzy
msgid "Custom Configuration"
msgstr "Custom Configuration"

#: ../../source/tutorial/tutorial_part4.md:7
msgid ""
"EvoX's default settings suit most situations, but sometimes you might want "
"to customize the framework’s behavior or parameters. For example:"
msgstr ""
"EvoX's default settings suit most situations, but sometimes you might want "
"to customize the framework’s behavior or parameters. For example:"

#: ../../source/tutorial/tutorial_part4.md:9
msgid ""
"**Tuning Algorithm Parameters**: Beyond basic population size and number of "
"iterations, many algorithms expose advanced parameters. For example, CMA-ES "
"allows configuration of the initial covariance matrix, and NSGA-II exposes "
"crowding distance parameters. You can pass parameters to the algorithm's "
"constructor, e.g., `GA(crossover_prob=0.9, mutation_prob=0.1)` customizes "
"crossover and mutation probabilities in Genetic Algorithm. Tuning these can "
"fine-tune performance. Refer to the EvoX documentation for each algorithm’s "
"API, where available parameters and defaults are listed."
msgstr ""
"**Tuning Algorithm Parameters**: Beyond basic population size and number of "
"iterations, many algorithms expose advanced parameters. For example, CMA-ES "
"allows configuration of the initial covariance matrix, and NSGA-II exposes "
"crowding distance parameters. You can pass parameters to the algorithm's "
"constructor, e.g., `GA(crossover_prob=0.9, mutation_prob=0.1)` customizes "
"crossover and mutation probabilities in Genetic Algorithm. Tuning these can "
"fine-tune performance. Refer to the EvoX documentation for each algorithm’s "
"API, where available parameters and defaults are listed."

#: ../../source/tutorial/tutorial_part4.md:11
msgid ""
"**Replacing Operator Components**: You can replace internal evolutionary "
"operators (e.g., selection or mutation strategies). Some algorithm classes "
"support passing custom operator objects. For example, Differential Evolution"
" (DE) may support custom mutation operators, allowing you to provide a "
"custom function or `Operator` class. EvoX’s modular design supports this "
"\"plugin-style\" replacement. This typically requires understanding the "
"algorithm internals and isn't usually necessary for standard use cases."
msgstr ""
"**Replacing Operator Components**: You can replace internal evolutionary "
"operators (e.g., selection or mutation strategies). Some algorithm classes "
"support passing custom operator objects. For example, Differential Evolution"
" (DE) may support custom mutation operators, allowing you to provide a "
"custom function or `Operator` class. EvoX’s modular design supports this "
"\"plugin-style\" replacement. This typically requires understanding the "
"algorithm internals and isn't usually necessary for standard use cases."

#: ../../source/tutorial/tutorial_part4.md:13
msgid ""
"**Multi-Objective Settings**: For multi-objective optimization, you might "
"need to configure preferences or weights—for example, setting weight vectors"
" for weighted sum methods or adjusting reference points during evolution. "
"These configurations are typically exposed via parameters in the problem or "
"algorithm class. For instance, `problem = DTLZ2(d=12, m=3)` defines a "
"12-dimensional, 3-objective problem. Some algorithms allow passing custom "
"reference vectors. Reading algorithm documentation helps you fully leverage "
"such settings."
msgstr ""
"**Multi-Objective Settings**: For multi-objective optimization, you might "
"need to configure preferences or weights—for example, setting weight vectors"
" for weighted sum methods or adjusting reference points during evolution. "
"These configurations are typically exposed via parameters in the problem or "
"algorithm class. For instance, `problem = DTLZ2(d=12, m=3)` defines a "
"12-dimensional, 3-objective problem. Some algorithms allow passing custom "
"reference vectors. Reading algorithm documentation helps you fully leverage "
"such settings."

#: ../../source/tutorial/tutorial_part4.md:15
msgid ""
"**Logging and Output**: The default `EvalMonitor` already logs key "
"optimization metrics. If you need extra info (e.g., population diversity or "
"average fitness per generation), you can customize the monitor or log "
"manually within your loop. For long-running tasks, you may want to log to a "
"file. This can be done using Python’s `logging` library or simple file I/O "
"to append results for later analysis."
msgstr ""
"**Logging and Output**: The default `EvalMonitor` already logs key "
"optimization metrics. If you need extra info (e.g., population diversity or "
"average fitness per generation), you can customize the monitor or log "
"manually within your loop. For long-running tasks, you may want to log to a "
"file. This can be done using Python’s `logging` library or simple file I/O "
"to append results for later analysis."

#: ../../source/tutorial/tutorial_part4.md:17
msgid ""
"In summary, custom configuration means modifying EvoX’s default behavior for"
" a specific task. This usually involves deeper usage of EvoX's API. We’ll "
"cover more in the **development and extension** section. For beginners, just"
" remember: EvoX offers flexible interfaces that let experienced users tweak "
"nearly every detail—but you can also stick with defaults and get results "
"quickly."
msgstr ""
"In summary, custom configuration means modifying EvoX’s default behavior for"
" a specific task. This usually involves deeper usage of EvoX's API. We’ll "
"cover more in the **development and extension** section. For beginners, just"
" remember: EvoX offers flexible interfaces that let experienced users tweak "
"nearly every detail—but you can also stick with defaults and get results "
"quickly."

#: ../../source/tutorial/tutorial_part4.md:19
msgid "Plugin Management"
msgstr "Plugin Management"

#: ../../source/tutorial/tutorial_part4.md:21
msgid ""
"\"Plugins\" here refer to optional components or extension modules in "
"EvoX—such as visualization tools, reinforcement learning environment "
"wrappers, and sibling projects in the EvoX ecosystem. Managing plugins in "
"EvoX mainly involves **installing and using optional modules**. Here are "
"some key extensions and how to manage them:"
msgstr ""
"\"Plugins\" here refer to optional components or extension modules in "
"EvoX—such as visualization tools, reinforcement learning environment "
"wrappers, and sibling projects in the EvoX ecosystem. Managing plugins in "
"EvoX mainly involves **installing and using optional modules**. Here are "
"some key extensions and how to manage them:"

#: ../../source/tutorial/tutorial_part4.md:23
msgid ""
"**Visualization Plugin**: EvoX includes the `evox.vis_tools` module, which "
"contains a `plot` submodule for charting and supports the `.exv` log format "
"for real-time data streams. To use visualization, install EvoX with the "
"`vis` extra: `pip install evox[vis]`. (If not installed initially, you can "
"install later or just run `pip install plotly` to satisfy dependencies.) "
"When using visual tools, you typically call plot functions after the monitor"
" logs data—for example, `EvalMonitor.plot()` uses `vis_tools.plot`. Ensuring"
" this plugin is installed avoids errors from missing libraries like "
"`matplotlib`."
msgstr ""
"**Visualization Plugin**: EvoX includes the `evox.vis_tools` module, which "
"contains a `plot` submodule for charting and supports the `.exv` log format "
"for real-time data streams. To use visualization, install EvoX with the "
"`vis` extra: `pip install evox[vis]`. (If not installed initially, you can "
"install later or just run `pip install plotly` to satisfy dependencies.) "
"When using visual tools, you typically call plot functions after the monitor"
" logs data—for example, `EvalMonitor.plot()` uses `vis_tools.plot`. Ensuring"
" this plugin is installed avoids errors from missing libraries like "
"`matplotlib`."

#: ../../source/tutorial/tutorial_part4.md:25
msgid ""
"**Neuroevolution Plugin**: EvoX supports reinforcement learning environments"
" (like the Brax physics engine) and neural individual optimization "
"(neuroevolution). These features are bundled in the `neuroevolution` "
"extension, installed via `pip install \"evox[neuroevolution]\"`. This "
"includes the Google Brax library, Gym, and more. After installation, you can"
" use wrappers like `BraxProblem` in `evox.problems.neuroevolution` to turn "
"RL environments into optimization problems. Tools like `ParamsAndVector` are"
" also included for flattening PyTorch model parameters into vectors for "
"evolution. Note that Brax only works on Linux or Windows via WSL—native "
"Windows Python may only run on CPU. In short, enabling or disabling EvoX "
"plugins is controlled via installation of specific extras."
msgstr ""
"**Neuroevolution Plugin**: EvoX supports reinforcement learning environments"
" (like the Brax physics engine) and neural individual optimization "
"(neuroevolution). These features are bundled in the `neuroevolution` "
"extension, installed via `pip install \"evox[neuroevolution]\"`. This "
"includes the Google Brax library, Gym, and more. After installation, you can"
" use wrappers like `BraxProblem` in `evox.problems.neuroevolution` to turn "
"RL environments into optimization problems. Tools like `ParamsAndVector` are"
" also included for flattening PyTorch model parameters into vectors for "
"evolution. Note that Brax only works on Linux or Windows via WSL—native "
"Windows Python may only run on CPU. In short, enabling or disabling EvoX "
"plugins is controlled via installation of specific extras."

#: ../../source/tutorial/tutorial_part4.md:27
msgid ""
"**Sibling Projects**: EvoX has related projects such as EvoRL (focused on "
"evolutionary reinforcement learning) and EvoGP (GPU-accelerated genetic "
"programming). These share EvoX's design philosophy and interface. If your "
"task is RL-heavy, you might prefer these dedicated frameworks. Managing "
"these plugins means ensuring version compatibility and satisfying "
"dependencies. For example, EvoRL uses JAX and Brax, while EvoGP may require "
"symbolic tree libraries. These libraries can usually coexist without "
"conflicts. Think of them as complementary tools that can be called from the "
"main EvoX project—or left out entirely for a lean setup."
msgstr ""
"**Sibling Projects**: EvoX has related projects such as EvoRL (focused on "
"evolutionary reinforcement learning) and EvoGP (GPU-accelerated genetic "
"programming). These share EvoX's design philosophy and interface. If your "
"task is RL-heavy, you might prefer these dedicated frameworks. Managing "
"these plugins means ensuring version compatibility and satisfying "
"dependencies. For example, EvoRL uses JAX and Brax, while EvoGP may require "
"symbolic tree libraries. These libraries can usually coexist without "
"conflicts. Think of them as complementary tools that can be called from the "
"main EvoX project—or left out entirely for a lean setup."

#: ../../source/tutorial/tutorial_part4.md:29
msgid ""
"**Custom Plugins**: Thanks to EvoX’s modularity, you can build your own "
"“plugins.” For example, create a custom `Monitor` class to track unique "
"metrics, or a custom `Problem` subclass that wraps a third-party simulator. "
"These effectively extend EvoX’s capabilities. Best practice is to follow "
"EvoX's interface contracts—for instance, ensure your custom `Problem` has an"
" `evaluate()` method, or that your custom `Monitor` inherits from a base "
"class. Once tested, you could even contribute it to EvoX’s future releases."
msgstr ""
"**Custom Plugins**: Thanks to EvoX’s modularity, you can build your own "
"“plugins.” For example, create a custom `Monitor` class to track unique "
"metrics, or a custom `Problem` subclass that wraps a third-party simulator. "
"These effectively extend EvoX’s capabilities. Best practice is to follow "
"EvoX's interface contracts—for instance, ensure your custom `Problem` has an"
" `evaluate()` method, or that your custom `Monitor` inherits from a base "
"class. Once tested, you could even contribute it to EvoX’s future releases."

#: ../../source/tutorial/tutorial_part4.md:31
msgid ""
"Overall, plugin management in EvoX is about **flexible extension and "
"dependency control**. As a beginner, during installation, you can decide "
"whether to include the `vis` and `neuroevolution` extensions. If not "
"initially installed, they can be added later. With plugins, you can monitor "
"optimization progress more easily and integrate EvoX with external tools for"
" greater power."
msgstr ""
"Overall, plugin management in EvoX is about **flexible extension and "
"dependency control**. As a beginner, during installation, you can decide "
"whether to include the `vis` and `neuroevolution` extensions. If not "
"initially installed, they can be added later. With plugins, you can monitor "
"optimization progress more easily and integrate EvoX with external tools for"
" greater power."

#: ../../source/tutorial/tutorial_part4.md:33
#, fuzzy
msgid "Performance Optimization"
msgstr "Performance Optimization"

#: ../../source/tutorial/tutorial_part4.md:35
msgid ""
"Performance is a major strength of EvoX. Even using the same algorithm, "
"EvoX’s GPU support can boost speed by several orders of magnitude. However, "
"to fully tap into this, you'll want to follow a few tips:"
msgstr ""
"Performance is a major strength of EvoX. Even using the same algorithm, "
"EvoX’s GPU support can boost speed by several orders of magnitude. However, "
"to fully tap into this, you'll want to follow a few tips:"

#: ../../source/tutorial/tutorial_part4.md:37
msgid ""
"**Use GPU Parallelism**: First, ensure your code is actually running on the "
"GPU. As noted earlier, install CUDA-enabled PyTorch and move data to GPU "
"devices. If things seem slow, check with `torch.cuda.is_available()`—it "
"should return `True`. If GPU exists but isn't used, it's likely because "
"tensors were created on the CPU by default. Fix this by explicitly setting "
"`device`, or by ensuring input tensors (like `lb`/`ub`) are on CUDA. EvoX "
"will follow the device of these inputs. On multi-GPU systems, EvoX generally"
" uses **one GPU per process**. To leverage multiple GPUs, you can run "
"multiple processes with different GPUs or wait for future support for "
"coordinated multi-GPU execution."
msgstr ""
"**Use GPU Parallelism**: First, ensure your code is actually running on the "
"GPU. As noted earlier, install CUDA-enabled PyTorch and move data to GPU "
"devices. If things seem slow, check with `torch.cuda.is_available()`—it "
"should return `True`. If GPU exists but isn't used, it's likely because "
"tensors were created on the CPU by default. Fix this by explicitly setting "
"`device`, or by ensuring input tensors (like `lb`/`ub`) are on CUDA. EvoX "
"will follow the device of these inputs. On multi-GPU systems, EvoX generally"
" uses **one GPU per process**. To leverage multiple GPUs, you can run "
"multiple processes with different GPUs or wait for future support for "
"coordinated multi-GPU execution."

#: ../../source/tutorial/tutorial_part4.md:39
msgid ""
"**Parallel Evaluation**: A key bottleneck in evolutionary algorithms is "
"**fitness evaluation**. Since evaluations are often independent, they can be"
" parallelized. EvoX batches evaluations when possible—for instance, neural "
"network evaluations or polynomial functions can be computed in parallel "
"using the GPU. For custom problems, avoid Python loops—vectorize your "
"evaluation code to process a whole batch of candidates at once. This makes "
"the most of PyTorch’s parallel capabilities. Simply put: make your problem’s"
" `evaluate()` function operate on batches—not individual solutions—for a "
"massive speedup."
msgstr ""
"**Parallel Evaluation**: A key bottleneck in evolutionary algorithms is "
"**fitness evaluation**. Since evaluations are often independent, they can be"
" parallelized. EvoX batches evaluations when possible—for instance, neural "
"network evaluations or polynomial functions can be computed in parallel "
"using the GPU. For custom problems, avoid Python loops—vectorize your "
"evaluation code to process a whole batch of candidates at once. This makes "
"the most of PyTorch’s parallel capabilities. Simply put: make your problem’s"
" `evaluate()` function operate on batches—not individual solutions—for a "
"massive speedup."

#: ../../source/tutorial/tutorial_part4.md:41
msgid ""
"**Compile for Optimization**: PyTorch 2.0 introduced `torch.compile`, which "
"JIT-compiles models/functions for performance gains. If your evaluation "
"logic is complex, consider compiling before running:"
msgstr ""
"**Compile for Optimization**: PyTorch 2.0 introduced `torch.compile`, which "
"JIT-compiles models/functions for performance gains. If your evaluation "
"logic is complex, consider compiling before running:"

#: ../../source/tutorial/tutorial_part4.md:47
msgid "This could significantly improve performance."
msgstr "This could significantly improve performance."

#: ../../source/tutorial/tutorial_part4.md:49
msgid ""
"Compilation adds overhead and isn’t always supported by all functions or "
"problems. Best suited for large-scale, long-running tasks. On Windows, "
"ensure Triton is installed for `torch.compile` to work."
msgstr ""
"Compilation adds overhead and isn’t always supported by all functions or "
"problems. Best suited for large-scale, long-running tasks. On Windows, "
"ensure Triton is installed for `torch.compile` to work."

#: ../../source/tutorial/tutorial_part4.md:52
msgid ""
"**Tune Population Size**: A larger population increases diversity and global"
" search ability—but also increases per-generation computation. Balance "
"quality and speed by tuning `pop_size`. On GPU, you can often increase it "
"without a linear time cost (thanks to parallelism). But too large a size can"
" cause memory issues. If you’re running out of GPU memory, reduce population"
" size or problem dimension, or use FP16 to save space (set via "
"`torch.set_float32_matmul_precision('medium')`)."
msgstr ""
"**Tune Population Size**: A larger population increases diversity and global"
" search ability—but also increases per-generation computation. Balance "
"quality and speed by tuning `pop_size`. On GPU, you can often increase it "
"without a linear time cost (thanks to parallelism). But too large a size can"
" cause memory issues. If you’re running out of GPU memory, reduce population"
" size or problem dimension, or use FP16 to save space (set via "
"`torch.set_float32_matmul_precision('medium')`)."

#: ../../source/tutorial/tutorial_part4.md:54
msgid ""
"**Reduce Python Overhead**: EvoX moves most core computation to "
"`torch.Tensor`, but user-written loops or custom operators should avoid "
"excessive Python-level operations. Avoid frequent prints (high I/O cost), "
"lists, or data type conversions. Keep your code vectorized/tensorized to "
"leverage fast C++/CUDA kernels under the hood and reduce Python interpreter "
"overhead."
msgstr ""
"**Reduce Python Overhead**: EvoX moves most core computation to "
"`torch.Tensor`, but user-written loops or custom operators should avoid "
"excessive Python-level operations. Avoid frequent prints (high I/O cost), "
"lists, or data type conversions. Keep your code vectorized/tensorized to "
"leverage fast C++/CUDA kernels under the hood and reduce Python interpreter "
"overhead."

#: ../../source/tutorial/tutorial_part4.md:56
msgid ""
"**Distributed Deployment**: For ultra-large problems, consider running "
"across multiple machines. EvoX supports multi-node setups (via backend "
"communication and sharding). While not beginner-friendly, it’s good to know "
"this exists. With a GPU cluster, refer to EvoX’s documentation for "
"distributed deployment. Usually, you’ll need to set environment variables or"
" launch with special scripts. The architecture allows the same code to run "
"on single or multi-node setups. For your first try, simulate it with "
"multiple processes on one machine."
msgstr ""
"**Distributed Deployment**: For ultra-large problems, consider running "
"across multiple machines. EvoX supports multi-node setups (via backend "
"communication and sharding). While not beginner-friendly, it’s good to know "
"this exists. With a GPU cluster, refer to EvoX’s documentation for "
"distributed deployment. Usually, you’ll need to set environment variables or"
" launch with special scripts. The architecture allows the same code to run "
"on single or multi-node setups. For your first try, simulate it with "
"multiple processes on one machine."

#: ../../source/tutorial/tutorial_part4.md:58
msgid ""
"**Performance Profiling**: To dive deeper, use tools like PyTorch's profiler"
" or Python’s `cProfile` to analyze bottlenecks. This helps you identify "
"whether the time goes into evaluation, selection, or something else—so you "
"can optimize accordingly (e.g., by caching repeated computations). EvoX is "
"built for performance, but real-world tasks may still hit unique bottlenecks"
" that need analysis."
msgstr ""
"**Performance Profiling**: To dive deeper, use tools like PyTorch's profiler"
" or Python’s `cProfile` to analyze bottlenecks. This helps you identify "
"whether the time goes into evaluation, selection, or something else—so you "
"can optimize accordingly (e.g., by caching repeated computations). EvoX is "
"built for performance, but real-world tasks may still hit unique bottlenecks"
" that need analysis."

#: ../../source/tutorial/tutorial_part4.md:60
msgid ""
"In short, while EvoX is already optimized at the architecture level, users "
"can further boost performance by **using GPUs correctly**, **batch "
"computing**, and **tuning parameters**. While chasing speed, also remember "
"to maintain result quality—balance is key. As you grow more familiar with "
"EvoX, performance tuning will become second nature."
msgstr ""
"In short, while EvoX is already optimized at the architecture level, users "
"can further boost performance by **using GPUs correctly**, **batch "
"computing**, and **tuning parameters**. While chasing speed, also remember "
"to maintain result quality—balance is key. As you grow more familiar with "
"EvoX, performance tuning will become second nature."

#: ../../source/tutorial/tutorial_part5.md:1
msgid "5. Development and Extension"
msgstr "5. Development and Extension"

#: ../../source/tutorial/tutorial_part5.md:3
msgid ""
"EvoX not only offers out-of-the-box functionality but also provides "
"developers and advanced users with a rich set of interfaces for custom "
"development and extended integration. This chapter details how to implement "
"custom algorithms and problems, how to utilize EvoX's APIs for deeper "
"control, and how to integrate EvoX with other tools to build more complex "
"applications."
msgstr ""
"EvoX not only offers out-of-the-box functionality but also provides "
"developers and advanced users with a rich set of interfaces for custom "
"development and extended integration. This chapter details how to implement "
"custom algorithms and problems, how to utilize EvoX's APIs for deeper "
"control, and how to integrate EvoX with other tools to build more complex "
"applications."

#: ../../source/tutorial/tutorial_part5.md:5
msgid "5.1 Developing Custom Modules"
msgstr "5.1 Developing Custom Modules"

#: ../../source/tutorial/tutorial_part5.md:7
msgid ""
"Sometimes the problem you’re solving or the algorithm you want to use isn’t "
"included in EvoX’s standard library. In such cases, you can develop custom "
"modules using the interfaces EvoX provides."
msgstr ""
"Sometimes the problem you’re solving or the algorithm you want to use isn’t "
"included in EvoX’s standard library. In such cases, you can develop custom "
"modules using the interfaces EvoX provides."

#: ../../source/tutorial/tutorial_part5.md:9
msgid "5.1.1 Custom Problems (MyProblem)"
msgstr "5.1.1 Custom Problems (MyProblem)"

#: ../../source/tutorial/tutorial_part5.md:11
msgid ""
"If your objective function isn’t available in `evox.problems`, you can "
"define your own by inheriting from the `evox.core.Problem` base class (or "
"conforming to the required interface). A typical problem class needs to "
"implement an `evaluate` function, which receives a batch of solutions "
"(`pop`) and returns the corresponding fitness/objective values. To leverage "
"parallel computation, EvoX requires that `evaluate` support **batch input**."
msgstr ""
"If your objective function isn’t available in `evox.problems`, you can "
"define your own by inheriting from the `evox.core.Problem` base class (or "
"conforming to the required interface). A typical problem class needs to "
"implement an `evaluate` function, which receives a batch of solutions "
"(`pop`) and returns the corresponding fitness/objective values. To leverage "
"parallel computation, EvoX requires that `evaluate` support **batch input**."

#: ../../source/tutorial/tutorial_part5.md:27
msgid "For example, to minimize the sum of cubes of the decision vector:"
msgstr "For example, to minimize the sum of cubes of the decision vector:"

#: ../../source/tutorial/tutorial_part5.md:29
#, fuzzy, python-brace-format
msgid ""
"\n"
"\\min f(x) = \\sum_{i=1}^{n} x_i^3\n"
msgstr ""
"\n"
"\\min f(x) = \\sum_{i=1}^{n} x_i^3\n"

#: ../../source/tutorial/tutorial_part5.md:33
msgid "You can implement a `MyProblem` class like this:"
msgstr "You can implement a `MyProblem` class like this:"

#: ../../source/tutorial/tutorial_part5.md:48
msgid ""
"Here, `pop` is a tensor of shape `(population_size, dim)`. The `evaluate` "
"function returns a 1D tensor of fitness values. For multi-objective "
"problems, you can return a dictionary with separate keys for each objective."
msgstr ""
"Here, `pop` is a tensor of shape `(population_size, dim)`. The `evaluate` "
"function returns a 1D tensor of fitness values. For multi-objective "
"problems, you can return a dictionary with separate keys for each objective."

#: ../../source/tutorial/tutorial_part5.md:50
msgid "You can use your custom problem like a built-in one:"
msgstr "You can use your custom problem like a built-in one:"

#: ../../source/tutorial/tutorial_part5.md:63
#, fuzzy
msgid "5.1.2 Custom Algorithms (MyAlgorithm)"
msgstr "5.1.2 Custom Algorithms (MyAlgorithm)"

#: ../../source/tutorial/tutorial_part5.md:65
msgid ""
"Creating a custom algorithm is more involved, as it includes initialization,"
" generating new solutions, and selection. To create a new algorithm, inherit"
" from `evox.core.Algorithm` and implement at least:"
msgstr ""
"Creating a custom algorithm is more involved, as it includes initialization,"
" generating new solutions, and selection. To create a new algorithm, inherit"
" from `evox.core.Algorithm` and implement at least:"

#: ../../source/tutorial/tutorial_part5.md:67
#, fuzzy
msgid "`__init__`: For initialization."
msgstr "`__init__`: For initialization."

#: ../../source/tutorial/tutorial_part5.md:68
msgid "`step`: The main evolutionary step logic."
msgstr "`step`: The main evolutionary step logic."

#: ../../source/tutorial/tutorial_part5.md:70
#, fuzzy
msgid ""
"Below is an example of implementing the Particle Swarm Optimization (PSO) "
"algorithm in EvoX:"
msgstr ""
"Below is an example of implementing the Particle Swarm Optimization (PSO) "
"algorithm in EvoX:"

#: ../../source/tutorial/tutorial_part5.md:145
#, fuzzy
msgid "To integrate the algorithm into a workflow:"
msgstr "To integrate the algorithm into a workflow:"

#: ../../source/tutorial/tutorial_part5.md:165
msgid "5.1.3 Custom Other Modules"
msgstr "5.1.3 Custom Other Modules"

#: ../../source/tutorial/tutorial_part5.md:167
msgid ""
"You can also customize `Monitor`, `Operator`, or any module in EvoX. For "
"example, implement a `MyMonitor` to record population diversity or create a "
"`MyOperator` for custom crossover/mutation strategies. Refer to existing "
"base classes and examples to understand which methods to override."
msgstr ""
"You can also customize `Monitor`, `Operator`, or any module in EvoX. For "
"example, implement a `MyMonitor` to record population diversity or create a "
"`MyOperator` for custom crossover/mutation strategies. Refer to existing "
"base classes and examples to understand which methods to override."

#: ../../source/tutorial/tutorial_part5.md:169
msgid "5.2 Using the API"
msgstr "5.2 Using the API"

#: ../../source/tutorial/tutorial_part5.md:171
msgid ""
"EvoX organizes its APIs into modules, making it easy to extend and combine "
"components."
msgstr ""
"EvoX organizes its APIs into modules, making it easy to extend and combine "
"components."

#: ../../source/tutorial/tutorial_part5.md:173
#, fuzzy
msgid "5.2.1 Algorithms and Problems"
msgstr "5.2.1 Algorithms and Problems"

#: ../../source/tutorial/tutorial_part5.md:175
msgid ""
"**Algorithms**: Found in `evox.algorithms.so` (single-objective) and "
"`evox.algorithms.mo` (multi-objective)."
msgstr ""
"**Algorithms**: Found in `evox.algorithms.so` (single-objective) and "
"`evox.algorithms.mo` (multi-objective)."

#: ../../source/tutorial/tutorial_part5.md:182
msgid "**Problems**: Found in `evox.problems`, including:"
msgstr "**Problems**: Found in `evox.problems`, including:"

#: ../../source/tutorial/tutorial_part5.md:183
msgid "`numerical` – classic test functions (e.g., Ackley, Sphere)."
msgstr "`numerical` – classic test functions (e.g., Ackley, Sphere)."

#: ../../source/tutorial/tutorial_part5.md:184
msgid "`neuroevolution` – RL environments like Brax."
msgstr "`neuroevolution` – RL environments like Brax."

#: ../../source/tutorial/tutorial_part5.md:185
msgid "`hpo_wrapper` – wrap ML training into HPO problems."
msgstr "`hpo_wrapper` – wrap ML training into HPO problems."

#: ../../source/tutorial/tutorial_part5.md:187
msgid "Example: Wrapping a PyTorch MLP with a Brax environment:"
msgstr "Example: Wrapping a PyTorch MLP with a Brax environment:"

#: ../../source/tutorial/tutorial_part5.md:204
msgid "Example: Wrapping an optimization process for HPO:"
msgstr "Example: Wrapping an optimization process for HPO:"

#: ../../source/tutorial/tutorial_part5.md:217
msgid "5.2.2 Workflows and Tools"
msgstr "5.2.2 Workflows and Tools"

#: ../../source/tutorial/tutorial_part5.md:219
msgid ""
"**Workflows**: `evox.workflows.StdWorkflow` for basic optimization loops."
msgstr ""
"**Workflows**: `evox.workflows.StdWorkflow` for basic optimization loops."

#: ../../source/tutorial/tutorial_part5.md:220
msgid "**Monitors**: `EvalMonitor` for tracking performance."
msgstr "**Monitors**: `EvalMonitor` for tracking performance."

#: ../../source/tutorial/tutorial_part5.md:222
#, fuzzy
msgid "Example:"
msgstr "Example:"

#: ../../source/tutorial/tutorial_part5.md:232
msgid "**Metrics**: `evox.metrics` provides IGD, Hypervolume, etc."
msgstr "**Metrics**: `evox.metrics` provides IGD, Hypervolume, etc."

#: ../../source/tutorial/tutorial_part5.md:239
msgid ""
"**PyTorch Interoperability**: Seamless integration with `torch.nn`, "
"`torch.Tensor`, etc."
msgstr ""
"**PyTorch Interoperability**: Seamless integration with `torch.nn`, "
"`torch.Tensor`, etc."

#: ../../source/tutorial/tutorial_part5.md:241
msgid "5.3 Integration with Other Tools"
msgstr "5.3 Integration with Other Tools"

#: ../../source/tutorial/tutorial_part5.md:243
msgid "EvoX is designed to integrate easily with external tools."
msgstr "EvoX is designed to integrate easily with external tools."

#: ../../source/tutorial/tutorial_part5.md:245
msgid "5.3.1 Machine Learning Integration"
msgstr "5.3.1 Machine Learning Integration"

#: ../../source/tutorial/tutorial_part5.md:247
#, fuzzy
msgid "Use EvoX to tune hyperparameters:"
msgstr "Use EvoX to tune hyperparameters:"

#: ../../source/tutorial/tutorial_part5.md:249
msgid "Wrap training/validation as a `Problem`."
msgstr "Wrap training/validation as a `Problem`."

#: ../../source/tutorial/tutorial_part5.md:250
msgid "Use an algorithm like CMA-ES."
msgstr "Use an algorithm like CMA-ES."

#: ../../source/tutorial/tutorial_part5.md:251
msgid "Optimize hyperparameters over multiple runs."
msgstr "Optimize hyperparameters over multiple runs."

#: ../../source/tutorial/tutorial_part5.md:252
#, fuzzy
msgid "Train final model with the best parameters."
msgstr "Train final model with the best parameters."

#: ../../source/tutorial/tutorial_part5.md:254
msgid "5.3.2 Reinforcement Learning Integration"
msgstr "5.3.2 Reinforcement Learning Integration"

#: ../../source/tutorial/tutorial_part5.md:256
#, fuzzy
msgid "Use EvoX to evolve neural network policies:"
msgstr "Use EvoX to evolve neural network policies:"

#: ../../source/tutorial/tutorial_part5.md:258
msgid "Wrap RL environment using `BraxProblem`."
msgstr "Wrap RL environment using `BraxProblem`."

#: ../../source/tutorial/tutorial_part5.md:259
msgid "Flatten policy network using `ParamsAndVector`."
msgstr "Flatten policy network using `ParamsAndVector`."

#: ../../source/tutorial/tutorial_part5.md:260
msgid "Optimize using evolutionary algorithms like GA or CMA-ES."
msgstr "Optimize using evolutionary algorithms like GA or CMA-ES."

#: ../../source/tutorial/tutorial_part5.md:261
msgid "Deploy optimized policies directly or fine-tune with RL."
msgstr "Deploy optimized policies directly or fine-tune with RL."

#: ../../source/tutorial/tutorial_part5.md:263
msgid ""
"EvoX supports batch environment simulation to fully utilize GPU/CPU power."
msgstr ""
"EvoX supports batch environment simulation to fully utilize GPU/CPU power."

#: ../../source/tutorial/tutorial_part5.md:267
msgid ""
"**In summary**, EvoX provides powerful, modular APIs and a developer-"
"friendly design for implementing custom algorithms, wrapping any "
"optimization problem, and integrating with ML and RL tools. As you deepen "
"your understanding, you can creatively apply these interfaces to build "
"tailored optimization solutions."
msgstr ""
"**In summary**, EvoX provides powerful, modular APIs and a developer-"
"friendly design for implementing custom algorithms, wrapping any "
"optimization problem, and integrating with ML and RL tools. As you deepen "
"your understanding, you can creatively apply these interfaces to build "
"tailored optimization solutions."

#: ../../source/tutorial/tutorial_part6.md:1
msgid "6. Troubleshooting and Optimization"
msgstr "6. Troubleshooting and Optimization"

#: ../../source/tutorial/tutorial_part6.md:3
msgid ""
"When using EvoX, you may encounter issues or want to fine-tune your "
"algorithms. This chapter outlines common problems and solutions, along with "
"debugging strategies and performance tuning tips to help you resolve issues "
"and optimize your experience."
msgstr ""
"When using EvoX, you may encounter issues or want to fine-tune your "
"algorithms. This chapter outlines common problems and solutions, along with "
"debugging strategies and performance tuning tips to help you resolve issues "
"and optimize your experience."

#: ../../source/tutorial/tutorial_part6.md:7
msgid "6.1 Common Issues and Solutions"
msgstr "6.1 Common Issues and Solutions"

#: ../../source/tutorial/tutorial_part6.md:9
msgid "Here are some frequently encountered problems and how to address them:"
msgstr ""
"Here are some frequently encountered problems and how to address them:"

#: ../../source/tutorial/tutorial_part6.md:11
msgid "**(1) Installation or Import Errors**:"
msgstr "**(1) Installation or Import Errors**:"

#: ../../source/tutorial/tutorial_part6.md:13
msgid "**Symptom**: Error when running `import evox`."
msgstr "**Symptom**: Error when running `import evox`."

#: ../../source/tutorial/tutorial_part6.md:14
#: ../../source/tutorial/tutorial_part6.md:22
#: ../../source/tutorial/tutorial_part6.md:29
#: ../../source/tutorial/tutorial_part6.md:39
#: ../../source/tutorial/tutorial_part6.md:48
#: ../../source/tutorial/tutorial_part6.md:64
msgid "**Solution**:"
msgstr "**Solution**:"

#: ../../source/tutorial/tutorial_part6.md:15
msgid ""
"**Check installation**: Run `pip show evox` to verify. If it’s not "
"installed, check your virtual environment and reinstall."
msgstr ""
"**Check installation**: Run `pip show evox` to verify. If it’s not "
"installed, check your virtual environment and reinstall."

#: ../../source/tutorial/tutorial_part6.md:16
msgid ""
"**Missing dependencies**: If you see `ModuleNotFoundError: No module named "
"'torch'`, install PyTorch as outlined in Chapter 2."
msgstr ""
"**Missing dependencies**: If you see `ModuleNotFoundError: No module named "
"'torch'`, install PyTorch as outlined in Chapter 2."

#: ../../source/tutorial/tutorial_part6.md:17
msgid ""
"**CUDA mismatch**: Ensure your PyTorch version matches your installed CUDA "
"drivers."
msgstr ""
"**CUDA mismatch**: Ensure your PyTorch version matches your installed CUDA "
"drivers."

#: ../../source/tutorial/tutorial_part6.md:19
msgid "**(2) GPU Not Being Used**:"
msgstr "**(2) GPU Not Being Used**:"

#: ../../source/tutorial/tutorial_part6.md:21
msgid "**Symptom**: EvoX is running on CPU instead of GPU."
msgstr "**Symptom**: EvoX is running on CPU instead of GPU."

#: ../../source/tutorial/tutorial_part6.md:23
msgid ""
"Check with `torch.cuda.is_available()`. If `False`, reinstall a GPU-"
"compatible PyTorch and check CUDA installation."
msgstr ""
"Check with `torch.cuda.is_available()`. If `False`, reinstall a GPU-"
"compatible PyTorch and check CUDA installation."

#: ../../source/tutorial/tutorial_part6.md:24
msgid ""
"If `True` but EvoX still uses CPU, make sure your tensors are moved to GPU "
"(see Chapter 3 for configuration)."
msgstr ""
"If `True` but EvoX still uses CPU, make sure your tensors are moved to GPU "
"(see Chapter 3 for configuration)."

#: ../../source/tutorial/tutorial_part6.md:26
msgid "**(3) Out of Memory (RAM/VRAM)**:"
msgstr "**(3) Out of Memory (RAM/VRAM)**:"

#: ../../source/tutorial/tutorial_part6.md:28
msgid "**Symptom**: You see `OutOfMemoryError`."
msgstr "**Symptom**: You see `OutOfMemoryError`."

#: ../../source/tutorial/tutorial_part6.md:30
msgid "Reduce population size, problem dimension, or evaluation frequency."
msgstr "Reduce population size, problem dimension, or evaluation frequency."

#: ../../source/tutorial/tutorial_part6.md:31
msgid "Use float16 (half precision) or batch evaluation splitting."
msgstr "Use float16 (half precision) or batch evaluation splitting."

#: ../../source/tutorial/tutorial_part6.md:32
msgid "Turn off debug/deterministic modes in PyTorch."
msgstr "Turn off debug/deterministic modes in PyTorch."

#: ../../source/tutorial/tutorial_part6.md:33
msgid ""
"Store statistics only instead of full Pareto fronts (for multi-objective)."
msgstr ""
"Store statistics only instead of full Pareto fronts (for multi-objective)."

#: ../../source/tutorial/tutorial_part6.md:34
msgid "Upgrading hardware is the ultimate fix for memory bottlenecks."
msgstr "Upgrading hardware is the ultimate fix for memory bottlenecks."

#: ../../source/tutorial/tutorial_part6.md:36
msgid "**(4) Convergence Stagnation**:"
msgstr "**(4) Convergence Stagnation**:"

#: ../../source/tutorial/tutorial_part6.md:38
msgid "**Symptom**: Algorithm gets stuck in a local optimum."
msgstr "**Symptom**: Algorithm gets stuck in a local optimum."

#: ../../source/tutorial/tutorial_part6.md:40
msgid "Increase population diversity (e.g., higher mutation rate)."
msgstr "Increase population diversity (e.g., higher mutation rate)."

#: ../../source/tutorial/tutorial_part6.md:41
msgid "Try different algorithms or parameters."
msgstr "Try different algorithms or parameters."

#: ../../source/tutorial/tutorial_part6.md:42
msgid "Ensure the objective function is well-defined (not too noisy or flat)."
msgstr ""
"Ensure the objective function is well-defined (not too noisy or flat)."

#: ../../source/tutorial/tutorial_part6.md:43
msgid "Run multiple trials and pick the best—EvoX makes parallel runs easy."
msgstr "Run multiple trials and pick the best—EvoX makes parallel runs easy."

#: ../../source/tutorial/tutorial_part6.md:45
#, fuzzy
msgid "**(5) Poor Optimization Results**:"
msgstr "**(5) Poor Optimization Results**:"

#: ../../source/tutorial/tutorial_part6.md:47
msgid "**Symptom**: Final results are below expectations."
msgstr "**Symptom**: Final results are below expectations."

#: ../../source/tutorial/tutorial_part6.md:49
msgid ""
"**Check problem definition**: Ensure fitness is computed correctly (e.g., "
"signs, scaling)."
msgstr ""
"**Check problem definition**: Ensure fitness is computed correctly (e.g., "
"signs, scaling)."

#: ../../source/tutorial/tutorial_part6.md:50
#, fuzzy
msgid "**Algorithm fit**: Try others or tune hyperparameters."
msgstr "**Algorithm fit**: Try others or tune hyperparameters."

#: ../../source/tutorial/tutorial_part6.md:51
msgid "**Use convergence curves**:"
msgstr "**Use convergence curves**:"

#: ../../source/tutorial/tutorial_part6.md:52
msgid "Flatline early → premature convergence."
msgstr "Flatline early → premature convergence."

#: ../../source/tutorial/tutorial_part6.md:53
msgid "Oscillating → randomness too high."
msgstr "Oscillating → randomness too high."

#: ../../source/tutorial/tutorial_part6.md:54
msgid "Adjust algorithm settings and analyze behavior over time."
msgstr "Adjust algorithm settings and analyze behavior over time."

#: ../../source/tutorial/tutorial_part6.md:56
msgid "**(6) Backend Conflicts (JAX vs PyTorch)**:"
msgstr "**(6) Backend Conflicts (JAX vs PyTorch)**:"

#: ../../source/tutorial/tutorial_part6.md:58
msgid ""
"**Symptom**: Accidentally installed JAX version of EvoX while using PyTorch "
"examples."
msgstr ""
"**Symptom**: Accidentally installed JAX version of EvoX while using PyTorch "
"examples."

#: ../../source/tutorial/tutorial_part6.md:59
msgid ""
"**Solution**: The default `pip install evox` gives you the PyTorch version. "
"If you installed a JAX version, reinstall using PyTorch instructions (see "
"Chapter 2). JAX features are documented separately."
msgstr ""
"**Solution**: The default `pip install evox` gives you the PyTorch version. "
"If you installed a JAX version, reinstall using PyTorch instructions (see "
"Chapter 2). JAX features are documented separately."

#: ../../source/tutorial/tutorial_part6.md:61
msgid "**(7) Version Mismatch**:"
msgstr "**(7) Version Mismatch**:"

#: ../../source/tutorial/tutorial_part6.md:63
msgid "**Symptom**: API calls don't match installed version."
msgstr "**Symptom**: API calls don't match installed version."

#: ../../source/tutorial/tutorial_part6.md:65
msgid "EvoX updates may change method names (e.g., `ask/tell` → `step`)."
msgstr "EvoX updates may change method names (e.g., `ask/tell` → `step`)."

#: ../../source/tutorial/tutorial_part6.md:66
msgid "Use the latest stable version and refer to its documentation."
msgstr "Use the latest stable version and refer to its documentation."

#: ../../source/tutorial/tutorial_part6.md:67
msgid "Adjust code to align with your EvoX version or consider upgrading."
msgstr "Adjust code to align with your EvoX version or consider upgrading."

#: ../../source/tutorial/tutorial_part6.md:71
msgid "6.2 Debugging Tips"
msgstr "6.2 Debugging Tips"

#: ../../source/tutorial/tutorial_part6.md:73
msgid ""
"Debugging evolutionary algorithms can be tricky due to their stochastic "
"nature. Here are practical tips:"
msgstr ""
"Debugging evolutionary algorithms can be tricky due to their stochastic "
"nature. Here are practical tips:"

#: ../../source/tutorial/tutorial_part6.md:75
msgid "**(1) Use Small Scale Testing**:"
msgstr "**(1) Use Small Scale Testing**:"

#: ../../source/tutorial/tutorial_part6.md:77
msgid "Reduce population size and iteration count to simplify debugging."
msgstr "Reduce population size and iteration count to simplify debugging."

#: ../../source/tutorial/tutorial_part6.md:78
msgid "Example: `pop_size=5`, `iterations=20`."
msgstr "Example: `pop_size=5`, `iterations=20`."

#: ../../source/tutorial/tutorial_part6.md:79
msgid "Makes it easier to track population behavior and isolate issues."
msgstr "Makes it easier to track population behavior and isolate issues."

#: ../../source/tutorial/tutorial_part6.md:81
msgid "**(2) Insert Print Statements**:"
msgstr "**(2) Insert Print Statements**:"

#: ../../source/tutorial/tutorial_part6.md:83
msgid "Print population fitness, best individuals, and intermediate values."
msgstr "Print population fitness, best individuals, and intermediate values."

#: ../../source/tutorial/tutorial_part6.md:84
msgid "For large tensors, print shapes or use `.tolist()` for smaller ones."
msgstr "For large tensors, print shapes or use `.tolist()` for smaller ones."

#: ../../source/tutorial/tutorial_part6.md:85
msgid "Helps you understand convergence and operator effects."
msgstr "Helps you understand convergence and operator effects."

#: ../../source/tutorial/tutorial_part6.md:87
msgid "**(3) Use IDE Breakpoints**:"
msgstr "**(3) Use IDE Breakpoints**:"

#: ../../source/tutorial/tutorial_part6.md:89
msgid ""
"Use PyCharm or VS Code to set breakpoints inside algorithm `step()` or "
"evaluation logic."
msgstr ""
"Use PyCharm or VS Code to set breakpoints inside algorithm `step()` or "
"evaluation logic."

#: ../../source/tutorial/tutorial_part6.md:90
msgid "Inspect variable values, tensor contents, or state transitions."
msgstr "Inspect variable values, tensor contents, or state transitions."

#: ../../source/tutorial/tutorial_part6.md:91
msgid ""
"Be cautious with large tensors—limit what you inspect to avoid crashes."
msgstr ""
"Be cautious with large tensors—limit what you inspect to avoid crashes."

#: ../../source/tutorial/tutorial_part6.md:93
msgid "**(4) Unit Test Custom Components**:"
msgstr "**(4) Unit Test Custom Components**:"

#: ../../source/tutorial/tutorial_part6.md:95
#, fuzzy
msgid "Test crossover/mutation functions separately."
msgstr "Test crossover/mutation functions separately."

#: ../../source/tutorial/tutorial_part6.md:96
msgid ""
"Use synthetic inputs to validate output shapes and logic before full "
"integration."
msgstr ""
"Use synthetic inputs to validate output shapes and logic before full "
"integration."

#: ../../source/tutorial/tutorial_part6.md:98
msgid "**(5) Profile Execution**:"
msgstr "**(5) Profile Execution**:"

#: ../../source/tutorial/tutorial_part6.md:100
msgid ""
"Use `torch.autograd.profiler.profile` or `time.time()` to measure step "
"timings."
msgstr ""
"Use `torch.autograd.profiler.profile` or `time.time()` to measure step "
"timings."

#: ../../source/tutorial/tutorial_part6.md:101
msgid "Helps you locate bottlenecks or infinite loops."
msgstr "Helps you locate bottlenecks or infinite loops."

#: ../../source/tutorial/tutorial_part6.md:102
msgid "Identify whether slowdowns are in evaluation or algorithm logic."
msgstr "Identify whether slowdowns are in evaluation or algorithm logic."

#: ../../source/tutorial/tutorial_part6.md:104
msgid "**(6) Log Output to File**:"
msgstr "**(6) Log Output to File**:"

#: ../../source/tutorial/tutorial_part6.md:106
msgid "Write logs to `.csv` files for long runs."
msgstr "Write logs to `.csv` files for long runs."

#: ../../source/tutorial/tutorial_part6.md:107
msgid "Include best fitness per generation, diversity stats, etc."
msgstr "Include best fitness per generation, diversity stats, etc."

#: ../../source/tutorial/tutorial_part6.md:108
msgid "Useful when crashes prevent console output from being seen."
msgstr "Useful when crashes prevent console output from being seen."

#: ../../source/tutorial/tutorial_part6.md:110
msgid ""
"Overall, debugging EvoX projects requires a balance of correctness checks "
"and result analysis. Focus first on ensuring the algorithm runs properly, "
"then optimize its effectiveness."
msgstr ""
"Overall, debugging EvoX projects requires a balance of correctness checks "
"and result analysis. Focus first on ensuring the algorithm runs properly, "
"then optimize its effectiveness."

#: ../../source/tutorial/tutorial_part6.md:114
msgid "6.3 Performance Tuning Guide"
msgstr "6.3 Performance Tuning Guide"

#: ../../source/tutorial/tutorial_part6.md:116
msgid "These tips help you squeeze more speed and quality from EvoX:"
msgstr "These tips help you squeeze more speed and quality from EvoX:"

#: ../../source/tutorial/tutorial_part6.md:118
msgid "**(1) Progressive Scaling**:"
msgstr "**(1) Progressive Scaling**:"

#: ../../source/tutorial/tutorial_part6.md:120
msgid "**Start small**: Test logic with small inputs."
msgstr "**Start small**: Test logic with small inputs."

#: ../../source/tutorial/tutorial_part6.md:121
msgid "**Scale up** gradually and observe how runtime increases."
msgstr "**Scale up** gradually and observe how runtime increases."

#: ../../source/tutorial/tutorial_part6.md:122
msgid ""
"**Identify inefficiencies** if scaling is nonlinear (e.g., 10x population → "
">10x time)."
msgstr ""
"**Identify inefficiencies** if scaling is nonlinear (e.g., 10x population → "
">10x time)."

#: ../../source/tutorial/tutorial_part6.md:124
msgid "**(2) Monitor Hardware Usage**:"
msgstr "**(2) Monitor Hardware Usage**:"

#: ../../source/tutorial/tutorial_part6.md:126
msgid "Use `nvidia-smi` for GPU, `htop` for CPU."
msgstr "Use `nvidia-smi` for GPU, `htop` for CPU."

#: ../../source/tutorial/tutorial_part6.md:127
msgid "High GPU utilization (>50%) is ideal."
msgstr "High GPU utilization (>50%) is ideal."

#: ../../source/tutorial/tutorial_part6.md:128
msgid ""
"Low GPU usage may mean data isn't on GPU or frequent CPU-GPU transfers are "
"slowing things down."
msgstr ""
"Low GPU usage may mean data isn't on GPU or frequent CPU-GPU transfers are "
"slowing things down."

#: ../../source/tutorial/tutorial_part6.md:130
msgid "**(3) Adjust Parallelism**:"
msgstr "**(3) Adjust Parallelism**:"

#: ../../source/tutorial/tutorial_part6.md:132
msgid "Set CPU threads: `torch.set_num_threads(n)`."
msgstr "Set CPU threads: `torch.set_num_threads(n)`."

#: ../../source/tutorial/tutorial_part6.md:133
msgid "Avoid oversubscription if using multi-threaded evaluation tools."
msgstr "Avoid oversubscription if using multi-threaded evaluation tools."

#: ../../source/tutorial/tutorial_part6.md:134
msgid ""
"For GPU, optimize `DataLoader` threads if using batch environments or "
"datasets."
msgstr ""
"For GPU, optimize `DataLoader` threads if using batch environments or "
"datasets."

#: ../../source/tutorial/tutorial_part6.md:136
msgid "**(4) Leverage Batch Evaluation**:"
msgstr "**(4) Leverage Batch Evaluation**:"

#: ../../source/tutorial/tutorial_part6.md:138
msgid "Batch evaluation is faster than per-individual evaluation."
msgstr "Batch evaluation is faster than per-individual evaluation."

#: ../../source/tutorial/tutorial_part6.md:139
msgid "Always vectorize `Problem.evaluate()` to process entire populations."
msgstr "Always vectorize `Problem.evaluate()` to process entire populations."

#: ../../source/tutorial/tutorial_part6.md:141
msgid "**(5) Reduce Python Overhead**:"
msgstr "**(5) Reduce Python Overhead**:"

#: ../../source/tutorial/tutorial_part6.md:143
msgid ""
"Move heavy logic inside `Algorithm` or `Problem`, avoid complex Python code "
"in main loop."
msgstr ""
"Move heavy logic inside `Algorithm` or `Problem`, avoid complex Python code "
"in main loop."

#: ../../source/tutorial/tutorial_part6.md:144
#, fuzzy
msgid "Use `workflow.step()` for most operations."
msgstr "Use `workflow.step()` for most operations."

#: ../../source/tutorial/tutorial_part6.md:145
msgid "Minimize per-generation diagnostics if they slow down runs."
msgstr "Minimize per-generation diagnostics if they slow down runs."

#: ../../source/tutorial/tutorial_part6.md:147
msgid "**(6) Tune Algorithm Choice**:"
msgstr "**(6) Tune Algorithm Choice**:"

#: ../../source/tutorial/tutorial_part6.md:149
msgid ""
"Try CMA-ES, GA, PSO, RVEA, etc.—no single algorithm is best for all "
"problems."
msgstr ""
"Try CMA-ES, GA, PSO, RVEA, etc.—no single algorithm is best for all "
"problems."

#: ../../source/tutorial/tutorial_part6.md:150
msgid ""
"A faster-converging algorithm may save more time than micro-optimizing one "
"that converges slowly."
msgstr ""
"A faster-converging algorithm may save more time than micro-optimizing one "
"that converges slowly."

#: ../../source/tutorial/tutorial_part6.md:152
msgid ""
"Performance tuning is iterative. With patience, you can go from hours of "
"runtime to minutes. EvoX gives you plenty of \"knobs\"—use them wisely to "
"balance speed and solution quality."
msgstr ""
"Performance tuning is iterative. With patience, you can go from hours of "
"runtime to minutes. EvoX gives you plenty of \"knobs\"—use them wisely to "
"balance speed and solution quality."

#: ../../source/tutorial/tutorial_part7.md:1
msgid "7. Practical Examples"
msgstr "7. Practical Examples"

#: ../../source/tutorial/tutorial_part7.md:3
msgid ""
"This chapter presents several complete, practical examples to demonstrate "
"how to apply the knowledge from previous chapters. We'll build an "
"optimization project from scratch and showcase how EvoX can be integrated "
"with other tools. These examples cover a range of problem types to help you "
"apply EvoX in real-world scenarios."
msgstr ""
"This chapter presents several complete, practical examples to demonstrate "
"how to apply the knowledge from previous chapters. We'll build an "
"optimization project from scratch and showcase how EvoX can be integrated "
"with other tools. These examples cover a range of problem types to help you "
"apply EvoX in real-world scenarios."

#: ../../source/tutorial/tutorial_part7.md:7
#, fuzzy
msgid "Example 1: Single-Objective Optimization"
msgstr "Example 1: Single-Objective Optimization"

#: ../../source/tutorial/tutorial_part7.md:9
msgid "**Problem**: Optimize the classic Rastrigin function:"
msgstr "**Problem**: Optimize the classic Rastrigin function:"

#: ../../source/tutorial/tutorial_part7.md:11
#, python-brace-format
msgid "f(\\mathbf{x}) = 10 d + \\sum_{i=1}^{d}[x_i^2 - 10 \\cos{(2\\pi x_i)}],"
msgstr "f(\\mathbf{x}) = 10 d + \\sum_{i=1}^{d}[x_i^2 - 10 \\cos{(2\\pi x_i)}],"

#: ../../source/tutorial/tutorial_part7.md:15
#, fuzzy, python-brace-format
msgid ""
"where $\\mathbf{x} \\in \\mathbb{R}^d$ and $d$ is the dimensionality. The "
"global optimum is 0 at the origin. The function is highly multimodal, making"
" it ideal for testing global optimization algorithms. Here's a plot of the "
"Rastrigin function"
msgstr ""
"where $\\mathbf{x} \\in \\mathbb{R}^d$ and $d$ is the dimensionality. The "
"global optimum is 0 at the origin. The function is highly multimodal, making"
" it ideal for testing global optimization algorithms. Here's a plot of the "
"Rastrigin function"

#: ../../source/tutorial/tutorial_part7.md:17
#, fuzzy
msgid "A plot of the Rastrigin function"
msgstr "A plot of the Rastrigin function"

#: ../../source/tutorial/tutorial_part7.md:22
#, fuzzy
msgid "Rastrigin function"
msgstr "Rastrigin function"

#: ../../source/tutorial/tutorial_part7.md:25
#, fuzzy
msgid ""
"In this example, we will use the Particle Swarm Optimization (PSO) algorithm"
" to optimize the 10-dimensional Rastrigin function."
msgstr ""
"In this example, we will use the Particle Swarm Optimization (PSO) algorithm"
" to optimize the 10-dimensional Rastrigin function."

#: ../../source/tutorial/tutorial_part7.md:27
msgid "**Step 1: Setup**"
msgstr "**Step 1: Setup**"

#: ../../source/tutorial/tutorial_part7.md:29
msgid ""
"Assuming you've configured your EvoX environment as explained in Chapter 2."
msgstr ""
"Assuming you've configured your EvoX environment as explained in Chapter 2."

#: ../../source/tutorial/tutorial_part7.md:31
msgid "**Step 2: Workflow Setup**"
msgstr "**Step 2: Workflow Setup**"

#: ../../source/tutorial/tutorial_part7.md:33
msgid "Create a Python script `opt_rastrigin_10.py`:"
msgstr "Create a Python script `opt_rastrigin_10.py`:"

#: ../../source/tutorial/tutorial_part7.md:42
#, fuzzy
msgid "Define the PSO algorithm:"
msgstr "Define the PSO algorithm:"

#: ../../source/tutorial/tutorial_part7.md:53
#, fuzzy
msgid "Set up the problem and workflow:"
msgstr "Set up the problem and workflow:"

#: ../../source/tutorial/tutorial_part7.md:65
#, fuzzy
msgid "**Step 3: Run Optimization**"
msgstr "**Step 3: Run Optimization**"

#: ../../source/tutorial/tutorial_part7.md:78
#: ../../source/tutorial/tutorial_part7.md:282
msgid "**Sample Output**:"
msgstr "**Sample Output**:"

#: ../../source/tutorial/tutorial_part7.md:90
msgid ""
"The PSO algorithm finds a near-optimal solution close to the origin, as "
"expected."
msgstr ""
"The PSO algorithm finds a near-optimal solution close to the origin, as "
"expected."

#: ../../source/tutorial/tutorial_part7.md:94
msgid "Example 2: Multi-Objective Optimization"
msgstr "Example 2: Multi-Objective Optimization"

#: ../../source/tutorial/tutorial_part7.md:96
msgid "**Problem**: Minimize two objectives:"
msgstr "**Problem**: Minimize two objectives:"

#: ../../source/tutorial/tutorial_part7.md:98
msgid ""
"f_1(x) = x^2, \\quad\n"
"f_2(x) = (x - 2)^2"
msgstr ""
"f_1(x) = x^2, \\quad\n"
"f_2(x) = (x - 2)^2"

#: ../../source/tutorial/tutorial_part7.md:103
msgid ""
"The Pareto front lies between $x = 0$ (optimal for $f_1$) and $x = 2$ "
"(optimal for $f_2$)."
msgstr ""
"The Pareto front lies between $x = 0$ (optimal for $f_1$) and $x = 2$ "
"(optimal for $f_2$)."

#: ../../source/tutorial/tutorial_part7.md:105
#, fuzzy
msgid "**Step 1: Environment Setup**"
msgstr "**Step 1: Environment Setup**"

#: ../../source/tutorial/tutorial_part7.md:107
#, fuzzy
msgid "Make sure you have EvoX installed with NSGA-II support."
msgstr "Make sure you have EvoX installed with NSGA-II support."

#: ../../source/tutorial/tutorial_part7.md:109
msgid "**Step 2: Define the Custom Problem**"
msgstr "**Step 2: Define the Custom Problem**"

#: ../../source/tutorial/tutorial_part7.md:111
msgid ""
"EvoX has many built-in multi-objective test problems, but for this example, "
"we will define a custom problem to optimize the two objectives:"
msgstr ""
"EvoX has many built-in multi-objective test problems, but for this example, "
"we will define a custom problem to optimize the two objectives:"

#: ../../source/tutorial/tutorial_part7.md:144
msgid "**Step 3: Define Algorithm and Workflow**"
msgstr "**Step 3: Define Algorithm and Workflow**"

#: ../../source/tutorial/tutorial_part7.md:165
msgid "**Step 4: Optimization and Visualization**"
msgstr "**Step 4: Optimization and Visualization**"

#: ../../source/tutorial/tutorial_part7.md:192
msgid ""
"We can visualize the results using Matplotlib. The blue points represent the"
" optimized population, while the red line shows the Pareto front."
msgstr ""
"We can visualize the results using Matplotlib. The blue points represent the"
" optimized population, while the red line shows the Pareto front."

#: ../../source/tutorial/tutorial_part7.md:194
#, fuzzy
msgid "A plot of the NSGA-II population"
msgstr "A plot of the NSGA-II population"

#: ../../source/tutorial/tutorial_part7.md:199
msgid "A plot of the NSGA-II population after optimization"
msgstr "A plot of the NSGA-II population after optimization"

#: ../../source/tutorial/tutorial_part7.md:202
msgid ""
"In Jupyter Notebook, you can use EvoX's built-in plotting capabilities to "
"visualize the optimization process and monitor how the population evolves "
"over generations."
msgstr ""
"In Jupyter Notebook, you can use EvoX's built-in plotting capabilities to "
"visualize the optimization process and monitor how the population evolves "
"over generations."

#: ../../source/tutorial/tutorial_part7.md:210
#, fuzzy
msgid "Example 3: Hyperparameter Optimization (HPO)"
msgstr "Example 3: Hyperparameter Optimization (HPO)"

#: ../../source/tutorial/tutorial_part7.md:212
msgid ""
"**Problem**: Tune `C` and `max_iter` of a logistic regression classifier on "
"the breast cancer dataset to maximize validation accuracy."
msgstr ""
"**Problem**: Tune `C` and `max_iter` of a logistic regression classifier on "
"the breast cancer dataset to maximize validation accuracy."

#: ../../source/tutorial/tutorial_part7.md:214
msgid "**Step 1: Load Data and Model**"
msgstr "**Step 1: Load Data and Model**"

#: ../../source/tutorial/tutorial_part7.md:231
msgid "**Step 2: Define the Problem**"
msgstr "**Step 2: Define the Problem**"

#: ../../source/tutorial/tutorial_part7.md:251
msgid "**Step 3: Workflow Setup**"
msgstr "**Step 3: Workflow Setup**"

#: ../../source/tutorial/tutorial_part7.md:270
#, fuzzy
msgid "**Step 4: Optimization**"
msgstr "**Step 4: Optimization**"

#: ../../source/tutorial/tutorial_part7.md:289
msgid ""
"With just a few lines of code, EvoX automates the tedious trial-and-error of"
" hyperparameter tuning."
msgstr ""
"With just a few lines of code, EvoX automates the tedious trial-and-error of"
" hyperparameter tuning."

#: ../../source/tutorial/tutorial_part7.md:293
msgid ""
"These practical examples illustrate how EvoX can be effectively applied "
"across various domains, from mathematical test functions to machine learning"
" workflows. Once you're comfortable with the basic structure—**Algorithm + "
"Problem + Monitor + Workflow**—you can adapt EvoX to suit almost any "
"optimization task."
msgstr ""
"These practical examples illustrate how EvoX can be effectively applied "
"across various domains, from mathematical test functions to machine learning"
" workflows. Once you're comfortable with the basic structure—**Algorithm + "
"Problem + Monitor + Workflow**—you can adapt EvoX to suit almost any "
"optimization task."

#~ msgid ""
#~ "\"A Reference Vector Guided Evolutionary Algorithm for Many-Objective "
#~ "Optimization,\" IEEE. `Link <https://ieeexplore.ieee.org/document/7386636>`"
#~ msgstr ""
#~ "面向多目标优化的参考向量引导的演化算法, IEEE. `Link "
#~ "<https://ieeexplore.ieee.org/document/7386636>`"

#~ msgid ""
#~ "\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
#~ "RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"
#~ msgstr ""
#~ "\"GPU-accelerated Evolutionary Multiobjective Optimization Using Tensorized "
#~ "RVEA\" ACM. `Link <https://dl.acm.org/doi/abs/10.1145/3638529.3654223>`"

#~ msgid "Optimizing Development for EvoX via PyTorch Advanced Techniques"
#~ msgstr "通过 PyTorch 高级技术优化 EvoX 的开发"

#~ msgid "Basic Optimization Support for Functions in PyTorch"
#~ msgstr "PyTorch中函数的基本优化支持"

#~ msgid ""
#~ "PyTorch provides fundamental optimization support for functions, primarily "
#~ "through vectorizing map (vmap) operations and Just-In-Time (JIT) "
#~ "compilation. These techniques enable efficient batch processing and enhance "
#~ "execution performance, respectively. Introductions of these optimizations "
#~ "are provided in the following sections."
#~ msgstr ""
#~ "PyTorch "
#~ "提供了对函数的基本优化支持，主要通过矢量化映射（vmap）操作和即时编译（JIT）实现。这些技术分别使得批处理更加高效并提升执行性能。关于这些优化的介绍将在以下部分提供。"

#~ msgid "Batch Processing Support through Vectorizing Map in PyTorch"
#~ msgstr "在 PyTorch 中通过矢量化映射支持批处理"

#~ msgid ""
#~ "Vectorizing map, implemented in PyTorch as "
#~ "[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html), "
#~ "is a powerful tool that takes a callable function and returns a batched "
#~ "version of it. According to specified strategy, this new function vectorizes"
#~ " the operations of the original one, which facilitates efficient batch "
#~ "processing. In EvoX, for example, this feature plays a crucial role in "
#~ "hyperparameter optimization (HPO)."
#~ msgstr ""
#~ "在PyTorch中实现的向量化映射[`torch.vmap`](https://pytorch.org/docs/stable/generated/torch.vmap.html)是一个强大的工具，它接受一个可调用函数并返回其批处理版本。根据指定的策略，这个新函数对原始函数的操作进行向量化，从而促进高效的批处理。在EvoX中，例如，这一特性在超参数优化（HPO）中起着至关重要的作用。"

#~ msgid "Just-In-Time (JIT) Support in PyTorch"
#~ msgstr "在PyTorch中支持即时编译（Just-In-Time, JIT）"

#~ msgid ""
#~ "In PyTorch, "
#~ "[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
#~ " and "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " provide two distinct types of JIT tools, supporting function performance "
#~ "optimization through tracing and scripting, respectively."
#~ msgstr ""
#~ "在 PyTorch "
#~ "中，[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
#~ " 和 "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " 提供了两种不同类型的 JIT 工具，分别通过追踪和脚本化支持函数性能优化。"

#~ msgid ""
#~ "Based on the tracing strategy, the `torch.jit.trace` method offers higher "
#~ "parsing speed and broader compatibility, such as with `torch.vmap` "
#~ "operations. Although it provides excellent support for simple functions, it "
#~ "is not suitable for complex tasks involving dynamic if-else branches and "
#~ "loop control flows."
#~ msgstr ""
#~ "根据追踪策略，`torch.jit.trace` 方法提供了更高的解析速度和更广泛的兼容性，例如与 `torch.vmap` "
#~ "操作的兼容性。尽管它对简单函数提供了出色的支持，但不适用于涉及动态 if-else 分支和循环控制流的复杂任务。"

#~ msgid ""
#~ "In the example below, the traced `vmap` function successfully returns the "
#~ "correct code representation:"
#~ msgstr "在下面的例子中，跟踪的 `vmap` 函数成功返回了正确的代码表示："

#~ msgid ""
#~ "However, dynamic python control-flow cannot be traced correctly and a "
#~ "warning will be raised:"
#~ msgstr "然而，动态的 Python 控制流无法被正确追踪，并且会发出警告："

#~ msgid ""
#~ "Alternatively, the `torch.jit.script` method, which adopts a scripting "
#~ "strategy, is better suited for complex tasks that involve dynamic control "
#~ "flows but has limited compatibility."
#~ msgstr "或者，采用脚本策略的 `torch.jit.script` 方法更适合涉及动态控制流的复杂任务，但兼容性有限。"

#~ msgid ""
#~ "In this example, the same `vmap_sample_func` function, after being scripted,"
#~ " returns an **incorrect** code representation:"
#~ msgstr "在这个例子中，相同的 `vmap_sample_func` 函数，在被脚本化后，返回了一个**不正确**的代码表示："

#~ msgid "Yet, it can correctly deal with complex dynamic python control flow:"
#~ msgstr "然而，它可以正确处理复杂的动态 Python 控制流："

#~ msgid ""
#~ "`torch.jit.script` relies on type hint to work properly. For example, any "
#~ "unannotated input argument is treated as a `torch.Tensor` while you can "
#~ "annotate some input arguments to be python types to make `torch.jit.script` "
#~ "work as intended."
#~ msgstr ""
#~ "`torch.jit.script` 依赖类型提示才能正常工作。例如，任何未注释的输入参数都会被视为 "
#~ "`torch.Tensor`，而你可以将一些输入参数注释为 python 类型，以使 `torch.jit.script` 按预期工作。"

#~ msgid "Combined Usage of JIT and Vectorizing Map in PyTorch"
#~ msgstr "在PyTorch中结合使用JIT和Vectorizing Map"

#~ msgid ""
#~ "Based on the introductions above, when `torch.jit.trace` and "
#~ "`torch.jit.script` are used in combination with `torch.vmap`, coordination "
#~ "is required due to compatibility considerations."
#~ msgstr ""
#~ "根据上述介绍，当 `torch.jit.trace` 和 `torch.jit.script` 与 `torch.vmap` "
#~ "结合使用时，由于兼容性考虑，需要进行协调。"

#~ msgid ""
#~ "The figure below illustrates the relationship between `torch.jit.script`, "
#~ "`torch.jit.trace`, and `torch.vmap`, highlighting their mutual invocation "
#~ "paths. If module A invokes module B, it implies that B can be called by A."
#~ msgstr ""
#~ "下图说明了 `torch.jit.script`、`torch.jit.trace` 和 `torch.vmap` "
#~ "之间的关系，突出显示了它们的相互调用路径。如果模块 A 调用模块 B，这意味着 B 可以被 A 调用。"

#~ msgid "JIT introduction"
#~ msgstr "JIT 介绍"

#~ msgid ""
#~ "For detailed usage of JIT and vectorizing map on PyTorch, please refer to "
#~ "the official PyTorch documentation for "
#~ "[TorchScript](#https://pytorch.org/docs/stable/jit.html) and "
#~ "[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)."
#~ msgstr ""
#~ "有关在 PyTorch 上使用 JIT 和矢量化映射的详细信息，请参阅 PyTorch 官方文档中的 "
#~ "[TorchScript](#https://pytorch.org/docs/stable/jit.html) 和 "
#~ "[`torch.vmap`](#https://pytorch.org/docs/stable/generated/torch.vmap.html)。"

#~ msgid "Specific Optimization Support in EvoX"
#~ msgstr "EvoX中的特定优化支持"

#~ msgid ""
#~ "Within EvoX, most functions are defined inside classes, particularly "
#~ "subclasses of [`ModuleBase`](#evox.core.module.ModuleBase). To provide more "
#~ "comprehensive optimization supports, EvoX offers specific enhancements."
#~ msgstr ""
#~ "在 EvoX 中，大多数函数是在类中定义的，特别是 [`ModuleBase`](#evox.core.module.ModuleBase) "
#~ "的子类中。为了提供更全面的优化支持，EvoX 提供了特定的增强功能。"

#~ msgid ""
#~ "Using JIT to Subclasses of [`ModuleBase`](#evox.core.module.ModuleBase)"
#~ msgstr "使用 JIT 到 [`ModuleBase`](#evox.core.module.ModuleBase) 的子类"

#~ msgid ""
#~ "For better understanding of this part, we need to explain three important "
#~ "functions in EvoX: [`jit_class`](#evox.core.module.jit_class), "
#~ "[`vmap`](#evox.core.jit_util.vmap) and [`jit`](l#evox.core.jit_util.jit)."
#~ msgstr ""
#~ "为了更好地理解这一部分，我们需要解释EvoX中的三个重要函数：[`jit_class`](#evox.core.module.jit_class)、[`vmap`](#evox.core.jit_util.vmap)和[`jit`](#evox.core.jit_util.jit)。"

#~ msgid "[`jit_class`](#evox.core.module.jit_class) Function"
#~ msgstr "[`jit_class`](#evox.core.module.jit_class) 函数"

#~ msgid ""
#~ "[`jit_class`](#evox.core.module.jit_class) is a helper function used to "
#~ "Just-In-Time (JIT) script of "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " or trace "
#~ "([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
#~ "jit-trace-module)) all member methods of the input class."
#~ msgstr ""
#~ "[`jit_class`](#evox.core.module.jit_class) 是一个辅助函数，用于对输入类的所有成员方法进行 Just-In-"
#~ "Time (JIT) 脚本化的 "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " 或跟踪 "
#~ "([`torch.jit.trace_module`](https://pytorch.org/docs/stable/generated/torch.jit.trace_module.html#torch-"
#~ "jit-trace-module))。"

#~ msgid "[`jit_class`](#evox.core.module.jit_class) has two parameters:"
#~ msgstr "[`jit_class`](#evox.core.module.jit_class) 有两个参数："

#~ msgid "`cls`: the original class whose member methods are to be lazy JIT."
#~ msgstr "`cls`: 原始类，其成员方法将被懒惰 JIT。"

#~ msgid ""
#~ "`trace`: whether to trace the module or to script the module. Default to "
#~ "`False`."
#~ msgstr "`trace`: 是否追踪模块或将模块脚本化。默认值为 `False`。"

#~ msgid ""
#~ "In many cases, it is not necessary to wrap your custom algorithms or "
#~ "problems with [`jit_class`](#evox.core.module.jit_class), the workflow(s) "
#~ "will do the trick for you."
#~ msgstr ""
#~ "在许多情况下，不需要用[`jit_class`](#evox.core.module.jit_class)包装您的自定义算法或问题，工作流将为您解决问题。"

#~ msgid ""
#~ "With `trace=True`, all the member functions are effectively modified to "
#~ "return `self` additionally since side-effects cannot be traced. If you want "
#~ "to preserve the side effects, please set `trace=False` and use the "
#~ "`use_state` function to wrap the member method to generate pure-functional "
#~ "(the `use_state` function will be explained in the next part)."
#~ msgstr ""
#~ "在 `trace=True` 的情况下，所有成员函数都会被有效地修改为额外返回 `self`，因为副作用无法被追踪。如果你想保留副作用，请设置 "
#~ "`trace=False` 并使用 `use_state` 函数来包装成员方法以生成纯函数（`use_state` 函数将在下一部分中解释）。"

#~ msgid ""
#~ "Similarly, all module-wide operations like `self.to(...)` can only returns "
#~ "the unwrapped module, which may not be desired. Since most of them are in-"
#~ "place operations, a simple `module.to(...)` can be used instead of `module ="
#~ " module.to(...)`."
#~ msgstr ""
#~ "类似地，所有模块级的操作如 `self.to(...)` 只能返回未包装的模块，这可能不是我们想要的。由于它们大多是就地操作，可以使用简单的 "
#~ "`module.to(...)` 来替代 `module = module.to(...)`。"

#~ msgid "[`vmap`](#evox.core.jit_util.vmap) Function"
#~ msgstr "[`vmap`](#evox.core.jit_util.vmap) 函数"

#~ msgid ""
#~ "[`vmap`](#evox.core.jit_util.vmap) function vectorized map the given "
#~ "function to its mapped version. Based on "
#~ "[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html), we "
#~ "made many improvements, and you can see "
#~ "[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) for "
#~ "more information."
#~ msgstr ""
#~ "[`vmap`](#evox.core.jit_util.vmap) 函数将给定函数矢量化映射到其映射版本。基于 "
#~ "[`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html)，我们进行了许多改进，您可以查看"
#~ " [`torch.vmap`](https://pytorch.org/docs/main/generated/torch.vmap.html) "
#~ "以获取更多信息。"

#~ msgid "[`jit`](#evox.core.jit_util.jit) Function"
#~ msgstr "[`jit`](#evox.core.jit_util.jit) 函数"

#~ msgid ""
#~ "[`jit`](#evox.core.jit_util.jit) compile the given `func` via "
#~ "[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " (`trace=True`) or "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
#~ " (`trace=False`)."
#~ msgstr ""
#~ "[`jit`](#evox.core.jit_util.jit) 使用 "
#~ "[`torch.jit.trace`](https://pytorch.org/docs/stable/generated/torch.jit.script.html)"
#~ " (`trace=True`) 或 "
#~ "[`torch.jit.script`](https://pytorch.org/docs/stable/generated/torch.jit.trace.html)"
#~ " (`trace=False`) 编译给定的 `func"

#~ msgid ""
#~ "This function wrapper effectively deals with nested JIT and vector map "
#~ "(`vmap`) expressions like `jit(func1)` -> `vmap` -> `jit(func2)`, preventing"
#~ " possible errors."
#~ msgstr ""
#~ "该函数包装器有效处理嵌套的 JIT 和向量映射 (`vmap`) 表达式，如 `jit(func1)` -> `vmap` -> "
#~ "`jit(func2)`，从而防止可能出现的错误。"

#~ msgid ""
#~ "With `trace=True`, `torch.jit.trace` cannot use SAME example input arguments"
#~ " for function of DIFFERENT parameters,e.g., you cannot pass `tensor_a, "
#~ "tensor_a` to `torch.jit.trace`d version of `f(x: torch.Tensor, y: "
#~ "torch.Tensor)`."
#~ msgstr ""
#~ "在 `trace=True` 的情况下，`torch.jit.trace` 不能对具有不同参数的函数使用相同的示例输入参数，例如，你不能将 "
#~ "`tensor_a, tensor_a` 传递给 `torch.jit.trace` 版本的 `f(x: torch.Tensor, y: "
#~ "torch.Tensor)"

#~ msgid ""
#~ "With `trace=False`, `torch.jit.script` cannot contain `vmap` expressions "
#~ "directly, please wrap them with `jit(..., trace=True)` or `torch.jit.trace`."
#~ msgstr ""
#~ "在 `trace=False` 的情况下，`torch.jit.script` 不能直接包含 `vmap` 表达式，请使用 `jit(..., "
#~ "trace=True)` 或 `torch.jit.trace` 包装它们。"

#~ msgid ""
#~ "In the [Working with Module in EvoX](#/guide/developer/1-modulebase), we "
#~ "have briefly introduced some rules about the methods inside a subclass of "
#~ "the [`ModuleBase`](#evox.core.module.ModuleBase) . Now that "
#~ "[`jit_class`](#evox.core.module.jit_class), "
#~ "[`vmap`](#evox.core.jit_util.vmap) and [`jit`](#evox.core.jit_util.jit) have"
#~ " been explained, we will explain more rules and provide some specific hints."
#~ msgstr ""
#~ "在 [EvoX 中的模块工作](#/guide/developer/1-modulebase) 中，我们简要介绍了关于 "
#~ "[`ModuleBase`](#evox.core.module.ModuleBase) 子类中方法的一些规则。现在 "
#~ "[`jit_class`](#evox.core.module.jit_class)、[`vmap`](#evox.core.jit_util.vmap)"
#~ " 和 [`jit`](#evox.core.jit_util.jit) 已经被解释，我们将解释更多规则并提供一些具体提示。"

#~ msgid "Definition of Static Methods Inside the Subclass"
#~ msgstr "子类中静态方法的定义"

#~ msgid "Inside the subclass, static methods to be JIT shall be defined like:"
#~ msgstr "在子类中，静态方法要被 JIT 定义为："

#~ msgid "Definition of Non-static Methods Inside the Subclass"
#~ msgstr "在子类中定义非静态方法"

#~ msgid ""
#~ "If a method with **Python dynamic control flows** like `if` were to be JIT, "
#~ "a separated static method with `jit(..., trace=False)` or "
#~ "`torch.jit.script_if_tracing` shall be used:"
#~ msgstr ""
#~ "如果一个方法使用了**Python动态控制流**，例如`if`，并且需要进行JIT，那么应使用一个独立的静态方法，并使用`jit(..., "
#~ "trace=False)`或`torch.jit.script_if_tracing"

#~ msgid ""
#~ "Dynamic control flow in Python refers to control structures that change "
#~ "dynamically based on conditions at runtime. `if...elif...else` Conditional "
#~ "Statements, `for`loop and `while` loop are all dynamic control flows. If you"
#~ " have to use them when defining non-static Methods inside the subclass of "
#~ "[`ModuleBase`](#evox.core.module.ModuleBase), please follow the above rule."
#~ msgstr ""
#~ "在Python中，动态控制流是指根据运行时的条件动态变化的控制结构。`if...elif...else` 条件语句、`for` 循环和 `while` "
#~ "循环都是动态控制流。如果在定义 [`ModuleBase`](#evox.core.module.ModuleBase) "
#~ "子类中的非静态方法时必须使用它们，请遵循上述规则。"

#~ msgid "Invocation of External Methods Inside the Subclass"
#~ msgstr "调用子类中的外部方法"

#~ msgid ""
#~ "Inside the subclass, external JIT methods can be invocated by the class "
#~ "methods to be JIT:"
#~ msgstr "在子类中，外部 JIT 方法可以通过类方法调用以实现 JIT："

#~ msgid "Automatically JIT for the Subclass Used with `jit_class`"
#~ msgstr "自动为使用 `jit_class` 的子类进行 JIT 处理"

#~ msgid ""
#~ "[`ModuleBase`](#evox.core.module.ModuleBase)  and its subclasses are usually"
#~ " used with [`jit_class`](#evox.core.module.jit_class) to automatically JIT "
#~ "all non-magic member methods:"
#~ msgstr ""
#~ "[`ModuleBase`](#evox.core.module.ModuleBase) 及其子类通常与 "
#~ "[`jit_class`](#evox.core.module.jit_class) 一起使用，以自动JIT所有非魔术成员方法："

#~ msgid "Invocation of External Vmap-wrapped Methods Inside the Subclass"
#~ msgstr "在子类中调用外部 Vmap 包装的方法"

#~ msgid ""
#~ "Inside the subclass, external vmap-wrapped methods can be invocated by the "
#~ "class methods to be JIT:"
#~ msgstr "在子类内部，外部 vmap 包装的方法可以通过类方法调用以实现 JIT："

#~ msgid ""
#~ "If method A invokes vmap-wrapped method B, then A and all methods invoke "
#~ "method A can not be vmap-wrapped again."
#~ msgstr "如果方法 A 调用 vmap 包装的方法 B，那么 A 和所有调用方法 A 的方法不能再次被 vmap 包装。"

#~ msgid "Internal Vmap-wrapped Methods Inside the Subclass"
#~ msgstr "子类内部的 Vmap 包装方法"

#~ msgid ""
#~ "Inside the subclass, internal vmap-wrapped methods can be  JIT by using the "
#~ "[`trace_impl`](#evox.core.module.trace_impl):"
#~ msgstr ""
#~ "在子类内部，可以使用 [`trace_impl`](#evox.core.module.trace_impl) 对内部 vmap 包装的方法进行 "
#~ "JIT。"

#~ msgid ""
#~ "If a class method use [`trace_impl`](#evox.core.module.trace_impl), it will "
#~ "be only available in the trace mode. More details about `trace_impl` will be"
#~ " shown in the next part."
#~ msgstr ""
#~ "如果一个类方法使用了[`trace_impl`](#evox.core.module.trace_impl)，它将仅在追踪模式下可用。关于`trace_impl`的更多细节将在下一部分展示。"

#~ msgid "Using `@trace_impl` and `@vmap_impl`"
#~ msgstr "使用 `@trace_impl` 和 `@vmap_impl"

#~ msgid ""
#~ "When designing a function or method, you may not always consider whether it "
#~ "is `JIT`-compatible. However, this property becomes crucial in specific "
#~ "scenarios, such as solving Hyperparameter Optimization (HPO) problems. For "
#~ "more details on deploying HPO with EvoX, refer to [Efficient HPO with "
#~ "EvoX](#/guide/user/3-hpo)."
#~ msgstr ""
#~ "在设计函数或方法时，您可能并不总是考虑它是否与`JIT`兼容。然而，这一特性在特定场景中变得至关重要，例如解决超参数优化（HPO）问题。有关使用EvoX部署HPO的更多详细信息，请参阅[Efficient"
#~ " HPO with EvoX](#/guide/user/3-hpo)。"

#~ msgid ""
#~ "A typical characteristic of such problems is that only certain parts of the "
#~ "algorithm need modification—for instance, the `step` method of an algorithm."
#~ " This allows you to avoid rewriting the entire algorithm. In such cases, you"
#~ " can use the `@trace_impl` or `@vmap_impl` decorator to rewrite the function"
#~ " as a trace-JIT-time or vmap-JIT-time proxy for the specified `target` "
#~ "method."
#~ msgstr ""
#~ "这类问题的一个典型特征是，只需要修改算法的某些部分——例如，算法的 `step` 方法。这使您可以避免重写整个算法。在这种情况下，您可以使用 "
#~ "`@trace_impl` 或 `@vmap_impl` 装饰器，将函数重写为指定 `target` 方法的 trace-JIT-time 或 "
#~ "vmap-JIT-time 代理。"

#~ msgid ""
#~ "The decorators [`@trace_impl`](#trace_impl) and [`@vmap_impl`](#vmap_impl) "
#~ "accept a single input parameter: the target method invoked when not "
#~ "tracing/vmapping JIT. These decorators are applicable **only** to member "
#~ "methods within a `jit_class`."
#~ msgstr ""
#~ "装饰器 [`@trace_impl`](#trace_impl) 和 [`@vmap_impl`](#vmap_impl) "
#~ "接受一个输入参数：在不进行追踪/vmap JIT 时调用的目标方法。这些装饰器**仅**适用于 `jit_class` 中的成员方法。"

#~ msgid ""
#~ "Since the annotated function serves as a rewritten version of the target "
#~ "function, it must maintain identical input/output signatures (e.g., number "
#~ "and types of arguments). Otherwise, the resulting behavior is undefined."
#~ msgstr "由于注释函数作为目标函数的重写版本，它必须保持相同的输入/输出签名（例如，参数的数量和类型）。否则，结果行为是未定义的。"

#~ msgid ""
#~ "If the annotated function is intended for use with `vmap`, it must satisfy "
#~ "three additional constraints:"
#~ msgstr "如果注释的函数打算与`vmap`一起使用，它必须满足三个额外的约束："

#~ msgid ""
#~ "**No In-Place Operations on Attributes:** The algorithm must not include "
#~ "methods that perform in-place operations on its attributes."
#~ msgstr "**禁止对属性进行原地操作：** 算法不得包含对其属性执行原地操作的方法。"

#~ msgid ""
#~ "**Avoid Python Control Flow:** The code logic must not rely on Python "
#~ "control flow structures. To handle Python control flow, use "
#~ "[`TracingCond`](#TracingCond), [`TracingWhile`](#TracingWhile), and "
#~ "[`TracingSwitch`](#TracingSwitch)."
#~ msgstr ""
#~ "**避免使用 Python 控制流：** 代码逻辑不能依赖于 Python 控制流结构。要处理 Python 控制流，请使用 "
#~ "[`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
#~ "[`TracingSwitch`](#TracingSwitch)。"

#~ msgid ""
#~ "**Avoid In-Place Operations on `self`:** Vectorized map in-place operations "
#~ "on `self` are not well-defined and cannot be compiled. Even if it is "
#~ "compiled successfully, you can still silently get incorrect results."
#~ msgstr ""
#~ "**避免对 `self` 进行就地操作：** 向量化映射对 `self` "
#~ "的就地操作定义不明确，无法编译。即使成功编译，您仍可能会悄无声息地得到错误的结果。"

#~ msgid "Using `use_state`"
#~ msgstr "使用 `use_state`"

#~ msgid ""
#~ "[`use_state`](#use_state) transforms a given stateful function (which "
#~ "performs in-place alterations on `nn.Module`s) into a pure-functional "
#~ "version that receives an additional `state` parameter (of type `Dict[str, "
#~ "torch.Tensor]`) and returns the altered state."
#~ msgstr ""
#~ "[`use_state`](#use_state) 将给定的有状态函数（对 `nn.Module` 进行就地更改）转换为纯函数版本，该版本接收一个额外的"
#~ " `state` 参数（类型为 `Dict[str, torch.Tensor]`），并返回更改后的状态。"

#~ msgid ""
#~ "The input `func` is the stateful function to be transformed or its generator"
#~ " function, and `is_generator` specifies whether `func` is a function or a "
#~ "function generator (e.g., a lambda that returns the stateful function). It "
#~ "defaults to `True`."
#~ msgstr ""
#~ "输入 `func` 是要转换的有状态函数或其生成器函数，而 `is_generator` 指定 `func` "
#~ "是一个函数还是一个函数生成器（例如，返回有状态函数的 lambda）。默认值为 `True"

#~ msgid "Here is a simple example:"
#~ msgstr "以下是一个简单的例子："

#~ msgid "Using `core._vmap_fix`"
#~ msgstr "使用 `core._vmap_fix"

#~ msgid ""
#~ "The module [`_vmap_fix`](#_vmap_fix) provides useful functions. After the "
#~ "automatic import, `_vmap_fix` enables `torch.vmap` to be correctly traced by"
#~ " `torch.jit.trace`, while resolving issues such as random number handling "
#~ "that couldn't be properly traced during the `vmap` process. It also provides"
#~ " the `debug_print` function, which allows dynamic printing of Tensor values "
#~ "during both `vmap` and tracing."
#~ msgstr ""
#~ "模块 [`_vmap_fix`](#_vmap_fix) 提供了有用的函数。在自动导入后，`_vmap_fix` 使 `torch.vmap` 能够被 "
#~ "`torch.jit.trace` 正确追踪，同时解决了在 `vmap` 过程中无法正确追踪的随机数处理等问题。它还提供了 `debug_print` "
#~ "函数，允许在 `vmap` 和追踪过程中动态打印 Tensor 值。"

#~ msgid ""
#~ "Detailed information can be found in the [`_vmap_fix`](#_vmap_fix) "
#~ "documentation."
#~ msgstr "详细信息可以在[`_vmap_fix`](#_vmap_fix)文档中找到。"

#~ msgid ""
#~ "To ensure the function is JIT-compilable, it must meet the conditions "
#~ "outlined in [JIT components](#/guide/developer/2-jit-able). In addition to "
#~ "these requirements, the algorithm must also satisfy the following two "
#~ "constraints:"
#~ msgstr ""
#~ "为了确保函数是 JIT 可编译的，它必须满足 [JIT components](#/guide/developer/2-jit-able) "
#~ "中列出的条件。除了这些要求外，算法还必须满足以下两个约束："

#~ msgid ""
#~ "In EvoX, we can easily make the algorithm parallelizable by the "
#~ "[`@trace_impl`](#trace_impl) decorator."
#~ msgstr "在 EvoX 中，我们可以通过 [`@trace_impl`](#trace_impl) 装饰器轻松地使算法并行化。"

#~ msgid ""
#~ "The parameter of this decorator is a non-parallelizable function, and the "
#~ "decorated function is a rewrite of the original function. Detailed "
#~ "introduction of [`@trace_impl`](#trace_impl) can be found in [JIT "
#~ "Components](#/guide/developer/2-jit-able)."
#~ msgstr ""
#~ "此装饰器的参数是一个不可并行化的函数，装饰后的函数是对原始函数的重写。关于[`@trace_impl`](#trace_impl)的详细介绍可以在[JIT"
#~ " Components](#/guide/developer/2-jit-able)中找到。"

#~ msgid ""
#~ "Under this mechanism, we can retain the original function for use outside "
#~ "HPO tasks while enabling efficient computation within HPO tasks. Moreover, "
#~ "this modification is highly convenient."
#~ msgstr "在这种机制下，我们可以保留原始函数以便在 HPO 任务之外使用，同时在 HPO 任务中实现高效计算。此外，这种修改非常方便。"

#~ msgid ""
#~ "To handle the Python control flow, we use [`TracingCond`](#TracingCond), "
#~ "[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch). "
#~ "Since, in tracing mode, variables outside the method may be incorrectly "
#~ "interpreted as static variables, we need to use state to track them. A "
#~ "detailed introduction to [`TracingCond`](#TracingCond), "
#~ "[`TracingWhile`](#TracingWhile) and [`TracingSwitch`](#TracingSwitch) can be"
#~ " found in [JIT Components](#/guide/developer/2-jit-able). Below, we provide "
#~ "two equivalent implementations for the `trace_step` method."
#~ msgstr ""
#~ "要处理 Python 控制流，我们使用 "
#~ "[`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
#~ "[`TracingSwitch`](#TracingSwitch)。由于在追踪模式中，方法外的变量可能会被错误地解释为静态变量，我们需要使用状态来跟踪它们。关于"
#~ " [`TracingCond`](#TracingCond)、[`TracingWhile`](#TracingWhile) 和 "
#~ "[`TracingSwitch`](#TracingSwitch) 的详细介绍可以在 [JIT "
#~ "Components](#/guide/developer/2-jit-able) 中找到。下面，我们提供了 `trace_step` "
#~ "方法的两个等效实现。"

#~ msgid "<br></br>"
#~ msgstr "<br></br>"

#~ msgid "To visualize in Jupyter:"
#~ msgstr "To visualize in Jupyter:"

#~ msgid "Note"
#~ msgstr "注意"

#~ msgid ""
#~ "This implementation is based on the original paper and may not be the most "
#~ "efficient implementation."
#~ msgstr "此实现基于原始论文，可能不是最有效的实现。"

#~ msgid ""
#~ "If a subclass have defined `trace_impl` of `step`, its corresponding "
#~ "`init_step` must be overwritten even though nothing special is to be "
#~ "included due to Python's object-oriented limitations."
#~ msgstr ""
#~ "如果子类定义了 `step` 的 `trace_impl` 方法，即使不需要添加任何特殊内容，由于 Python 对象模型的限制，其对应的 "
#~ "`init_step` 方法必须被覆盖重写。"

#~ msgid ""
#~ "{py:obj}`_ReplaceForwardModule <evox.core.module._ReplaceForwardModule>`"
#~ msgstr ""
#~ "{py:obj}`_ReplaceForwardModule <evox.core.module._ReplaceForwardModule>`"

#~ msgid "{py:obj}`ParameterT <evox.core.module.ParameterT>`"
#~ msgstr "{py:obj}`ParameterT <evox.core.module.ParameterT>`"

#~ msgid ""
#~ "{py:obj}`_compiled_update_dc_and_rank "
#~ "<evox.operators.selection.non_dominate._compiled_update_dc_and_rank>`"
#~ msgstr ""
#~ "{py:obj}`_compiled_update_dc_and_rank "
#~ "<evox.operators.selection.non_dominate._compiled_update_dc_and_rank>`"

#~ msgid "'compile(...)'"
#~ msgstr "'compile(...)'"

#~ msgid ""
#~ "{py:obj}`_vmap_vmap_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._vmap_vmap_mean_fit_aggregation>`"
#~ msgstr ""
#~ "{py:obj}`_vmap_vmap_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._vmap_vmap_mean_fit_aggregation>`"

#~ msgid ""
#~ "{py:obj}`_vmap_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._vmap_mean_fit_aggregation>`"
#~ msgstr ""
#~ "{py:obj}`_vmap_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._vmap_mean_fit_aggregation>`"

#~ msgid ""
#~ "{py:obj}`_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._mean_fit_aggregation>`"
#~ msgstr ""
#~ "{py:obj}`_mean_fit_aggregation "
#~ "<evox.problems.hpo_wrapper._mean_fit_aggregation>`"

#~ msgid "{py:obj}`get_sub_state <evox.problems.hpo_wrapper.get_sub_state>`"
#~ msgstr "{py:obj}`get_sub_state <evox.problems.hpo_wrapper.get_sub_state>`"

#~ msgid "Get the sub state from the tuple of states."
#~ msgstr "从状态元组中获取子状态。"

#~ msgid ""
#~ "{py:obj}`_fake_hpo_evaluate_loop "
#~ "<evox.problems.hpo_wrapper._fake_hpo_evaluate_loop>`"
#~ msgstr ""
#~ "{py:obj}`_fake_hpo_evaluate_loop "
#~ "<evox.problems.hpo_wrapper._fake_hpo_evaluate_loop>`"

#~ msgid ""
#~ "{py:obj}`_hpo_evaluate_loop <evox.problems.hpo_wrapper._hpo_evaluate_loop>`"
#~ msgstr ""
#~ "{py:obj}`_hpo_evaluate_loop <evox.problems.hpo_wrapper._hpo_evaluate_loop>`"

#~ msgid "{py:obj}`__hpo_data__ <evox.problems.hpo_wrapper.__hpo_data__>`"
#~ msgstr "{py:obj}`__hpo_data__ <evox.problems.hpo_wrapper.__hpo_data__>`"

#~ msgid "The tuple of states."
#~ msgstr "状态的元组。"

#~ msgid "The sub state."
#~ msgstr "子状态。"

#~ msgid ""
#~ "{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"
#~ msgstr ""
#~ "{py:obj}`to_jax_array <evox.problems.neuroevolution.brax.to_jax_array>`"

#~ msgid ""
#~ "{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"
#~ msgstr ""
#~ "{py:obj}`from_jax_array <evox.problems.neuroevolution.brax.from_jax_array>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_brax_main "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_main>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_brax_main "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_main>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_brax <evox.problems.neuroevolution.brax._evaluate_brax>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_brax <evox.problems.neuroevolution.brax._evaluate_brax>`"

#~ msgid ""
#~ "{py:obj}`_fake_evaluate_brax "
#~ "<evox.problems.neuroevolution.brax._fake_evaluate_brax>`"
#~ msgstr ""
#~ "{py:obj}`_fake_evaluate_brax "
#~ "<evox.problems.neuroevolution.brax._fake_evaluate_brax>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_brax_vmap_main "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_vmap_main>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_brax_vmap_main "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_vmap_main>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_brax_vmap "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_vmap>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_brax_vmap "
#~ "<evox.problems.neuroevolution.brax._evaluate_brax_vmap>`"

#~ msgid ""
#~ "{py:obj}`_fake_evaluate_brax_vmap "
#~ "<evox.problems.neuroevolution.brax._fake_evaluate_brax_vmap>`"
#~ msgstr ""
#~ "{py:obj}`_fake_evaluate_brax_vmap "
#~ "<evox.problems.neuroevolution.brax._fake_evaluate_brax_vmap>`"

#~ msgid "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"
#~ msgstr "{py:obj}`__all__ <evox.problems.neuroevolution.brax.__all__>`"

#~ msgid ""
#~ "{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"
#~ msgstr ""
#~ "{py:obj}`__brax_data__ <evox.problems.neuroevolution.brax.__brax_data__>`"

#~ msgid "['BraxProblem']"
#~ msgstr "['BraxProblem']"

#~ msgid "Warning"
#~ msgstr "警告"

#~ msgid ""
#~ "from evox import problems problem = problems.neuroevolution.Brax( ...    "
#~ "env_name=\"swimmer\", ...    policy=model, ...    max_episode_length=1000, "
#~ "...    num_episodes=3, ...    pop_size=100, ...    rotate_key=False, ...)"
#~ msgstr ""
#~ "from evox import problems\n"
#~ "problem = problems.neuroevolution.Brax(\n"
#~ "    ...    env_name=\"swimmer\",\n"
#~ "    ...    policy=model,\n"
#~ "    ...    max_episode_length=1000,\n"
#~ "    ...    num_episodes=3,\n"
#~ "    ...    pop_size=100,\n"
#~ "    ...    rotate_key=False,\n"
#~ "...)"

#~ msgid ""
#~ "{py:obj}`to_jax_array "
#~ "<evox.problems.neuroevolution.mujoco_playground.to_jax_array>`"
#~ msgstr ""
#~ "{py:obj}`to_jax_array "
#~ "<evox.problems.neuroevolution.mujoco_playground.to_jax_array>`"

#~ msgid ""
#~ "{py:obj}`from_jax_array "
#~ "<evox.problems.neuroevolution.mujoco_playground.from_jax_array>`"
#~ msgstr ""
#~ "{py:obj}`from_jax_array "
#~ "<evox.problems.neuroevolution.mujoco_playground.from_jax_array>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_mjx_main "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_main>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_mjx_main "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_main>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_mjx "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_mjx "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx>`"

#~ msgid ""
#~ "{py:obj}`_fake_evaluate_mjx "
#~ "<evox.problems.neuroevolution.mujoco_playground._fake_evaluate_mjx>`"
#~ msgstr ""
#~ "{py:obj}`_fake_evaluate_mjx "
#~ "<evox.problems.neuroevolution.mujoco_playground._fake_evaluate_mjx>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_mjx_vmap_main "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_vmap_main>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_mjx_vmap_main "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_vmap_main>`"

#~ msgid ""
#~ "{py:obj}`_evaluate_mjx_vmap "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_vmap>`"
#~ msgstr ""
#~ "{py:obj}`_evaluate_mjx_vmap "
#~ "<evox.problems.neuroevolution.mujoco_playground._evaluate_mjx_vmap>`"

#~ msgid ""
#~ "{py:obj}`_fake_evaluate_mjx_vmap "
#~ "<evox.problems.neuroevolution.mujoco_playground._fake_evaluate_mjx_vmap>`"
#~ msgstr ""
#~ "{py:obj}`_fake_evaluate_mjx_vmap "
#~ "<evox.problems.neuroevolution.mujoco_playground._fake_evaluate_mjx_vmap>`"

#~ msgid ""
#~ "{py:obj}`__all__ <evox.problems.neuroevolution.mujoco_playground.__all__>`"
#~ msgstr ""
#~ "{py:obj}`__all__ <evox.problems.neuroevolution.mujoco_playground.__all__>`"

#~ msgid ""
#~ "{py:obj}`__mjx_data__ "
#~ "<evox.problems.neuroevolution.mujoco_playground.__mjx_data__>`"
#~ msgstr ""
#~ "{py:obj}`__mjx_data__ "
#~ "<evox.problems.neuroevolution.mujoco_playground.__mjx_data__>`"

#~ msgid "['MujocoProblem']"
#~ msgstr "['MujocoProblem']"

#~ msgid ""
#~ "from evox import problems problem = problems.neuroevolution.MujocoProblem( "
#~ "...    env_name=\"SwimmerSwimmer6\", ...    policy=model, ...    "
#~ "max_episode_length=1000, ...    num_episodes=3, ...    pop_size=100, ...    "
#~ "rotate_key=False, ...)"
#~ msgstr ""
#~ "from evox import problems  \n"
#~ "problem = problems.neuroevolution.MujocoProblem(  \n"
#~ "    ...    \n"
#~ "    env_name=\"SwimmerSwimmer6\",  \n"
#~ "    ...    \n"
#~ "    policy=model,  \n"
#~ "    ...    \n"
#~ "    max_episode_length=1000,  \n"
#~ "    ...    \n"
#~ "    num_episodes=3,  \n"
#~ "    ...    \n"
#~ "    pop_size=100,  \n"
#~ "    ...    \n"
#~ "    rotate_key=False,  \n"
#~ "    ...  \n"
#~ ")  "

#~ msgid ""
#~ "{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"
#~ msgstr ""
#~ "{py:obj}`__all__ <evox.problems.neuroevolution.supervised_learning.__all__>`"

#~ msgid "['SupervisedLearningProblem']"
#~ msgstr "['监督学习问题']"

#~ msgid "{py:obj}`__all__ <evox.problems.numerical.__all__>`"
#~ msgstr "{py:obj}`__all__ <evox.problems.numerical.__all__>`"

#~ msgid ""
#~ "['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
#~ "'CEC2022', 'DTLZ1', 'DTLZ2',..."
#~ msgstr ""
#~ "['Ackley', 'Griewank', 'Rastrigin', 'Rosenbrock', 'Schwefel', 'Sphere', "
#~ "'CEC2022', 'DTLZ1', 'DTLZ2',..."

#~ msgid "{py:obj}`unique <evox.workflows.eval_monitor.unique>`"
#~ msgstr "{py:obj}`unique <evox.workflows.eval_monitor.unique>`"

#~ msgid ""
#~ "Return the unique elements of the input tensor, as well as the unique index."
#~ msgstr "返回输入张量的唯一元素及其唯一索引。"

#~ msgid ""
#~ "If any of `full_fit_history` or `full_sol_history` is set to True, this "
#~ "monitor will introduce a graph break in `torch.compile`."
#~ msgstr ""
#~ "如果 `full_fit_history` 或 `full_sol_history` 中的任何一个被设置为 True，这个监视器将在 "
#~ "`torch.compile` 中引入一个图断点。"

#~ msgid "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"
#~ msgstr "{py:obj}`_NegModule <evox.workflows.std_workflow._NegModule>`"

#~ msgid "Whether to scramble the order of the samples. Defaults to True."
#~ msgstr "是否打乱样本的顺序。默认为 True。"
