# 4. 进阶功能

EvoX 提供了许多**进阶功能**，来满足更复杂的需求。在熟悉基本用法之后，本章将介绍框架定制化配置、管理可选的插件模块，以及对性能进行优化的技巧等，以便您在需要时对 EvoX 进行扩展和调优。

## 定制化配置

EvoX 的默认设置已经适用于多数情况，但在一些场景下您可能希望定制框架的行为或参数。例如：

- **调整算法参数**：除了基本的种群规模、迭代次数，许多算法还有高级参数可供调整。例如 CMA-ES 算法的初始协方差、NSGA-II 的拥挤距离参数等。通过传递参数给算法构造函数即可实现。例如：`GA(crossover_prob=0.9, mutation_prob=0.1)` 自定义遗传算法的交叉和变异概率。调节这些参数可以微调算法性能。建议参考 EvoX 文档中对各算法类的 API 说明，其中列出了可配置的参数及默认值。

- **更换算子组件**：您可以替换算法内部使用的进化算子（如选择策略、变异策略等）。某些算法类允许传入自定义的算子对象。例如，一个差分进化（DE）算法可能支持自定义变异算子，则您可以提供一个自定义函数或Operator类。EvoX 的模块化设计允许这样“插件式”地更换组件。这需要对算法实现有一定了解，一般在标准算法够用时不必修改。

- **配置多目标优化设置**：如果进行多目标优化，可能需要设置目标偏好或权重，例如在加权和法中设置权重向量，或在进化过程中调整参考点。这些配置通常通过问题类或算法类提供的参数来实现。例如 `problem = DTLZ2(d=12, m=3)` 定义了12维3目标问题；对于某些算法可以传入参数自定义参考向量集。阅读算法文档以了解这些选项可以帮助您更好地定制多目标优化行为。

- **日志和输出**：默认的 `EvalMonitor` 已经记录了主要的优化指标。如果您需要记录额外信息（比如每代种群的多样性、平均适应度等），可以定制监控器或在循环中手动记录。对于大规模长时间运行的任务，您可能希望将日志输出到文件。可以通过Python的日志库或简单的文件读写，把每代结果追加写入文件，便于后续分析。

总之，定制化配置意味着根据具体任务对EvoX的默认行为做修改。在大多数情况下，这涉及更深入地使用EvoX提供的API，在**开发与扩展**章节我们还会提及。作为初学者，不妨记住：EvoX 提供的灵活接口能让有经验的用户几乎调整框架内的任何细节，但初期也可以先依赖默认配置快速得到结果。

## 插件管理

“插件”在此指 EvoX 的一些可选组件或扩展功能模块。例如，可视化工具、强化学习环境接口、以及EvoX生态下的姊妹项目等，都可以看作插件式的扩展。在EvoX中管理这些插件主要体现在**安装和使用可选模块**上。以下是几个重要的扩展及其管理方法：

- **可视化插件**：EvoX 内置了 `evox.vis_tools` 模块，包含如 `plot` 子模块用于绘制图表，以及 `.exv` 日志格式支持实时数据流。要使用这些可视化功能，需要在安装时包含 `vis` 扩展选项，即执行 `pip install evox[vis]`（如果当初未安装，可随时重新安装或使用 `pip install plotly` 等满足依赖）。使用可视化工具时，一般会在监控器记录数据后调用绘图函数。例如前述的 `EvalMonitor.plot()` 就依赖 `vis_tools.plot` 模块来生成图形。因此，确保此插件已安装能避免运行时报找不到`matplotlib`等库。

- **神经进化插件**：EvoX 提供对强化学习环境（如 Brax 物理引擎）的支持，以及对神经网络个体的优化（神经进化）支持。这部分功能被归类为 `neuroevolution` 扩展。在安装时可通过 `pip install "evox[neuroevolution]"` 一并安装。其中包括 Google Brax 库、Gym 等。安装后，您可以使用 `evox.problems.neuroevolution` 模块下的环境包装器类（如 `BraxProblem`）来将强化学习环境封装为优化问题。此外还有实用工具如 `ParamsAndVector`，可将 PyTorch 模型参数展开为向量便于演化算法处理。插件管理上，需要注意 Brax 只支持 Linux 或 Windows 的 WSL 环境，如果在Windows原生 Python 上使用可能有限制（可能只能在CPU上进行计算）。总之，通过安装/卸载对应扩展，可以启用或禁用 EvoX 的这些特定功能模块。

- **姊妹项目**：EvoX 项目有一些相关的扩展项目，如 EvoRL（专注进化强化学习）、EvoGP（GPU加速的遗传编程）等。这些项目与EvoX一脉相承，接口和设计理念类似。如果您的任务更专注于某一领域（比如强化学习），可以考虑使用这些专门的框架。插件管理在此指，如果同时使用它们，需要确保版本匹配且依赖满足。例如 EvoRL 基于 JAX 实现，使用前需安装 JAX 和 Brax 环境，而 EvoGP 可能需要额外的符号树处理库等。在一个Python环境中共存多个相关库时，注意依赖版本即可。EvoX 和其姊妹库之间通常不会冲突，可以把它们看成互补工具，在主项目中调用。如果暂时不需要，可不安装以保持环境简洁。

- **自定义插件**：由于EvoX模块化设计，用户也可以开发自己的“插件”。例如，您可以实现一个自定义的 Monitor 类，记录特殊指标，然后在Workflow中使用它；或者实现一个自定义 Problem 子类包装第三方模拟器，使其适配 EvoX 优化流程。这些都相当于对EvoX的功能扩充。良好的实践是遵循EvoX的接口规范，例如确保自定义Problem有 `evaluate()` 接口，自定义Monitor继承自EvoX的基类等等。在调试通过后，您甚至可以贡献这些自定义插件给 EvoX 的未来版本。

总体来说，EvoX 的插件管理更多是体现在**灵活拓展和依赖管理**上。初学者在第一次安装时，可以根据需求选择是否安装 `vis` 和 `neuroevolution` 扩展。如果一开始未安装某扩展，后续需要时再安装也是可以的。利用好这些插件，您可以方便地对优化过程进行监控、并将EvoX与其他工具融合，实现强大的功能。

## 性能优化

性能是 EvoX 的一大优势。即使是同一算法，相比传统CPU实现，EvoX 利用GPU可以实现若干数量级的提速。然而，要充分榨取性能潜力，还需要了解一些优化技巧：

- **利用GPU并行**：确保你的代码确实在GPU上运行是首要的。前面提到过，要使用GPU，需要安装支持 CUDA 的 PyTorch 并将数据迁移到GPU设备。如果发现运行速度不理想，检查是否真的启用了GPU（例如打印 `torch.cuda.is_available()` 结果，应为True）。如果 GPU 存在但未被使用，可能是张量默认创建在 CPU 导致的。解决办法是显式指定`device`或将数据迁移。EvoX 算法内部会试图使用输入张量所在的设备，因此只要保证算法初始化用的张量（如 lb/ub 边界等）在 CUDA 上，整个演化过程就会在GPU进行。对于多 GPU 环境，EvoX目前一般**单进程使用一块 GPU **。如果想并行利用多块GPU，可以考虑使用多进程，每个进程绑定一块不同的 GPU 执行不同的优化任务，或未来版本提供的多 GPU 协调功能。

- **并行评估**：演化算法的瓶颈之一在于**适应度评估**。如果每个候选解的评估相互独立，可以并行进行。EvoX 在可能的情况下会对问题评估进行批量并行处理。例如对于神经网络评估、多项式计算等，可以借助 GPU 的并行一次算完一批个体的适应度。如果您的自定义问题计算耗时较长，尽量向量化地计算，将多个输入一起评估而不是用Python循环逐个评估。这样可充分利用 PyTorch 的并行计算能力。简而言之，让**问题的`evaluate()` 函数对种群批量计算**而非单个计算，可以极大提高效率。

- **编译优化**：PyTorch 2.0 引入了 `torch.compile` 功能，能够对模型/函数进行JIT编译以提升性能。如果您的优化问题涉及复杂的PyTorch计算模型，尝试在评估前对模型进行编译：例如

  ```python
  jit_state_step = torch.compile(workflow.step())
  ```

  这样可获得更佳性能。
  ```{note}
  需要注意的是，一些情况下编译会增加前期开销(部分算法或者问题本身也可能不支持`torch.complie`)，适合长时间大批量的评估任务。如果您在 Windows 上使用`torch.compile`，请确保安装了Triton（见前述安装部分）以支持这一特性。
  ```

- **合理设置种群规模**：较大的种群可以增加多样性、提高全局搜索能力，但也直接增加每代评估开销。要平衡算法质量和速度，您可以调整 `pop_size` 看对总运行时间的影响。有 GPU 的情况下，适度增大种群（利用GPU的并行算力）常常不会线性增加时间 （因为 GPU 并行计算的特性）。但过大也可能导致显存占用过高。如果发现显存不足，可以减小种群规模或问题维度，或者使用半精度浮点（FP16）等技术降低单次计算量（这需要PyTorch支持，通过 `torch.set_float32_matmul_precision('medium')` 等方法设置）。

- **减少 Python 开销**：EvoX 已经尽量将核心计算转移到`torch.Tensor`张量计算中，但在用户编写的循环或自定义算子中，也应避免过多纯 Python 操作。比如在 `step()` 循环中，不要打印过于频繁（I/O开销大），不要进行大量列表操作或转换类型。保持代码的矢量化和张量化，可以让底层 C++/CUDA 代码高效运行，减少 Python 解释器的瓶颈。

- **分布式部署**：对于超级大规模的问题，可以考虑利用多台机器分布式运行。EvoX 理论上支持多节点（通过底层通信和分片）。尽管对于初学者这不是立即用到的功能，但了解其存在很重要。如果您有 GPU 集群资源，可以查阅 EvoX 文档中关于多节点部署的部分。通常需要设置环境变量或使用特定的 launcher 来启动同步的多个进程。由于 EvoX的独特架构，这可能比传统 MPI 框架更容易：据官方介绍，同一套代码无需修改即可在单节点或多节点模式下运行。当然，实际操作要确保各节点间网络通信良好，配置相应的主机地址等。初次尝试建议先在单机的多进程（模拟多节点）上测试。

- **性能调试**：如果想进一步分析性能瓶颈，推荐使用一些工具例如 PyTorch 自带的 profiler 或 Python 的 cProfile。通过这些工具，您可以查明时间主要花在了算法内部的哪个步骤。比如是评估函数耗时还是算法选择阶段耗时，从而有针对性地优化（比如缓存重复计算的中间结果等）。EvoX 追求高性能，但具体任务中仍可能有不同瓶颈，需要具体分析。

总结来说，EvoX 已经在架构层面做了大量优化，但用户仍可通过**正确使用GPU**、**批量计算**、**调整参数**等手段进一步提高效率。在追求速度的同时，也应关注结果质量，找到二者的平衡点。随着您对EvoX更熟悉，优化性能将变得驾轻就熟。
